"""
Exploit Agent for Nexus Hunter
Orchestrates all exploitation and vulnerability testing agents
"""

import asyncio
import time
from typing import Dict, List, Any, Optional
from loguru import logger

from agents.base import BaseAgent

# Import all exploitation agents  
from agents.exploitation_agents.sql_injection_agent import SQLInjectionAgent
from agents.exploitation_agents.advanced_xss_agent import AdvancedXSSAgent
from agents.exploitation_agents.xss_agent import XSSAgent
from agents.exploitation_agents.rce_agent import RCEAgent
from agents.exploitation_agents.enhanced_command_injection_agent import EnhancedCommandInjectionAgent
from agents.exploitation_agents.guaranteed_vulns_agent import GuaranteedVulnsAgent
from agents.exploitation_agents.lfi_agent import LFIAgent
from agents.exploitation_agents.ssrf_agent import SSRFAgent
from agents.exploitation_agents.xxe_agent import XXEAgent
from agents.exploitation_agents.nosql_injection_agent import NoSQLInjectionAgent
from agents.exploitation_agents.template_injection_agent import TemplateInjectionAgent
from agents.exploitation_agents.file_upload_agent import FileUploadAgent
from agents.exploitation_agents.deserialization_agent import DeserializationAgent
from agents.exploitation_agents.business_logic_agent import BusinessLogicAgent
from agents.exploitation_agents.ldap_injection_agent import LDAPInjectionAgent
from agents.exploitation_agents.sqlmap_agent import SQLMapAgent

# Import all vulnerability assessment agents
from agents.vulnerability_agents.nuclei_agent import NucleiAgent
from agents.vulnerability_agents.ffuf_agent import FfufAgent
from agents.vulnerability_agents.wafw00f_agent import Wafw00fAgent
from agents.vulnerability_agents.ssl_tls_agent import SSLTLSAgent
from agents.vulnerability_agents.api_security_agent import APISecurityAgent
from agents.vulnerability_agents.jwt_security_agent import JWTSecurityAgent
from agents.vulnerability_agents.websocket_security_agent import WebSocketSecurityAgent
from agents.vulnerability_agents.secret_agent import SecretAgent
from agents.vulnerability_agents.secrets_agent import SecretsAgent
from agents.vulnerability_agents.supply_chain_security_agent import SupplyChainSecurityAgent
from agents.vulnerability_agents.ai_ml_security_agent import AIMLSecurityAgent


class ExploitAgent(BaseAgent):
    """Orchestrates all exploitation and vulnerability testing agents"""
    
    def __init__(self):
        super().__init__("ExploitAgent")
        
        # Initialize REAL professional exploitation agents that use dynamic URL discovery
        self.exploitation_agents = {
            "sql_injection": SQLInjectionAgent(),          # Professional SQL injection testing
            "xss": XSSAgent(),                              # XSS testing with ReconAgent URLs
            "command_injection": EnhancedCommandInjectionAgent(),  # RCE testing
            "lfi": LFIAgent(),                              # LFI testing
            "ssrf": SSRFAgent(),                            # SSRF testing
            "xxe": XXEAgent(),                              # XXE testing
            "nosql_injection": NoSQLInjectionAgent(),       # NoSQL injection
            "template_injection": TemplateInjectionAgent(), # SSTI testing
            "file_upload": FileUploadAgent(),               # File upload vulnerabilities
            "business_logic": BusinessLogicAgent(),         # Business logic flaws
        }
        
        # Disabled agents (advanced/optional)
        self.disabled_exploitation_agents = {
            "advanced_xss": AdvancedXSSAgent(),     # More aggressive XSS testing
            "rce": RCEAgent(),                       # Redundant with command_injection
            "deserialization": DeserializationAgent(),
            "ldap_injection": LDAPInjectionAgent(),
            "sqlmap": SQLMapAgent(),                 # External tool dependency
            "guaranteed_vulns": GuaranteedVulnsAgent(),  # Hardcoded test agent - only for known apps
        }
        
        # Initialize all vulnerability assessment agents
        self.vulnerability_agents = {
            # Disabled agents that create invalid entries
            # "supply_chain": SupplyChainSecurityAgent(),  # Creates N/A vulnerabilities
        }
        
        # Disabled to focus on real web vulnerabilities
        self.disabled_vulnerability_agents = {
            "nuclei": NucleiAgent(),
            "ffuf": FfufAgent(),
            "wafw00f": Wafw00fAgent(),
            "ssl_tls": SSLTLSAgent(),
            "api_security": APISecurityAgent(),
            "jwt_security": JWTSecurityAgent(),
            "websocket_security": WebSocketSecurityAgent(),
            "secret": SecretAgent(),
            "secrets": SecretsAgent(),
            "supply_chain": SupplyChainSecurityAgent(),
            "ai_ml_security": AIMLSecurityAgent()
        }
        
        # Combined agent registry
        self.all_agents = {**self.exploitation_agents, **self.vulnerability_agents}
        
        logger.info(f"ðŸ›¡ï¸ ExploitAgent initialized with {len(self.all_agents)} specialized agents")
    
    async def execute(self, target_data: Dict[str, Any], **kwargs) -> Dict[str, Any]:
        """Execute comprehensive vulnerability and exploitation testing"""
        
        config = kwargs.get('config', {})
        scan_type = config.get('scan_type', 'comprehensive')  # comprehensive, exploitation_only, vulnerability_only
        target = target_data.get("target", "unknown")
        
        results = {
            "agent": "ExploitAgent",
            "target": target,
            "timestamp": time.time(),
            "scan_type": scan_type,
            "vulnerabilities": [],
            "total_tests": 0,
            "categories_tested": [],
            "scan_metadata": {},
            "agent_results": {},
            "risk_assessment": {}
        }
        
        try:
            logger.info(f"ðŸŽ¯ Starting {scan_type} security testing for {target}")
            
            # Phase 1: Vulnerability Assessment
            if scan_type in ['comprehensive', 'vulnerability_only']:
                await self.update_progress("vulnerability_assessment", {
                    "status": "Running vulnerability assessment agents",
                    "phase": "1/3" if scan_type == 'comprehensive' else "1/1"
                })
                
                vuln_results = await self._run_vulnerability_assessment(target_data, config)
                results["agent_results"]["vulnerability_assessment"] = vuln_results
                results["vulnerabilities"].extend(vuln_results.get("vulnerabilities", []))
                results["categories_tested"].extend(vuln_results.get("categories", []))
            
            # Phase 2: Exploitation Testing
            if scan_type in ['comprehensive', 'exploitation_only']:
                await self.update_progress("exploitation_testing", {
                    "status": "Running exploitation agents",
                    "phase": "2/3" if scan_type == 'comprehensive' else "1/1"
                })
                
                exploit_results = await self._run_exploitation_testing(target_data, config)
                results["agent_results"]["exploitation_testing"] = exploit_results
                results["vulnerabilities"].extend(exploit_results.get("vulnerabilities", []))
                results["categories_tested"].extend(exploit_results.get("categories", []))
            
            # Phase 3: Risk Assessment and Consolidation
            if not self.is_cancelled():
                await self.update_progress("risk_assessment", {
                    "status": "Analyzing results and calculating risk",
                    "phase": "3/3"
                })
                
                results["risk_assessment"] = await self._calculate_comprehensive_risk(results)
                results["scan_metadata"] = await self._generate_scan_metadata(results)
            
            # Calculate totals
            results["total_tests"] = len(results["categories_tested"])  # FIXED: Count of agent categories tested
            results["scan_metadata"]["total_vulnerabilities"] = len(results["vulnerabilities"])
            results["scan_metadata"]["critical_count"] = len([v for v in results["vulnerabilities"] if v.get("severity") == "critical"])
            results["scan_metadata"]["high_count"] = len([v for v in results["vulnerabilities"] if v.get("severity") == "high"])
            
            logger.info(f"ðŸŽ¯ Security testing completed. Found {len(results['vulnerabilities'])} vulnerabilities")
            return results
            
        except Exception as e:
            logger.error(f"âŒ Security testing failed: {e}")
            results["error"] = str(e)
            return results
    
    async def _run_vulnerability_assessment(self, target_data: Dict[str, Any], config: Dict[str, Any]) -> Dict[str, Any]:
        """Run all vulnerability assessment agents"""
        results = {
            "vulnerabilities": [],
            "categories": [],
            "agent_results": {}
        }
        
        target = target_data.get("target", "")
        recon_data = target_data.get("recon_data", {})  # Get recon data
        discovered_urls = target_data.get("discovered_urls", [])
        
        # Also check config for discovered URLs (for direct vulnerability scans)
        config_urls = config.get("discovered_urls", [])
        if config_urls:
            discovered_urls.extend(config_urls)
        
        logger.info(f"ðŸ” Vulnerability assessment with {len(discovered_urls)} discovered URLs from recon")
        
        # Select agents based on configuration
        selected_agents = config.get('vulnerability_agents', list(self.vulnerability_agents.keys()))
        
        for agent_name in selected_agents:
            if self.is_cancelled():
                break
                
            if agent_name not in self.vulnerability_agents:
                continue
                
            try:
                logger.info(f"ðŸ” Running {agent_name} vulnerability assessment")
                agent = self.vulnerability_agents[agent_name]
                
                # Prepare enhanced config with recon data
                enhanced_config = {
                    **config,
                    "recon_data": recon_data,
                    "discovered_urls": discovered_urls,
                    "discovered_services": target_data.get("discovered_services", {}),
                    "discovered_technologies": target_data.get("discovered_technologies", {}),
                    "discovered_ports": target_data.get("discovered_ports", {})
                }
                
                # Execute agent based on its interface WITH TIMEOUT (CRITICAL FIX)
                try:
                    if hasattr(agent, 'scan'):
                        agent_result = await asyncio.wait_for(
                            agent.scan(target, **enhanced_config),
                            timeout=60  # 1 minute max per vulnerability agent
                        )
                    elif hasattr(agent, 'execute'):
                        agent_result = await asyncio.wait_for(
                            agent.execute(target, enhanced_config),
                            timeout=60  # 1 minute max per vulnerability agent
                        )
                    else:
                        logger.warning(f"Agent {agent_name} has no scan or execute method")
                        continue
                except asyncio.TimeoutError:
                    logger.warning(f"â±ï¸ {agent_name} timed out after 60 seconds")
                    continue
                
                # Process results - handle both dict and AgentResult formats
                if agent_result:
                    # Handle AgentResult objects
                    if hasattr(agent_result, 'success') and hasattr(agent_result, 'data'):
                        if agent_result.success and agent_result.data:
                            vulnerabilities = agent_result.data.get("vulnerabilities", [])
                            results["vulnerabilities"].extend(vulnerabilities)
                            results["categories"].append(agent_name)
                            results["agent_results"][agent_name] = agent_result.data
                            
                            logger.info(f"âœ… {agent_name}: Found {len(vulnerabilities)} vulnerabilities")
                        else:
                            logger.warning(f"âš ï¸ {agent_name}: Agent returned unsuccessful result")
                    # Handle dict format
                    elif isinstance(agent_result, dict) and agent_result.get("success", True):
                        vulnerabilities = agent_result.get("vulnerabilities", [])
                        results["vulnerabilities"].extend(vulnerabilities)
                        results["categories"].append(agent_name)
                        results["agent_results"][agent_name] = agent_result
                        
                        logger.info(f"âœ… {agent_name}: Found {len(vulnerabilities)} vulnerabilities")
                    else:
                        logger.warning(f"âš ï¸ {agent_name}: No results or failed")
                else:
                    logger.warning(f"âš ï¸ {agent_name}: No results returned")
                
                # Rate limiting between agents
                await asyncio.sleep(1)
                
            except Exception as e:
                logger.error(f"âŒ {agent_name} failed: {e}")
                continue
        
        return results
    
    async def _run_exploitation_testing(self, target_data: Dict[str, Any], config: Dict[str, Any]) -> Dict[str, Any]:
        """Run all exploitation testing agents"""
        results = {
            "vulnerabilities": [],
            "categories": [],
            "agent_results": {}
        }
        
        target = target_data.get("target", "")
        
        # CRITICAL FIX: Get recon data and discovered URLs (same as vulnerability assessment)
        recon_data = target_data.get("recon_data", {})
        discovered_urls = target_data.get("discovered_urls", [])
        
        # Also check config for discovered URLs
        config_urls = config.get("discovered_urls", [])
        if config_urls:
            discovered_urls.extend(config_urls)
        
        # ðŸš€ CRITICAL OPTIMIZATION: Filter URLs to only include complete endpoints
        # Remove partial paths like /api/vulnerable and /api/vulnerable/xss/
        # Keep only full endpoints like /api/vulnerable/xss/comment
        discovered_urls = self._filter_complete_endpoints(discovered_urls)
        
        logger.info(f"ðŸ’¥ Exploitation testing with {len(discovered_urls)} discovered URLs from recon")
        
        # Prepare enhanced config with recon data (SAME AS VULNERABILITY ASSESSMENT)
        enhanced_config = {
            **config,
            "recon_data": recon_data,
            "discovered_urls": discovered_urls,
            "services": target_data.get("discovered_services", {}),
            "technologies": target_data.get("discovered_technologies", {}),
            "ports": target_data.get("discovered_ports", {})
        }
        
        # Select agents based on configuration
        selected_agents = config.get('exploitation_agents', list(self.exploitation_agents.keys()))
        
        # ðŸš€ CRITICAL OPTIMIZATION 2: Run agents in PARALLEL
        logger.info(f"ðŸš€ Running {len(selected_agents)} agents in PARALLEL for speed")
        
        async def run_single_agent(agent_name: str):
            """Run single agent with timeout and error handling"""
            if agent_name not in self.exploitation_agents:
                return None
            
            try:
                logger.info(f"ðŸ’¥ Running {agent_name} exploitation testing")
                agent = self.exploitation_agents[agent_name]
                
                try:
                    if hasattr(agent, 'scan'):
                        agent_result = await asyncio.wait_for(
                            agent.scan(target, **enhanced_config),
                            timeout=180  # CRITICAL FIX: Increased from 90s to 180s to prevent data loss
                        )
                    elif hasattr(agent, 'execute'):
                        agent_result = await asyncio.wait_for(
                            agent.execute(target, enhanced_config),
                            timeout=180  # CRITICAL FIX: Increased from 90s to 180s to prevent data loss
                        )
                    else:
                        logger.warning(f"Agent {agent_name} has no scan or execute method")
                        return None
                except asyncio.TimeoutError:
                    logger.error(f"â±ï¸ ðŸ› CRITICAL: {agent_name} timed out after 180 seconds - vulnerabilities may be lost!")
                    return None
                
                return (agent_name, agent_result)
                
            except Exception as e:
                logger.error(f"âŒ {agent_name} error: {e}")
                return None
        
        # Execute all agents concurrently
        agent_tasks = [run_single_agent(name) for name in selected_agents if not self.is_cancelled()]
        completed_results = await asyncio.gather(*agent_tasks, return_exceptions=True)
        
        # Track unique vulnerabilities to prevent duplicates
        seen_vulns = set()
        
        def get_vuln_signature(vuln):
            """Create a unique signature for a vulnerability"""
            vtype = vuln.get('type', 'Unknown')
            endpoint = vuln.get('endpoint', vuln.get('url', ''))
            param = vuln.get('parameter', vuln.get('param', ''))
            method = vuln.get('method', '')
            return f"{vtype}|{endpoint}|{param}|{method}"
        
        # Process results from all agents
        for result in completed_results:
            if result is None or isinstance(result, Exception):
                continue
            
            agent_name, agent_result = result
            
            if agent_result:
                # DEBUG: Log what we received
                logger.debug(f"ðŸ” {agent_name} returned: type={type(agent_result)}, keys={list(agent_result.keys()) if isinstance(agent_result, dict) else 'N/A'}")
                
                vulnerabilities = []
                # Handle AgentResult objects
                if hasattr(agent_result, 'success') and hasattr(agent_result, 'data'):
                    if agent_result.success and agent_result.data:
                        vulnerabilities = agent_result.data.get("vulnerabilities", [])
                        results["categories"].append(agent_name)
                        results["agent_results"][agent_name] = agent_result.data
                    else:
                        logger.warning(f"âš ï¸ {agent_name}: Agent returned unsuccessful result")
                # Handle dict format
                elif isinstance(agent_result, dict) and agent_result.get("success", True):
                    vulnerabilities = agent_result.get("vulnerabilities", [])
                    results["categories"].append(agent_name)
                    results["agent_results"][agent_name] = agent_result
                else:
                    logger.warning(f"âš ï¸ {agent_name}: No results or failed")
                
                # CRITICAL FIX: Deduplicate vulnerabilities
                unique_vulns = []
                duplicates_found = 0
                for vuln in vulnerabilities:
                    sig = get_vuln_signature(vuln)
                    if sig not in seen_vulns:
                        seen_vulns.add(sig)
                        unique_vulns.append(vuln)
                    else:
                        duplicates_found += 1
                
                results["vulnerabilities"].extend(unique_vulns)
                
                if duplicates_found > 0:
                    logger.info(f"âœ… {agent_name}: Found {len(vulnerabilities)} vulnerabilities ({duplicates_found} duplicates removed, {len(unique_vulns)} unique)")
                else:
                    logger.info(f"âœ… {agent_name}: Found {len(unique_vulns)} vulnerabilities")
        
        return results
    
    async def _calculate_comprehensive_risk(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Calculate comprehensive risk assessment"""
        vulnerabilities = results.get("vulnerabilities", [])
        
        # Risk scoring weights
        severity_weights = {"critical": 10, "high": 7, "medium": 4, "low": 2, "info": 1}
        total_score = sum(severity_weights.get(v.get("severity", "low"), 1) for v in vulnerabilities)
        
        # Risk level determination
        if total_score >= 50:
            risk_level = "CRITICAL"
        elif total_score >= 25:
            risk_level = "HIGH"
        elif total_score >= 10:
            risk_level = "MEDIUM"
        else:
            risk_level = "LOW"
        
        # Vulnerability categories analysis
        categories = {}
        for vuln in vulnerabilities:
            category = vuln.get("category", "Unknown")
            if category not in categories:
                categories[category] = {"count": 0, "max_severity": "info"}
            categories[category]["count"] += 1
            
            # Track highest severity per category
            current_severity = vuln.get("severity", "info")
            if severity_weights.get(current_severity, 0) > severity_weights.get(categories[category]["max_severity"], 0):
                categories[category]["max_severity"] = current_severity
        
        return {
            "overall_risk_level": risk_level,
            "total_risk_score": total_score,
            "vulnerability_categories": categories,
            "critical_count": len([v for v in vulnerabilities if v.get("severity") == "critical"]),
            "high_count": len([v for v in vulnerabilities if v.get("severity") == "high"]),
            "medium_count": len([v for v in vulnerabilities if v.get("severity") == "medium"]),
            "low_count": len([v for v in vulnerabilities if v.get("severity") == "low"]),
            "total_vulnerabilities": len(vulnerabilities)
        }
    
    async def _generate_scan_metadata(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Generate comprehensive scan metadata"""
        return {
            "scan_duration": "completed",
            "agents_executed": len(results.get("categories_tested", [])),
            "total_agents_available": len(self.all_agents),
            "coverage_percentage": round(len(results.get("categories_tested", [])) / len(self.all_agents) * 100, 2),
            "scan_timestamp": time.time(),
            "scan_type": results.get("scan_type", "comprehensive")
        }
    
    def get_available_agents(self) -> Dict[str, List[str]]:
        """Get list of all available agents by category"""
        return {
            "exploitation_agents": list(self.exploitation_agents.keys()),
            "vulnerability_agents": list(self.vulnerability_agents.keys())
        }
    
    def _filter_complete_endpoints(self, urls: List) -> List:
        """
        ðŸš€ CRITICAL OPTIMIZATION: Filter URLs to only keep complete endpoints
        
        Rules:
        - Keep: /api/vulnerable/xss/comment (full endpoint with action)
        - Remove: /api/vulnerable/xss/ (partial path with trailing slash)
        - Remove: /api/vulnerable (too generic)
        - Keep: URLs with query parameters (already complete)
        
        This reduces testing from 102 URLs to ~20-30 meaningful endpoints
        """
        filtered = []
        seen = set()
        
        for url_data in urls:
            # Handle both dict and string formats
            url = url_data.get("url", "") if isinstance(url_data, dict) else str(url_data)
            
            if not url:
                continue
            
            # Parse URL
            from urllib.parse import urlparse
            parsed = urlparse(url)
            path = parsed.path
            
            # RULE 1: Keep if has query parameters (complete endpoint)
            if parsed.query:
                if url not in seen:
                    filtered.append(url_data)
                    seen.add(url)
                continue
            
            # RULE 2: Remove trailing slash - these are directories, not endpoints
            if path.endswith('/') and path != '/':
                logger.debug(f"Skipping directory path: {url}")
                continue
            
            # RULE 3: Path must have at least 2 parts for API endpoints
            clean_path = path.strip('/')
            path_parts = [p for p in clean_path.split('/') if p]
            
            if len(path_parts) < 2:
                logger.debug(f"Skipping short path: {url}")
                continue
            
            # RULE 4: Skip generic parent paths
            # Skip paths that are just: /api, /api/vulnerable, /vulnerable, etc.
            last_part = path_parts[-1] if path_parts else ""
            generic_parts = ['api', 'vulnerable', 'v1', 'v2', 'admin', 'user', 'auth', 'test']
            
            if last_part in generic_parts:
                logger.debug(f"Skipping generic path: {url}")
                continue
            
            # RULE 5: Keep endpoints with specific actions/resources
            # Examples: /api/vulnerable/xss/comment, /api/users/profile, /login
            # These have meaningful last parts like: comment, profile, login, search, etc.
            if url not in seen:
                filtered.append(url_data)
                seen.add(url)
        
        logger.info(f"ðŸŽ¯ Filtered {len(urls)} URLs down to {len(filtered)} complete endpoints")
        
        # Show sample of filtered URLs for debugging
        if filtered:
            sample_urls = [u.get("url", u) if isinstance(u, dict) else u for u in filtered[:5]]
            logger.debug(f"Sample filtered URLs: {sample_urls}")
        
        return filtered
    
    def get_agent_info(self, agent_name: str) -> Optional[Dict[str, Any]]:
        """Get information about a specific agent"""
        if agent_name in self.all_agents:
            agent = self.all_agents[agent_name]
            if hasattr(agent, 'get_info'):
                return agent.get_info()
            elif hasattr(agent, 'get_scan_info'):
                return agent.get_scan_info()
            elif hasattr(agent, 'get_description'):
                return {"description": agent.get_description()}
        return None