"""
Secret Scanning Agent - Comprehensive Secret Detection
Discovers exposed credentials, API keys, and sensitive information
"""

import asyncio
import json
import os
import re
import subprocess
import tempfile
from typing import Dict, List, Any, Set, Optional, Tuple
from dataclasses import dataclass, asdict
from pathlib import Path
from urllib.parse import urlparse, urljoin

from loguru import logger
from agents.base import BaseAgent


@dataclass
class Secret:
    """Represents a discovered secret"""
    type: str
    value: str
    description: str
    severity: str
    confidence: int
    source: str
    location: str
    context: str
    remediation: str


@dataclass
class SecretRule:
    """Secret detection rule"""
    name: str
    pattern: str
    description: str
    severity: str
    confidence: int
    keywords: List[str]


class SecretAgent(BaseAgent):
    """
    Comprehensive secret scanning using multiple detection methods
    Finds exposed credentials, API keys, tokens, and sensitive data
    """
    
    def __init__(self):
        super().__init__("SecretAgent")
        self.discovered_secrets: List[Secret] = []
        
        # Tool paths
        self.gitleaks_path = self._get_gitleaks_path()
        self.trufflehog_path = self._get_trufflehog_path()
        
        # Configuration
        self.max_file_size = 10 * 1024 * 1024  # 10MB
        self.supported_extensions = {
            '.js', '.json', '.yaml', '.yml', '.env', '.config', '.conf',
            '.xml', '.sql', '.py', '.php', '.rb', '.go', '.java', '.cs',
            '.cpp', '.c', '.h', '.sh', '.bash', '.ps1', '.bat', '.properties',
            '.ini', '.cfg', '.toml', '.txt', '.log', '.md', '.dockerfile'
        }
        
        # Initialize secret detection rules
        self.secret_rules = self._initialize_secret_rules()
        
        # Common secret patterns
        self.secret_patterns = self._initialize_secret_patterns()
        
    def _get_gitleaks_path(self) -> str:
        """Get Gitleaks binary path"""
        possible_paths = [
            "/usr/local/bin/gitleaks",
            "/usr/bin/gitleaks",
            "/opt/homebrew/bin/gitleaks",
            "gitleaks"
        ]
        
        for path in possible_paths:
            try:
                result = subprocess.run([path, "version"], 
                                      capture_output=True, text=True, timeout=5)
                if result.returncode == 0:
                    logger.info(f"âœ… Found Gitleaks at: {path}")
                    return path
            except (subprocess.TimeoutExpired, FileNotFoundError):
                continue
        
        logger.warning("âš ï¸ Gitleaks not found. Will install if needed...")
        return self._install_gitleaks()
    
    def _install_gitleaks(self) -> str:
        """Install Gitleaks"""
        try:
            # Install via Go
            install_cmd = "go install github.com/gitleaks/gitleaks/v8@latest"
            result = subprocess.run(install_cmd, shell=True, capture_output=True, text=True, timeout=120)
            
            if result.returncode == 0:
                go_bin = subprocess.run(["go", "env", "GOPATH"], capture_output=True, text=True).stdout.strip()
                gitleaks_path = f"{go_bin}/bin/gitleaks"
                logger.info(f"âœ… Gitleaks installed at: {gitleaks_path}")
                return gitleaks_path
            else:
                return "builtin"
        except Exception as e:
            logger.warning(f"Gitleaks installation failed: {e}")
            return "builtin"
    
    def _get_trufflehog_path(self) -> str:
        """Get TruffleHog binary path (optional)"""
        possible_paths = [
            "/usr/local/bin/trufflehog",
            "/usr/bin/trufflehog",
            "trufflehog"
        ]
        
        for path in possible_paths:
            try:
                result = subprocess.run([path, "--version"], 
                                      capture_output=True, text=True, timeout=5)
                if result.returncode == 0:
                    logger.info(f"âœ… Found TruffleHog at: {path}")
                    return path
            except (subprocess.TimeoutExpired, FileNotFoundError):
                continue
        
        return ""  # Optional tool
    
    def _initialize_secret_rules(self) -> List[SecretRule]:
        """Initialize secret detection rules"""
        return [
            SecretRule(
                name="AWS Access Key",
                pattern=r"(?i)aws[_-]?access[_-]?key[_-]?id['\"\s]*[:=]['\"\s]*([A-Z0-9]{20})",
                description="AWS Access Key ID",
                severity="critical",
                confidence=90,
                keywords=["aws", "access", "key"]
            ),
            SecretRule(
                name="AWS Secret Key",
                pattern=r"(?i)aws[_-]?secret[_-]?access[_-]?key['\"\s]*[:=]['\"\s]*([A-Za-z0-9/+=]{40})",
                description="AWS Secret Access Key",
                severity="critical", 
                confidence=90,
                keywords=["aws", "secret", "key"]
            ),
            SecretRule(
                name="GitHub Token",
                pattern=r"(?i)github[_-]?token['\"\s]*[:=]['\"\s]*([a-f0-9]{40})",
                description="GitHub Personal Access Token",
                severity="high",
                confidence=85,
                keywords=["github", "token"]
            ),
            SecretRule(
                name="API Key Generic",
                pattern=r"(?i)api[_-]?key['\"\s]*[:=]['\"\s]*['\"]([A-Za-z0-9_\-]{16,})['\"]\s",
                description="Generic API Key",
                severity="medium",
                confidence=70,
                keywords=["api", "key"]
            ),
            SecretRule(
                name="Database Password",
                pattern=r"(?i)(password|passwd|pwd)['\"\s]*[:=]['\"\s]*['\"]([^'\"]{8,})['\"]\s",
                description="Database Password",
                severity="high",
                confidence=75,
                keywords=["password", "database"]
            ),
            SecretRule(
                name="JWT Token",
                pattern=r"eyJ[A-Za-z0-9_-]+\.eyJ[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+",
                description="JSON Web Token",
                severity="medium",
                confidence=80,
                keywords=["jwt", "token"]
            ),
            SecretRule(
                name="SSH Private Key",
                pattern=r"-----BEGIN [A-Z]+ PRIVATE KEY-----",
                description="SSH Private Key",
                severity="critical",
                confidence=95,
                keywords=["ssh", "private", "key"]
            ),
            SecretRule(
                name="Slack Token",
                pattern=r"xox[baprs]-([0-9a-zA-Z]{10,48})",
                description="Slack Bot/App/User Token",
                severity="medium",
                confidence=85,
                keywords=["slack", "token"]
            ),
            SecretRule(
                name="Google API Key",
                pattern=r"AIza[0-9A-Za-z_\-]{35}",
                description="Google API Key",
                severity="high",
                confidence=90,
                keywords=["google", "api"]
            ),
            SecretRule(
                name="Docker Registry Auth",
                pattern=r"(?i)docker[_-]?registry[_-]?auth['\"\s]*[:=]['\"\s]*([A-Za-z0-9+/=]{20,})",
                description="Docker Registry Authentication",
                severity="medium",
                confidence=80,
                keywords=["docker", "registry", "auth"]
            )
        ]
    
    def _initialize_secret_patterns(self) -> Dict[str, List[str]]:
        """Initialize common secret patterns and keywords"""
        return {
            "api_keys": [
                r"['\"]?[A-Za-z0-9_-]*api[_-]?key['\"]?\s*[:=]\s*['\"]([A-Za-z0-9_\-]{16,})['\"]",
                r"['\"]?[A-Za-z0-9_-]*token['\"]?\s*[:=]\s*['\"]([A-Za-z0-9_\-]{16,})['\"]",
                r"['\"]?[A-Za-z0-9_-]*secret['\"]?\s*[:=]\s*['\"]([A-Za-z0-9_\-]{16,})['\"]"
            ],
            "database": [
                r"(?i)(mongodb|mysql|postgres)://([^:]+):([^@]+)@",
                r"(?i)database[_-]?url['\"\s]*[:=]['\"\s]*['\"]([^'\"]+)['\"]",
                r"(?i)db[_-]?password['\"\s]*[:=]['\"\s]*['\"]([^'\"]+)['\"]"
            ],
            "cloud_credentials": [
                r"(?i)azure[_-]?client[_-]?secret['\"\s]*[:=]['\"\s]*['\"]([^'\"]+)['\"]",
                r"(?i)gcp[_-]?service[_-]?account['\"\s]*[:=]['\"\s]*['\"]([^'\"]+)['\"]",
                r"(?i)digitalocean[_-]?token['\"\s]*[:=]['\"\s]*['\"]([^'\"]+)['\"]"
            ],
            "encryption": [
                r"-----BEGIN [A-Z ]+-----",
                r"(?i)private[_-]?key['\"\s]*[:=]['\"\s]*['\"]([^'\"]+)['\"]",
                r"(?i)encryption[_-]?key['\"\s]*[:=]['\"\s]*['\"]([^'\"]+)['\"]"
            ]
        }
    
    async def execute(self, scan_data: Dict[str, Any], **kwargs) -> Dict[str, Any]:
        """Execute comprehensive secret scanning"""
        logger.info("ðŸ” Starting comprehensive secret scanning")
        
        results = {
            "secrets": [],
            "secret_types": {},
            "sources_scanned": [],
            "scan_statistics": {},
            "high_severity_count": 0,
            "recommendations": [],
            "metadata": {}
        }
        
        try:
            # Phase 1: Web-based Secret Scanning
            await self.update_progress("web_secrets", {
                "status": "Scanning web endpoints for exposed secrets",
                "phase": "1/4"
            })
            
            web_secrets = await self._scan_web_secrets(scan_data)
            results["secrets"].extend(web_secrets)
            results["sources_scanned"].append("web_endpoints")
            
            # Phase 2: JavaScript File Analysis
            if not self.is_cancelled():
                await self.update_progress("js_analysis", {
                    "status": "Analyzing JavaScript files for hardcoded secrets",
                    "phase": "2/4"
                })
                
                js_secrets = await self._scan_javascript_secrets(scan_data)
                results["secrets"].extend(js_secrets)
                results["sources_scanned"].append("javascript_files")
            
            # Phase 3: Configuration File Scanning
            if not self.is_cancelled():
                await self.update_progress("config_scan", {
                    "status": "Scanning configuration files",
                    "phase": "3/4"
                })
                
                config_secrets = await self._scan_configuration_files(scan_data)
                results["secrets"].extend(config_secrets)
                results["sources_scanned"].append("configuration_files")
            
            # Phase 4: Repository Analysis (if GitHub data available)
            if not self.is_cancelled():
                await self.update_progress("repo_analysis", {
                    "status": "Analyzing repositories for secret exposure",
                    "phase": "4/4"
                })
                
                repo_secrets = await self._scan_repository_secrets(scan_data)
                results["secrets"].extend(repo_secrets)
                results["sources_scanned"].append("repositories")
            
            # Process and analyze results
            results = self._process_secret_results(results)
            
            logger.info(f"âœ… Secret scanning completed: {len(results['secrets'])} secrets found")
            return results
            
        except Exception as e:
            logger.error(f"âŒ Secret scanning failed: {e}")
            raise
    
    async def _scan_web_secrets(self, scan_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Scan web endpoints for exposed secrets"""
        secrets = []
        
        # Get web endpoints from previous scans
        web_responses = scan_data.get("web_responses", [])
        active_hosts = scan_data.get("active_hosts", [])
        
        # Common endpoints that might expose secrets
        secret_endpoints = [
            "/.env", "/.env.local", "/.env.production",
            "/config.json", "/config.yaml", "/config.yml",
            "/app.config", "/web.config", "/database.yml",
            "/.git/config", "/.gitignore", "/docker-compose.yml",
            "/package.json", "/composer.json", "/requirements.txt",
            "/Dockerfile", "/.dockerignore", "/kubernetes.yml",
            "/secrets.json", "/credentials.json", "/auth.json",
            "/backup", "/dump", "/.backup", "/db_backup"
        ]
        
        import httpx
        
        async with httpx.AsyncClient(timeout=10.0, verify=False) as client:
            for host in active_hosts[:20]:  # Limit for performance
                if self.is_cancelled():
                    break
                
                for endpoint in secret_endpoints:
                    try:
                        full_url = urljoin(host, endpoint)
                        response = await client.get(full_url)
                        
                        # Check if response contains potential secrets
                        if response.status_code == 200 and response.text:
                            detected_secrets = await self._analyze_content_for_secrets(
                                response.text, f"web:{full_url}"
                            )
                            secrets.extend(detected_secrets)
                        
                    except Exception:
                        continue
                
                # Rate limiting
                await asyncio.sleep(0.2)
        
        return secrets
    
    async def _scan_javascript_secrets(self, scan_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Analyze JavaScript files for hardcoded secrets"""
        secrets = []
        
        # Get active hosts
        active_hosts = scan_data.get("active_hosts", [])
        
        # Common JS paths that might contain secrets
        js_paths = [
            "/js/app.js", "/js/main.js", "/js/config.js",
            "/assets/js/app.js", "/static/js/main.js",
            "/build/js/app.js", "/dist/js/bundle.js",
            "/js/bundle.js", "/webpack/main.js"
        ]
        
        import httpx
        
        async with httpx.AsyncClient(timeout=15.0, verify=False) as client:
            for host in active_hosts[:10]:  # Limit for performance
                if self.is_cancelled():
                    break
                
                for js_path in js_paths:
                    try:
                        js_url = urljoin(host, js_path)
                        response = await client.get(js_url)
                        
                        if response.status_code == 200 and 'javascript' in response.headers.get('content-type', ''):
                            # Analyze JavaScript content for secrets
                            js_secrets = await self._analyze_javascript_content(
                                response.text, f"javascript:{js_url}"
                            )
                            secrets.extend(js_secrets)
                        
                    except Exception:
                        continue
        
        return secrets
    
    async def _analyze_javascript_content(self, js_content: str, source: str) -> List[Dict[str, Any]]:
        """Analyze JavaScript content for hardcoded secrets"""
        secrets = []
        
        # JavaScript-specific secret patterns
        js_patterns = [
            r'(?i)api[_-]?key[\'\"]\s*[:=]\s*[\'\"]([\w\-]{16,})[\'\"]\s*[,;}]',
            r'(?i)token[\'\"]\s*[:=]\s*[\'\"]([\w\-]{20,})[\'\"]\s*[,;}]',
            r'(?i)secret[\'\"]\s*[:=]\s*[\'\"]([\w\-]{16,})[\'\"]\s*[,;}]',
            r'(?i)password[\'\"]\s*[:=]\s*[\'\"]([\w\-]{8,})[\'\"]\s*[,;}]',
            r'(?i)key[\'\"]\s*[:=]\s*[\'\"]([\w\-]{16,})[\'\"]\s*[,;}]'
        ]
        
        # Analyze content with patterns
        for pattern in js_patterns:
            matches = re.finditer(pattern, js_content)
            for match in matches:
                secret_value = match.group(1)
                
                # Skip common false positives
                if self._is_likely_secret(secret_value):
                    secrets.append({
                        "type": "javascript_secret",
                        "value": secret_value,
                        "description": "Hardcoded secret in JavaScript file",
                        "severity": "medium",
                        "confidence": 70,
                        "source": source,
                        "location": f"Line content: {match.group(0)[:100]}",
                        "context": js_content[max(0, match.start()-50):match.end()+50],
                        "remediation": "Move secret to environment variables or secure configuration"
                    })
        
        # Also run general secret detection
        general_secrets = await self._analyze_content_for_secrets(js_content, source)
        secrets.extend(general_secrets)
        
        return secrets
    
    async def _scan_configuration_files(self, scan_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Scan common configuration file locations"""
        secrets = []
        
        active_hosts = scan_data.get("active_hosts", [])
        
        # Configuration file patterns
        config_files = [
            "/.env", "/.env.local", "/.env.production", "/.env.development",
            "/config.json", "/config.yaml", "/config.yml", "/config.xml",
            "/app.config", "/web.config", "/appsettings.json",
            "/database.yml", "/database.json", "/db.json",
            "/secrets.yaml", "/credentials.json", "/auth.json",
            "/docker-compose.yml", "/docker-compose.yaml",
            "/kubernetes.yml", "/k8s-config.yml"
        ]
        
        import httpx
        
        async with httpx.AsyncClient(timeout=10.0, verify=False) as client:
            for host in active_hosts[:10]:
                if self.is_cancelled():
                    break
                
                for config_file in config_files:
                    try:
                        config_url = urljoin(host, config_file)
                        response = await client.get(config_url)
                        
                        if response.status_code == 200:
                            # Analyze configuration content
                            config_secrets = await self._analyze_config_content(
                                response.text, f"config:{config_url}"
                            )
                            secrets.extend(config_secrets)
                        
                    except Exception:
                        continue
        
        return secrets
    
    async def _analyze_config_content(self, content: str, source: str) -> List[Dict[str, Any]]:
        """Analyze configuration file content for secrets"""
        secrets = []
        
        # Configuration-specific patterns
        config_patterns = [
            r'(?i)(password|passwd|pwd)\s*[:=]\s*[\'\"]([\w\-@$!%*?&]{8,})[\'\"]\s',
            r'(?i)(api[_-]?key|apikey)\s*[:=]\s*[\'\"]([\w\-]{16,})[\'\"]\s',
            r'(?i)(secret|token)\s*[:=]\s*[\'\"]([\w\-]{16,})[\'\"]\s',
            r'(?i)(database[_-]?url|db[_-]?url)\s*[:=]\s*[\'\"]([\w\-:/\.@$!%*?&]{10,})[\'\"]\s',
            r'(?i)(connection[_-]?string)\s*[:=]\s*[\'\"]([\w\-:/\.@$!%*?&]{10,})[\'\"]\s'
        ]
        
        for pattern in config_patterns:
            matches = re.finditer(pattern, content)
            for match in matches:
                secret_type = match.group(1).lower()
                secret_value = match.group(2)
                
                if self._is_likely_secret(secret_value):
                    severity = "critical" if "password" in secret_type else "high"
                    
                    secrets.append({
                        "type": f"config_{secret_type}",
                        "value": secret_value,
                        "description": f"Exposed {secret_type} in configuration file",
                        "severity": severity,
                        "confidence": 85,
                        "source": source,
                        "location": f"Config entry: {match.group(0)}",
                        "context": content[max(0, match.start()-50):match.end()+50],
                        "remediation": "Use environment variables or encrypted configuration"
                    })
        
        return secrets
    
    async def _scan_repository_secrets(self, scan_data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Scan repositories for secret exposure using Gitleaks"""
        secrets = []
        
        # This would integrate with GitHub API data if available
        # For now, simulate repository secret detection
        github_data = scan_data.get("github_repositories", [])
        
        if self.gitleaks_path != "builtin" and github_data:
            # Use Gitleaks for repository scanning
            secrets = await self._run_gitleaks_scan(github_data)
        else:
            # Placeholder for built-in repository scanning
            secrets = await self._builtin_repo_scan(github_data)
        
        return secrets
    
    async def _run_gitleaks_scan(self, repositories: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Run Gitleaks on repositories"""
        secrets = []
        
        # This would clone and scan repositories
        # Implement based on actual repository data structure
        
        return secrets
    
    async def _builtin_repo_scan(self, repositories: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Built-in repository secret scanning"""
        # Placeholder for built-in scanning
        return []
    
    async def _analyze_content_for_secrets(self, content: str, source: str) -> List[Dict[str, Any]]:
        """Analyze content using secret detection rules"""
        secrets = []
        
        for rule in self.secret_rules:
            try:
                matches = re.finditer(rule.pattern, content, re.IGNORECASE | re.MULTILINE)
                for match in matches:
                    secret_value = match.group(1) if match.groups() else match.group(0)
                    
                    # Validate that this is likely a real secret
                    if self._is_likely_secret(secret_value):
                        secrets.append({
                            "type": rule.name.lower().replace(" ", "_"),
                            "value": secret_value,
                            "description": rule.description,
                            "severity": rule.severity,
                            "confidence": rule.confidence,
                            "source": source,
                            "location": f"Match: {match.group(0)[:100]}",
                            "context": content[max(0, match.start()-50):match.end()+50],
                            "remediation": self._get_remediation_for_secret_type(rule.name)
                        })
            except Exception as e:
                logger.warning(f"Error applying rule {rule.name}: {e}")
        
        return secrets
    
    def _is_likely_secret(self, value: str) -> bool:
        """Determine if a value is likely to be a real secret"""
        if not value or len(value) < 8:
            return False
        
        # Skip common false positives
        false_positives = {
            "example", "test", "demo", "placeholder", "your_key_here",
            "insert_key_here", "your_secret", "change_me", "password",
            "123456789", "abcdefgh", "null", "undefined", "false", "true"
        }
        
        if value.lower() in false_positives:
            return False
        
        # Check for sufficient entropy (randomness)
        if len(set(value)) < len(value) * 0.4:  # Too repetitive
            return False
        
        # Check for realistic length and character patterns
        if len(value) < 12 and not re.search(r'[A-Z]', value):
            return False
        
        return True
    
    def _get_remediation_for_secret_type(self, secret_type: str) -> str:
        """Get specific remediation advice for secret type"""
        remediation_map = {
            "AWS Access Key": "Rotate AWS credentials immediately and use AWS IAM roles",
            "GitHub Token": "Revoke token in GitHub settings and create new one with minimal permissions",
            "API Key Generic": "Rotate API key and use environment variables for storage",
            "Database Password": "Change database password and use connection encryption",
            "SSH Private Key": "Generate new SSH key pair and update authorized_keys",
            "JWT Token": "Invalidate token and implement proper token rotation",
        }
        
        return remediation_map.get(secret_type, "Remove secret from code and use secure configuration management")
    
    def _process_secret_results(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Process and enhance secret scanning results"""
        secrets = results["secrets"]
        
        # Count secret types
        secret_types = {}
        high_severity_count = 0
        
        for secret in secrets:
            secret_type = secret.get("type", "unknown")
            severity = secret.get("severity", "low")
            
            # Count by type
            if secret_type not in secret_types:
                secret_types[secret_type] = 0
            secret_types[secret_type] += 1
            
            # Count high severity
            if severity in ["critical", "high"]:
                high_severity_count += 1
        
        results["secret_types"] = secret_types
        results["high_severity_count"] = high_severity_count
        
        # Generate recommendations
        recommendations = []
        
        if high_severity_count > 0:
            recommendations.append(f"ðŸš¨ CRITICAL: {high_severity_count} high-severity secrets found - immediate action required")
        
        if "aws_access_key" in secret_types or "aws_secret_key" in secret_types:
            recommendations.append("ðŸ” AWS credentials exposed - rotate immediately and check CloudTrail logs")
        
        if any("password" in secret_type for secret_type in secret_types):
            recommendations.append("ðŸ’¡ Implement proper password management and avoid hardcoded credentials")
        
        if len(secrets) > 10:
            recommendations.append("ðŸ“‹ Multiple secrets found - consider implementing automated secret scanning in CI/CD")
        
        results["recommendations"] = recommendations
        
        # Scan statistics
        results["scan_statistics"] = {
            "total_secrets": len(secrets),
            "unique_types": len(secret_types),
            "critical_secrets": len([s for s in secrets if s.get("severity") == "critical"]),
            "high_secrets": len([s for s in secrets if s.get("severity") == "high"]),
            "medium_secrets": len([s for s in secrets if s.get("severity") == "medium"]),
            "sources_scanned": len(results["sources_scanned"]),
            "average_confidence": sum(s.get("confidence", 0) for s in secrets) / max(len(secrets), 1)
        }
        
        # Sort secrets by severity and confidence
        severity_order = {"critical": 0, "high": 1, "medium": 2, "low": 3}
        results["secrets"] = sorted(
            secrets,
            key=lambda x: (severity_order.get(x.get("severity", "low"), 3), -x.get("confidence", 0))
        )
        
        return results
