"""
SSL/TLS Security Agent for Nexus Hunter
Comprehensive SSL/TLS configuration and vulnerability assessment
"""

import asyncio
import json
import ssl
import socket
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from urllib.parse import urlparse
import subprocess

from agents.base import BaseAgent


@dataclass
class SSLVulnerability:
    """SSL/TLS vulnerability finding"""
    name: str
    description: str
    severity: str
    category: str
    evidence: str
    recommendation: str


class SSLTLSAgent(BaseAgent):
    """Comprehensive SSL/TLS security assessment agent"""
    
    def __init__(self):
        super().__init__("SSLTLSAgent")
        self.weak_ciphers = [
            "RC4", "DES", "3DES", "MD5", "SHA1", "NULL",
            "EXPORT", "ADH", "AECDH", "aNULL", "eNULL"
        ]
        self.weak_protocols = ["SSLv2", "SSLv3", "TLSv1.0", "TLSv1.1"]
        self.secure_protocols = ["TLSv1.2", "TLSv1.3"]
        
    async def execute(self, target: str, config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Main execution method required by BaseAgent"""
        return await self.scan(target, **(config or {}))
        
    async def scan(self, target: str, **kwargs) -> Dict[str, Any]:
        """
        Perform comprehensive SSL/TLS security assessment
        
        Args:
            target: Target domain or URL to assess
            **kwargs: Additional scan options
        """
        try:
            # Parse target to get domain and port
            domain, port = self._parse_target(target)
            
            results = {
                "target": target,
                "domain": domain,
                "port": port,
                "vulnerabilities": [],
                "certificate_info": {},
                "protocol_support": {},
                "cipher_analysis": {},
                "security_headers": {},
                "statistics": {}
            }
            
            self.logger.info(f"Starting SSL/TLS scan for {domain}:{port}")
            
            # Test SSL/TLS connectivity
            if not await self._test_ssl_connectivity(domain, port):
                return {
                    "error": "No SSL/TLS service detected",
                    "target": target,
                    "domain": domain,
                    "port": port
                }
            
            # Comprehensive SSL/TLS assessment
            certificate_info = await self._analyze_certificate(domain, port)
            results["certificate_info"] = certificate_info
            
            protocol_support = await self._test_protocol_support(domain, port)
            results["protocol_support"] = protocol_support
            
            cipher_analysis = await self._analyze_ciphers(domain, port)
            results["cipher_analysis"] = cipher_analysis
            
            security_headers = await self._check_security_headers(target)
            results["security_headers"] = security_headers
            
            # Identify vulnerabilities
            vulnerabilities = await self._identify_ssl_vulnerabilities(
                certificate_info, protocol_support, cipher_analysis, security_headers
            )
            results["vulnerabilities"] = vulnerabilities
            
            # Use external tools if available
            external_results = await self._run_external_ssl_tools(domain, port)
            results["external_tool_results"] = external_results
            
            # Analyze and categorize findings
            results = await self._analyze_ssl_results(results)
            
            self.logger.info(f"SSL/TLS scan completed for {domain}:{port}")
            return results
            
        except Exception as e:
            self.logger.error(f"SSL/TLS scan failed: {e}")
            return {"error": str(e), "target": target}
    
    def _parse_target(self, target: str) -> Tuple[str, int]:
        """Parse target to extract domain and port"""
        if target.startswith(('http://', 'https://')):
            parsed = urlparse(target)
            domain = parsed.hostname
            port = parsed.port or (443 if parsed.scheme == 'https' else 80)
        else:
            if ':' in target:
                domain, port_str = target.rsplit(':', 1)
                port = int(port_str)
            else:
                domain = target
                port = 443
        
        return domain, port
    
    async def _test_ssl_connectivity(self, domain: str, port: int) -> bool:
        """Test if SSL/TLS service is available"""
        try:
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(domain, port, ssl=context),
                timeout=10
            )
            writer.close()
            await writer.wait_closed()
            return True
        
        except Exception:
            return False
    
    async def _analyze_certificate(self, domain: str, port: int) -> Dict[str, Any]:
        """Analyze SSL certificate"""
        try:
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(10)
            
            ssl_sock = context.wrap_socket(sock, server_hostname=domain)
            ssl_sock.connect((domain, port))
            
            cert = ssl_sock.getpeercert()
            ssl_sock.close()
            
            if not cert:
                return {"error": "No certificate found"}
            
            return {
                "subject": dict(x[0] for x in cert.get('subject', [])),
                "issuer": dict(x[0] for x in cert.get('issuer', [])),
                "version": cert.get('version', 'Unknown'),
                "serial_number": cert.get('serialNumber', 'Unknown'),
                "not_before": cert.get('notBefore', 'Unknown'),
                "not_after": cert.get('notAfter', 'Unknown'),
                "subject_alt_names": [x[1] for x in cert.get('subjectAltName', [])],
                "signature_algorithm": cert.get('signatureAlgorithm', 'Unknown'),
                "public_key_info": self._analyze_public_key(cert),
                "extensions": self._analyze_certificate_extensions(cert)
            }
        
        except Exception as e:
            self.logger.error(f"Certificate analysis failed: {e}")
            return {"error": str(e)}
    
    def _analyze_public_key(self, cert: Dict) -> Dict[str, Any]:
        """Analyze certificate public key"""
        try:
            # This would require more advanced certificate parsing
            # For now, return basic info
            return {
                "algorithm": "RSA",  # Default assumption
                "key_size": "Unknown",
                "analysis": "Basic analysis - key size detection requires cryptography library"
            }
        except Exception:
            return {"error": "Public key analysis failed"}
    
    def _analyze_certificate_extensions(self, cert: Dict) -> List[str]:
        """Analyze certificate extensions"""
        try:
            extensions = []
            
            # Common extension analysis
            if cert.get('subjectAltName'):
                extensions.append("Subject Alternative Name")
            
            # This would require more detailed certificate parsing
            extensions.append("Basic extension analysis - detailed analysis requires cryptography library")
            
            return extensions
        except Exception:
            return ["Extension analysis failed"]
    
    async def _test_protocol_support(self, domain: str, port: int) -> Dict[str, Any]:
        """Test supported SSL/TLS protocols"""
        protocol_support = {}
        
        # Protocol version mapping for Python ssl module
        protocols_to_test = [
            ("TLSv1.3", ssl.PROTOCOL_TLS_CLIENT),
            ("TLSv1.2", ssl.PROTOCOL_TLS_CLIENT),
            ("TLSv1.1", ssl.PROTOCOL_TLS_CLIENT),
            ("TLSv1.0", ssl.PROTOCOL_TLS_CLIENT)
        ]
        
        for protocol_name, protocol_version in protocols_to_test:
            try:
                context = ssl.SSLContext(protocol_version)
                context.check_hostname = False
                context.verify_mode = ssl.CERT_NONE
                
                # Configure protocol version if possible
                if hasattr(context, 'minimum_version'):
                    if protocol_name == "TLSv1.3":
                        context.minimum_version = ssl.TLSVersion.TLSv1_3
                        context.maximum_version = ssl.TLSVersion.TLSv1_3
                    elif protocol_name == "TLSv1.2":
                        context.minimum_version = ssl.TLSVersion.TLSv1_2
                        context.maximum_version = ssl.TLSVersion.TLSv1_2
                    elif protocol_name == "TLSv1.1":
                        context.minimum_version = ssl.TLSVersion.TLSv1_1
                        context.maximum_version = ssl.TLSVersion.TLSv1_1
                    elif protocol_name == "TLSv1.0":
                        context.minimum_version = ssl.TLSVersion.TLSv1
                        context.maximum_version = ssl.TLSVersion.TLSv1
                
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(10)
                
                ssl_sock = context.wrap_socket(sock, server_hostname=domain)
                ssl_sock.connect((domain, port))
                
                protocol_support[protocol_name] = {
                    "supported": True,
                    "version": ssl_sock.version() or protocol_name
                }
                ssl_sock.close()
                
            except Exception as e:
                protocol_support[protocol_name] = {
                    "supported": False,
                    "error": str(e)
                }
        
        return protocol_support
    
    async def _analyze_ciphers(self, domain: str, port: int) -> Dict[str, Any]:
        """Analyze supported cipher suites"""
        try:
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(10)
            
            ssl_sock = context.wrap_socket(sock, server_hostname=domain)
            ssl_sock.connect((domain, port))
            
            cipher_info = ssl_sock.cipher()
            ssl_sock.close()
            
            if cipher_info:
                cipher_name, version, bits = cipher_info
                
                return {
                    "negotiated_cipher": cipher_name,
                    "protocol_version": version,
                    "key_bits": bits,
                    "cipher_analysis": self._analyze_cipher_security(cipher_name),
                    "weak_cipher_detected": any(weak in cipher_name for weak in self.weak_ciphers)
                }
            
            return {"error": "No cipher information available"}
            
        except Exception as e:
            self.logger.error(f"Cipher analysis failed: {e}")
            return {"error": str(e)}
    
    def _analyze_cipher_security(self, cipher_name: str) -> Dict[str, Any]:
        """Analyze cipher security characteristics"""
        analysis = {
            "security_level": "unknown",
            "key_exchange": "unknown",
            "authentication": "unknown",
            "encryption": "unknown",
            "mac": "unknown",
            "issues": []
        }
        
        cipher_lower = cipher_name.lower()
        
        # Check for weak components
        if any(weak in cipher_lower for weak in ["rc4", "des", "md5", "sha1"]):
            analysis["security_level"] = "weak"
            analysis["issues"].append("Uses weak cryptographic algorithms")
        elif any(strong in cipher_lower for strong in ["aes", "chacha20", "gcm", "sha256", "sha384"]):
            analysis["security_level"] = "strong"
        else:
            analysis["security_level"] = "moderate"
        
        # Analyze key exchange
        if "ecdhe" in cipher_lower:
            analysis["key_exchange"] = "ECDHE (Perfect Forward Secrecy)"
        elif "dhe" in cipher_lower:
            analysis["key_exchange"] = "DHE (Perfect Forward Secrecy)"
        elif "ecdh" in cipher_lower:
            analysis["key_exchange"] = "ECDH (Static)"
        elif "rsa" in cipher_lower:
            analysis["key_exchange"] = "RSA (Static)"
            analysis["issues"].append("No Perfect Forward Secrecy")
        
        # Check authentication
        if "ecdsa" in cipher_lower:
            analysis["authentication"] = "ECDSA"
        elif "rsa" in cipher_lower:
            analysis["authentication"] = "RSA"
        
        return analysis
    
    async def _check_security_headers(self, target: str) -> Dict[str, Any]:
        """Check SSL/TLS related security headers"""
        try:
            import httpx
            
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                response = await client.get(target)
                headers = response.headers
                
                security_headers = {
                    "strict_transport_security": headers.get("Strict-Transport-Security"),
                    "public_key_pins": headers.get("Public-Key-Pins"),
                    "expect_ct": headers.get("Expect-CT"),
                    "content_security_policy": headers.get("Content-Security-Policy"),
                    "x_frame_options": headers.get("X-Frame-Options"),
                    "x_content_type_options": headers.get("X-Content-Type-Options")
                }
                
                return {
                    "headers_found": security_headers,
                    "hsts_configured": "strict-transport-security" in headers,
                    "hpkp_configured": "public-key-pins" in headers,
                    "expect_ct_configured": "expect-ct" in headers,
                    "security_score": self._calculate_header_security_score(security_headers)
                }
                
        except Exception as e:
            self.logger.error(f"Security headers check failed: {e}")
            return {"error": str(e)}
    
    def _calculate_header_security_score(self, headers: Dict[str, Any]) -> int:
        """Calculate security score based on headers"""
        score = 0
        
        if headers.get("strict_transport_security"):
            score += 30
        if headers.get("public_key_pins"):
            score += 20
        if headers.get("expect_ct"):
            score += 15
        if headers.get("content_security_policy"):
            score += 20
        if headers.get("x_frame_options"):
            score += 10
        if headers.get("x_content_type_options"):
            score += 5
        
        return score
    
    async def _run_external_ssl_tools(self, domain: str, port: int) -> Dict[str, Any]:
        """Run external SSL testing tools if available"""
        results = {}
        
        # Try to run testssl.sh if available
        try:
            process = await asyncio.create_subprocess_exec(
                "testssl.sh", "--quiet", "--jsonfile", "/tmp/testssl_output.json", 
                f"{domain}:{port}",
                stdout=asyncio.subprocess.DEVNULL,
                stderr=asyncio.subprocess.DEVNULL
            )
            
            await asyncio.wait_for(process.wait(), timeout=120)
            
            if process.returncode == 0:
                try:
                    with open("/tmp/testssl_output.json", "r") as f:
                        results["testssl"] = json.load(f)
                except:
                    results["testssl"] = {"status": "completed", "details": "output parsing failed"}
            else:
                results["testssl"] = {"status": "failed", "return_code": process.returncode}
        
        except FileNotFoundError:
            results["testssl"] = {"status": "not_available", "note": "testssl.sh not installed"}
        except asyncio.TimeoutError:
            results["testssl"] = {"status": "timeout", "note": "testssl.sh timed out"}
        except Exception as e:
            results["testssl"] = {"status": "error", "error": str(e)}
        
        # Try SSLyze if available
        try:
            process = await asyncio.create_subprocess_exec(
                "sslyze", "--json_out=/tmp/sslyze_output.json", 
                f"{domain}:{port}",
                stdout=asyncio.subprocess.DEVNULL,
                stderr=asyncio.subprocess.DEVNULL
            )
            
            await asyncio.wait_for(process.wait(), timeout=60)
            
            if process.returncode == 0:
                try:
                    with open("/tmp/sslyze_output.json", "r") as f:
                        results["sslyze"] = json.load(f)
                except:
                    results["sslyze"] = {"status": "completed", "details": "output parsing failed"}
            else:
                results["sslyze"] = {"status": "failed", "return_code": process.returncode}
        
        except FileNotFoundError:
            results["sslyze"] = {"status": "not_available", "note": "SSLyze not installed"}
        except asyncio.TimeoutError:
            results["sslyze"] = {"status": "timeout", "note": "SSLyze timed out"}
        except Exception as e:
            results["sslyze"] = {"status": "error", "error": str(e)}
        
        return results
    
    async def _identify_ssl_vulnerabilities(self, cert_info: Dict, protocol_support: Dict, 
                                         cipher_analysis: Dict, headers: Dict) -> List[Dict[str, Any]]:
        """Identify SSL/TLS vulnerabilities from analysis results"""
        vulnerabilities = []
        
        # Certificate vulnerabilities
        if cert_info and not cert_info.get("error"):
            # Check certificate expiry
            if cert_info.get("not_after"):
                # This would require date parsing - simplified check
                vulnerabilities.append({
                    "name": "Certificate Expiry Check",
                    "description": "Certificate expiry date should be monitored",
                    "severity": "info",
                    "category": "Certificate",
                    "evidence": f"Certificate expires: {cert_info['not_after']}",
                    "recommendation": "Monitor certificate expiry and renew before expiration"
                })
            
            # Check for self-signed or weak signatures
            if cert_info.get("issuer", {}).get("organizationName") == cert_info.get("subject", {}).get("organizationName"):
                vulnerabilities.append({
                    "name": "Self-Signed Certificate",
                    "description": "Certificate appears to be self-signed",
                    "severity": "medium",
                    "category": "Certificate",
                    "evidence": "Issuer and subject organization are identical",
                    "recommendation": "Use certificates from trusted Certificate Authorities"
                })
        
        # Protocol vulnerabilities
        for protocol, info in protocol_support.items():
            if info.get("supported") and protocol in self.weak_protocols:
                severity = "high" if protocol in ["SSLv2", "SSLv3"] else "medium"
                vulnerabilities.append({
                    "name": f"Weak Protocol Support: {protocol}",
                    "description": f"Server supports deprecated protocol {protocol}",
                    "severity": severity,
                    "category": "Protocol",
                    "evidence": f"Protocol {protocol} is supported",
                    "recommendation": f"Disable support for {protocol}"
                })
        
        # Cipher vulnerabilities
        if cipher_analysis and not cipher_analysis.get("error"):
            if cipher_analysis.get("weak_cipher_detected"):
                vulnerabilities.append({
                    "name": "Weak Cipher Suite",
                    "description": "Server negotiated a weak cipher suite",
                    "severity": "medium",
                    "category": "Cipher",
                    "evidence": f"Weak cipher: {cipher_analysis.get('negotiated_cipher')}",
                    "recommendation": "Configure server to prefer strong cipher suites"
                })
            
            cipher_info = cipher_analysis.get("cipher_analysis", {})
            if "No Perfect Forward Secrecy" in cipher_info.get("issues", []):
                vulnerabilities.append({
                    "name": "No Perfect Forward Secrecy",
                    "description": "Server does not support Perfect Forward Secrecy",
                    "severity": "medium",
                    "category": "Cipher",
                    "evidence": "Key exchange method does not provide PFS",
                    "recommendation": "Configure ECDHE or DHE key exchange methods"
                })
        
        # Header vulnerabilities
        if headers and not headers.get("error"):
            if not headers.get("hsts_configured"):
                vulnerabilities.append({
                    "name": "Missing HSTS Header",
                    "description": "Strict-Transport-Security header is not configured",
                    "severity": "medium",
                    "category": "Headers",
                    "evidence": "HSTS header not found in response",
                    "recommendation": "Configure Strict-Transport-Security header"
                })
            
            security_score = headers.get("security_score", 0)
            if security_score < 50:
                vulnerabilities.append({
                    "name": "Insufficient Security Headers",
                    "description": "Server lacks important security headers",
                    "severity": "low",
                    "category": "Headers",
                    "evidence": f"Security header score: {security_score}/100",
                    "recommendation": "Implement additional security headers"
                })
        
        return vulnerabilities
    
    async def _analyze_ssl_results(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze and categorize SSL/TLS scan results"""
        try:
            vulnerabilities = results["vulnerabilities"]
            
            # Categorize by severity
            critical_vulns = [v for v in vulnerabilities if v.get("severity") == "critical"]
            high_vulns = [v for v in vulnerabilities if v.get("severity") == "high"]
            medium_vulns = [v for v in vulnerabilities if v.get("severity") == "medium"]
            low_vulns = [v for v in vulnerabilities if v.get("severity") == "low"]
            info_vulns = [v for v in vulnerabilities if v.get("severity") == "info"]
            
            # Categorize by type
            cert_issues = [v for v in vulnerabilities if v.get("category") == "Certificate"]
            protocol_issues = [v for v in vulnerabilities if v.get("category") == "Protocol"]
            cipher_issues = [v for v in vulnerabilities if v.get("category") == "Cipher"]
            header_issues = [v for v in vulnerabilities if v.get("category") == "Headers"]
            
            results["categorized_vulnerabilities"] = {
                "critical": critical_vulns,
                "high": high_vulns,
                "medium": medium_vulns,
                "low": low_vulns,
                "info": info_vulns
            }
            
            results["issue_categories"] = {
                "certificate": cert_issues,
                "protocol": protocol_issues,
                "cipher": cipher_issues,
                "headers": header_issues
            }
            
            # Calculate overall security score
            security_score = self._calculate_overall_security_score(results)
            
            results["statistics"] = {
                "total_vulnerabilities": len(vulnerabilities),
                "critical_count": len(critical_vulns),
                "high_count": len(high_vulns),
                "medium_count": len(medium_vulns),
                "low_count": len(low_vulns),
                "info_count": len(info_vulns),
                "overall_security_score": security_score,
                "security_grade": self._calculate_security_grade(security_score)
            }
            
            results["recommendations"] = self._generate_ssl_recommendations(results)
            
            return results
        
        except Exception as e:
            self.logger.error(f"SSL results analysis failed: {e}")
            return results
    
    def _calculate_overall_security_score(self, results: Dict[str, Any]) -> int:
        """Calculate overall SSL/TLS security score"""
        score = 100  # Start with perfect score
        
        # Deduct points for vulnerabilities
        for vuln in results["vulnerabilities"]:
            severity = vuln.get("severity", "info")
            if severity == "critical":
                score -= 25
            elif severity == "high":
                score -= 15
            elif severity == "medium":
                score -= 10
            elif severity == "low":
                score -= 5
        
        # Bonus points for strong configuration
        protocol_support = results.get("protocol_support", {})
        if protocol_support.get("TLSv1.3", {}).get("supported"):
            score += 10
        
        headers = results.get("security_headers", {})
        if headers.get("hsts_configured"):
            score += 5
        
        return max(0, min(100, score))
    
    def _calculate_security_grade(self, score: int) -> str:
        """Calculate security grade from score"""
        if score >= 90:
            return "A+"
        elif score >= 80:
            return "A"
        elif score >= 70:
            return "B"
        elif score >= 60:
            return "C"
        elif score >= 50:
            return "D"
        else:
            return "F"
    
    def _generate_ssl_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Generate SSL/TLS specific recommendations"""
        recommendations = []
        
        # Protocol recommendations
        protocol_support = results.get("protocol_support", {})
        if any(protocol in protocol_support and protocol_support[protocol].get("supported") 
               for protocol in self.weak_protocols):
            recommendations.append("Disable weak SSL/TLS protocols (SSLv2, SSLv3, TLSv1.0, TLSv1.1)")
        
        if not protocol_support.get("TLSv1.3", {}).get("supported"):
            recommendations.append("Enable TLS 1.3 support for better security and performance")
        
        # Cipher recommendations
        cipher_analysis = results.get("cipher_analysis", {})
        if cipher_analysis.get("weak_cipher_detected"):
            recommendations.append("Configure server to use only strong cipher suites")
        
        # Header recommendations
        headers = results.get("security_headers", {})
        if not headers.get("hsts_configured"):
            recommendations.append("Implement HSTS (HTTP Strict Transport Security) header")
        
        # General recommendations
        recommendations.extend([
            "Regularly update SSL/TLS certificates before expiration",
            "Use certificates with strong key sizes (RSA 2048+ or ECDSA P-256+)",
            "Implement Certificate Transparency monitoring",
            "Configure Perfect Forward Secrecy (PFS)",
            "Monitor SSL/TLS configuration for security changes"
        ])
        
        return recommendations
    
    def get_vulnerability_types(self) -> List[str]:
        """Get types of SSL/TLS vulnerabilities this agent can detect"""
        return [
            "Certificate Issues",
            "Weak Protocols",
            "Weak Ciphers",
            "Missing Security Headers",
            "Configuration Issues"
        ]
    
    def get_description(self) -> str:
        """Get agent description"""
        return "Comprehensive SSL/TLS security assessment agent for certificate, protocol, cipher, and configuration analysis"

