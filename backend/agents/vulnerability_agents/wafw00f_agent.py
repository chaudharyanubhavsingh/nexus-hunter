"""
Wafw00f Agent - WAF Detection and Identification
Professional Web Application Firewall detection and fingerprinting
"""

import asyncio
import json
import subprocess
from typing import Dict, List, Any, Optional
from loguru import logger

from agents.base import BaseAgent


class Wafw00fAgent(BaseAgent):
    """
    Professional WAF Detection Agent using Wafw00f
    Identifies Web Application Firewalls and security solutions
    """
    
    def __init__(self):
        super().__init__("wafw00f_agent")
        self.tool_command = "wafw00f"
        
    async def detect_waf(
        self,
        target: str,
        options: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Detect Web Application Firewalls for target
        
        Args:
            target: Target URL or domain
            options: Additional scanning options
            
        Returns:
            WAF detection results with identified firewalls
        """
        logger.info(f"ðŸ›¡ï¸ Starting WAF detection for {target}")
        
        try:
            # Prepare wafw00f command
            cmd = [self.tool_command, target]
            
            # Add options if provided
            if options:
                if options.get("verbose"):
                    cmd.append("-v")
                if options.get("findall"):
                    cmd.append("-a")  # Find all WAFs
                if options.get("proxy"):
                    cmd.extend(["--proxy", options["proxy"]])
                if options.get("headers"):
                    for header, value in options["headers"].items():
                        cmd.extend(["-H", f"{header}: {value}"])
            
            # Execute wafw00f scan
            logger.debug(f"Executing: {' '.join(cmd)}")
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode == 0:
                results = self._parse_wafw00f_output(stdout.decode())
                logger.info(f"âœ… WAF detection completed for {target}")
                return {
                    "success": True,
                    "target": target,
                    "waf_detected": results.get("waf_detected", False),
                    "waf_name": results.get("waf_name"),
                    "confidence": results.get("confidence"),
                    "details": results.get("details", {}),
                    "raw_output": stdout.decode(),
                    "timestamp": self._get_timestamp()
                }
            else:
                error_msg = stderr.decode().strip()
                logger.error(f"âŒ Wafw00f scan failed: {error_msg}")
                return {
                    "success": False,
                    "target": target,
                    "error": error_msg,
                    "timestamp": self._get_timestamp()
                }
                
        except FileNotFoundError:
            logger.error("âŒ Wafw00f not found - install with: pip install wafw00f")
            return await self._fallback_waf_detection(target)
        except Exception as e:
            logger.error(f"âŒ Wafw00f scan error: {e}")
            return await self._fallback_waf_detection(target)
    
    def _parse_wafw00f_output(self, output: str) -> Dict[str, Any]:
        """Parse wafw00f output to extract WAF information"""
        results = {
            "waf_detected": False,
            "waf_name": None,
            "confidence": "unknown",
            "details": {}
        }
        
        lines = output.split('\n')
        
        for line in lines:
            line = line.strip()
            
            # Check for WAF detection
            if "is behind" in line.lower():
                results["waf_detected"] = True
                # Extract WAF name
                if "(" in line and ")" in line:
                    waf_name = line.split("(")[1].split(")")[0].strip()
                    results["waf_name"] = waf_name
                    
            elif "no waf" in line.lower() or "not behind" in line.lower():
                results["waf_detected"] = False
                
            # Extract confidence if available
            elif "confidence" in line.lower():
                if "high" in line.lower():
                    results["confidence"] = "high"
                elif "medium" in line.lower():
                    results["confidence"] = "medium"
                elif "low" in line.lower():
                    results["confidence"] = "low"
        
        return results
    
    async def _fallback_waf_detection(self, target: str) -> Dict[str, Any]:
        """
        Fallback WAF detection using HTTP headers analysis
        """
        logger.info(f"ðŸ”§ Using fallback WAF detection for {target}")
        
        try:
            import aiohttp
            
            async with aiohttp.ClientSession() as session:
                # Test for common WAF signatures
                waf_signatures = {
                    "cloudflare": ["cf-ray", "cf-cache-status", "__cfduid"],
                    "aws_waf": ["x-amzn-requestid", "x-amz-cf-id"],
                    "akamai": ["akamai-ghost-ip", "x-akamai-request-id"],
                    "incapsula": ["x-iinfo", "incap_ses"],
                    "sucuri": ["x-sucuri-id", "x-sucuri-cache"],
                    "barracuda": ["barra"],
                    "f5_bigip": ["bigipserver", "f5-ltm-pool"],
                    "fortinet": ["fortigate", "x-fw"]
                }
                
                async with session.get(f"http://{target}") as response:
                    headers = dict(response.headers)
                    
                    detected_wafs = []
                    for waf_name, signatures in waf_signatures.items():
                        for signature in signatures:
                            if any(signature.lower() in header.lower() for header in headers.keys()):
                                detected_wafs.append(waf_name)
                                break
                    
                    return {
                        "success": True,
                        "target": target,
                        "waf_detected": len(detected_wafs) > 0,
                        "waf_name": detected_wafs[0] if detected_wafs else None,
                        "detected_wafs": detected_wafs,
                        "method": "fallback_header_analysis",
                        "headers": headers,
                        "timestamp": self._get_timestamp()
                    }
                    
        except Exception as e:
            logger.error(f"âŒ Fallback WAF detection failed: {e}")
            return {
                "success": False,
                "target": target,
                "error": f"Fallback detection failed: {str(e)}",
                "timestamp": self._get_timestamp()
            }
    
    async def bulk_waf_scan(
        self,
        targets: List[str],
        options: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Perform WAF detection on multiple targets
        """
        logger.info(f"ðŸ›¡ï¸ Starting bulk WAF detection for {len(targets)} targets")
        
        results = []
        for target in targets:
            result = await self.detect_waf(target, options)
            results.append(result)
            
            # Small delay between requests
            await asyncio.sleep(0.5)
        
        return {
            "success": True,
            "total_targets": len(targets),
            "results": results,
            "summary": self._generate_waf_summary(results),
            "timestamp": self._get_timestamp()
        }
    
    def _generate_waf_summary(self, results: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Generate summary of WAF detection results"""
        total = len(results)
        detected = sum(1 for r in results if r.get("waf_detected"))
        waf_types = {}
        
        for result in results:
            if result.get("waf_detected") and result.get("waf_name"):
                waf_name = result["waf_name"]
                waf_types[waf_name] = waf_types.get(waf_name, 0) + 1
        
        return {
            "total_scanned": total,
            "waf_detected": detected,
            "no_waf": total - detected,
            "detection_rate": f"{(detected/total)*100:.1f}%" if total > 0 else "0%",
            "waf_distribution": waf_types
        }
    
    async def execute(self, target: str, config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Main execution method required by BaseAgent"""
        return await self.detect_waf(target, config)
    
    def get_scan_info(self) -> Dict[str, Any]:
        """Get information about this scanning agent"""
        return {
            "name": "Wafw00f WAF Detection Agent",
            "description": "Professional Web Application Firewall detection and identification",
            "capabilities": [
                "WAF Detection and Fingerprinting",
                "Security Solution Identification", 
                "HTTP Header Analysis",
                "Bulk Target Scanning",
                "Fallback Detection Methods"
            ],
            "supported_targets": ["domains", "URLs", "IP addresses"],
            "output_formats": ["structured", "raw"],
            "tool_version": "wafw00f",
            "agent_version": "1.0.0"
        }
