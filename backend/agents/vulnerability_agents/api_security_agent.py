"""
API Security Agent for Nexus Hunter
Comprehensive REST API security testing and vulnerability assessment
"""

import asyncio
import json
import base64
import re
from typing import Dict, List, Any, Optional, Set
from dataclasses import dataclass
from urllib.parse import urlparse, urljoin

import httpx
from loguru import logger

from agents.base import BaseAgent


@dataclass
class APIVulnerability:
    """API vulnerability finding"""
    name: str
    description: str
    severity: str
    category: str
    evidence: str
    endpoint: str
    method: str
    recommendation: str


class APISecurityAgent(BaseAgent):
    """Comprehensive API security assessment agent"""
    
    def __init__(self):
        super().__init__("APISecurityAgent")
        self.discovered_endpoints = set()
        self.tested_endpoints = set()
        self.api_vulnerabilities = []
        
        # Common API paths and patterns
        self.api_patterns = [
            "/api", "/api/v1", "/api/v2", "/api/v3",
            "/rest", "/graphql", "/soap", "/rpc",
            "/service", "/services", "/endpoint", "/endpoints"
        ]
        
        # HTTP methods to test
        self.http_methods = ["GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS"]
        
        # Common API parameters
        self.common_params = [
            "id", "user", "admin", "token", "key", "password", "email",
            "username", "role", "permission", "api_key", "access_token",
            "limit", "offset", "page", "size", "format", "callback"
        ]
        
        # Sensitive data patterns
        self.sensitive_patterns = {
            "api_keys": r"api[_-]?key['\"]?\s*[:=]\s*['\"]?[a-zA-Z0-9]{16,}",
            "tokens": r"token['\"]?\s*[:=]\s*['\"]?[a-zA-Z0-9._-]{16,}",
            "passwords": r"password['\"]?\s*[:=]\s*['\"]?[^'\"]{8,}",
            "secrets": r"secret['\"]?\s*[:=]\s*['\"]?[a-zA-Z0-9]{16,}",
            "jwt": r"eyJ[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+\.[A-Za-z0-9_-]+",
            "emails": r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b"
        }
    
    async def execute(self, target: str, config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Main execution method required by BaseAgent"""
        return await self.scan(target, **(config or {}))
    
    async def scan(self, target: str, **kwargs) -> Dict[str, Any]:
        """
        Perform comprehensive API security assessment
        
        Args:
            target: Target URL or API base URL
            **kwargs: Additional scan options
        """
        try:
            results = {
                "target": target,
                "discovered_endpoints": [],
                "vulnerabilities": [],
                "api_documentation": {},
                "authentication_analysis": {},
                "rate_limiting": {},
                "data_exposure": {},
                "statistics": {}
            }
            
            self.logger.info(f"Starting API security scan for {target}")
            
            # Discover API endpoints
            endpoints = await self._discover_api_endpoints(target)
            results["discovered_endpoints"] = endpoints
            self.discovered_endpoints = set(ep["url"] for ep in endpoints)
            
            # Analyze API documentation
            api_docs = await self._analyze_api_documentation(target)
            results["api_documentation"] = api_docs
            
            # Test authentication and authorization
            auth_analysis = await self._test_authentication(target, endpoints)
            results["authentication_analysis"] = auth_analysis
            
            # Test rate limiting
            rate_limit_analysis = await self._test_rate_limiting(endpoints)
            results["rate_limiting"] = rate_limit_analysis
            
            # Test for data exposure
            data_exposure = await self._test_data_exposure(endpoints)
            results["data_exposure"] = data_exposure
            
            # Test each endpoint for vulnerabilities
            for endpoint in endpoints[:20]:  # Limit for performance
                endpoint_vulns = await self._test_endpoint_security(endpoint, **kwargs)
                if endpoint_vulns:
                    results["vulnerabilities"].extend(endpoint_vulns)
            
            # Test for API-specific vulnerabilities
            api_vulns = await self._test_api_specific_vulnerabilities(target, endpoints)
            results["vulnerabilities"].extend(api_vulns)
            
            # Analyze results
            results = await self._analyze_api_results(results)
            
            self.logger.info(f"API security scan completed for {target}")
            return results
            
        except Exception as e:
            self.logger.error(f"API security scan failed: {e}")
            return {"error": str(e), "target": target}
    
    async def _discover_api_endpoints(self, target: str) -> List[Dict[str, Any]]:
        """Discover API endpoints and documentation"""
        endpoints = []
        
        try:
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                base_url = target.rstrip('/')
                
                # Test common API paths
                for api_path in self.api_patterns:
                    test_url = f"{base_url}{api_path}"
                    
                    try:
                        response = await client.get(test_url)
                        if response.status_code not in [404, 405]:
                            endpoints.append({
                                "url": test_url,
                                "method": "GET",
                                "status_code": response.status_code,
                                "content_type": response.headers.get("content-type", ""),
                                "response_size": len(response.content),
                                "discovery_method": "path_enumeration"
                            })
                            
                            # Try to discover more endpoints from response
                            additional_endpoints = await self._extract_endpoints_from_response(
                                response, test_url
                            )
                            endpoints.extend(additional_endpoints)
                    
                    except Exception as e:
                        self.logger.debug(f"Failed to test {test_url}: {e}")
                
                # Look for API documentation endpoints
                doc_paths = ["/docs", "/swagger", "/api-docs", "/openapi.json", "/swagger.json"]
                for doc_path in doc_paths:
                    doc_url = f"{base_url}{doc_path}"
                    
                    try:
                        response = await client.get(doc_url)
                        if response.status_code == 200:
                            endpoints.append({
                                "url": doc_url,
                                "method": "GET",
                                "status_code": response.status_code,
                                "content_type": response.headers.get("content-type", ""),
                                "discovery_method": "documentation",
                                "is_documentation": True
                            })
                    
                    except Exception as e:
                        self.logger.debug(f"Failed to test documentation {doc_url}: {e}")
        
        except Exception as e:
            self.logger.error(f"API endpoint discovery failed: {e}")
        
        return endpoints
    
    async def _extract_endpoints_from_response(self, response: httpx.Response, base_url: str) -> List[Dict[str, Any]]:
        """Extract additional endpoints from API response"""
        endpoints = []
        
        try:
            content_type = response.headers.get("content-type", "").lower()
            
            if "json" in content_type:
                try:
                    data = response.json()
                    # Look for endpoint patterns in JSON response
                    endpoints.extend(self._extract_from_json(data, base_url))
                except:
                    pass
            
            # Look for URL patterns in response text
            response_text = response.text
            url_patterns = [
                r'/api/[a-zA-Z0-9/_-]+',
                r'/rest/[a-zA-Z0-9/_-]+',
                r'/service/[a-zA-Z0-9/_-]+',
                r'"url":\s*"([^"]+)"',
                r'"endpoint":\s*"([^"]+)"',
                r'"path":\s*"([^"]+)"'
            ]
            
            for pattern in url_patterns:
                matches = re.findall(pattern, response_text, re.IGNORECASE)
                for match in matches[:10]:  # Limit findings
                    if isinstance(match, tuple):
                        match = match[0]
                    
                    endpoint_url = urljoin(base_url, match)
                    endpoints.append({
                        "url": endpoint_url,
                        "method": "GET",
                        "discovery_method": "response_extraction",
                        "discovered_from": base_url
                    })
        
        except Exception as e:
            self.logger.debug(f"Endpoint extraction failed: {e}")
        
        return endpoints
    
    def _extract_from_json(self, data: Any, base_url: str) -> List[Dict[str, Any]]:
        """Extract endpoints from JSON data"""
        endpoints = []
        
        try:
            if isinstance(data, dict):
                # Look for common endpoint keys
                endpoint_keys = ["endpoints", "paths", "routes", "apis", "services"]
                for key in endpoint_keys:
                    if key in data:
                        value = data[key]
                        if isinstance(value, list):
                            for item in value:
                                if isinstance(item, str) and item.startswith('/'):
                                    endpoints.append({
                                        "url": urljoin(base_url, item),
                                        "method": "GET",
                                        "discovery_method": "json_extraction"
                                    })
                        elif isinstance(value, dict):
                            for path in value.keys():
                                if isinstance(path, str) and path.startswith('/'):
                                    endpoints.append({
                                        "url": urljoin(base_url, path),
                                        "method": "GET",
                                        "discovery_method": "json_extraction"
                                    })
                
                # Recursively search nested objects
                for key, value in data.items():
                    if isinstance(value, (dict, list)):
                        endpoints.extend(self._extract_from_json(value, base_url))
            
            elif isinstance(data, list):
                for item in data:
                    endpoints.extend(self._extract_from_json(item, base_url))
        
        except Exception as e:
            self.logger.debug(f"JSON extraction failed: {e}")
        
        return endpoints
    
    async def _analyze_api_documentation(self, target: str) -> Dict[str, Any]:
        """Analyze API documentation for security issues"""
        doc_analysis = {
            "documentation_found": False,
            "documentation_accessible": False,
            "sensitive_info_exposed": [],
            "endpoints_documented": [],
            "security_schemes": []
        }
        
        try:
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                base_url = target.rstrip('/')
                
                # Common documentation endpoints
                doc_endpoints = [
                    "/swagger", "/swagger.json", "/swagger.yaml",
                    "/api-docs", "/docs", "/openapi.json",
                    "/redoc", "/api/docs", "/api/swagger"
                ]
                
                for doc_path in doc_endpoints:
                    doc_url = f"{base_url}{doc_path}"
                    
                    try:
                        response = await client.get(doc_url)
                        if response.status_code == 200:
                            doc_analysis["documentation_found"] = True
                            doc_analysis["documentation_accessible"] = True
                            
                            # Check for sensitive information in documentation
                            doc_content = response.text.lower()
                            
                            # Look for sensitive patterns
                            for pattern_name, pattern in self.sensitive_patterns.items():
                                if re.search(pattern, doc_content, re.IGNORECASE):
                                    doc_analysis["sensitive_info_exposed"].append({
                                        "type": pattern_name,
                                        "location": doc_path,
                                        "severity": "high" if pattern_name in ["passwords", "api_keys"] else "medium"
                                    })
                            
                            # Try to parse Swagger/OpenAPI
                            if "json" in response.headers.get("content-type", ""):
                                try:
                                    swagger_data = response.json()
                                    doc_analysis["endpoints_documented"] = list(swagger_data.get("paths", {}).keys())
                                    doc_analysis["security_schemes"] = list(swagger_data.get("securityDefinitions", {}).keys())
                                except:
                                    pass
                    
                    except Exception as e:
                        self.logger.debug(f"Documentation check failed for {doc_url}: {e}")
        
        except Exception as e:
            self.logger.error(f"API documentation analysis failed: {e}")
        
        return doc_analysis
    
    async def _test_authentication(self, target: str, endpoints: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Test authentication and authorization mechanisms"""
        auth_analysis = {
            "authentication_required": False,
            "authentication_methods": [],
            "authorization_issues": [],
            "session_management": {},
            "token_security": []
        }
        
        try:
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                # Test endpoints without authentication
                for endpoint in endpoints[:10]:  # Limit testing
                    if endpoint.get("is_documentation"):
                        continue
                    
                    endpoint_url = endpoint["url"]
                    
                    try:
                        response = await client.get(endpoint_url)
                        
                        # Check if authentication is required
                        if response.status_code == 401:
                            auth_analysis["authentication_required"] = True
                            
                            # Check WWW-Authenticate header
                            auth_header = response.headers.get("www-authenticate", "")
                            if auth_header:
                                auth_analysis["authentication_methods"].append(auth_header)
                        
                        elif response.status_code == 403:
                            auth_analysis["authorization_issues"].append({
                                "endpoint": endpoint_url,
                                "issue": "Forbidden access without authentication",
                                "severity": "medium"
                            })
                        
                        elif response.status_code == 200:
                            # Check if sensitive data is accessible without auth
                            response_text = response.text.lower()
                            if any(sensitive in response_text for sensitive in 
                                  ["password", "token", "secret", "api_key", "private"]):
                                auth_analysis["authorization_issues"].append({
                                    "endpoint": endpoint_url,
                                    "issue": "Sensitive data accessible without authentication",
                                    "severity": "high"
                                })
                    
                    except Exception as e:
                        self.logger.debug(f"Authentication test failed for {endpoint_url}: {e}")
                
                # Test common authentication bypasses
                bypass_tests = await self._test_auth_bypasses(client, endpoints)
                auth_analysis["bypass_attempts"] = bypass_tests
        
        except Exception as e:
            self.logger.error(f"Authentication testing failed: {e}")
        
        return auth_analysis
    
    async def _test_auth_bypasses(self, client: httpx.AsyncClient, endpoints: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Test common authentication bypass techniques"""
        bypass_results = []
        
        bypass_headers = [
            {"X-Forwarded-For": "127.0.0.1"},
            {"X-Real-IP": "127.0.0.1"},
            {"X-Originating-IP": "127.0.0.1"},
            {"X-Remote-IP": "127.0.0.1"},
            {"X-Forwarded-Host": "localhost"},
            {"Authorization": "Bearer guest"},
            {"Authorization": "Bearer test"},
            {"X-API-Key": "test"},
            {"X-Admin": "true"}
        ]
        
        for endpoint in endpoints[:5]:  # Limit bypass testing
            endpoint_url = endpoint["url"]
            
            for bypass_header in bypass_headers:
                try:
                    response = await client.get(endpoint_url, headers=bypass_header)
                    
                    if response.status_code == 200:
                        bypass_results.append({
                            "endpoint": endpoint_url,
                            "bypass_method": list(bypass_header.keys())[0],
                            "bypass_value": list(bypass_header.values())[0],
                            "success": True,
                            "severity": "high"
                        })
                
                except Exception as e:
                    self.logger.debug(f"Bypass test failed: {e}")
        
        return bypass_results
    
    async def _test_rate_limiting(self, endpoints: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Test API rate limiting"""
        rate_limit_analysis = {
            "rate_limiting_detected": False,
            "rate_limit_headers": [],
            "rate_limit_bypasses": [],
            "endpoints_tested": []
        }
        
        try:
            async with httpx.AsyncClient(timeout=5, verify=False) as client:
                # Test a few endpoints for rate limiting
                for endpoint in endpoints[:3]:
                    endpoint_url = endpoint["url"]
                    
                    # Send multiple rapid requests
                    responses = []
                    for i in range(10):
                        try:
                            response = await client.get(endpoint_url)
                            responses.append({
                                "request_number": i + 1,
                                "status_code": response.status_code,
                                "headers": dict(response.headers)
                            })
                            
                            # Check for rate limiting headers
                            rate_headers = [h for h in response.headers.keys() 
                                          if "rate" in h.lower() or "limit" in h.lower()]
                            if rate_headers:
                                rate_limit_analysis["rate_limit_headers"].extend(rate_headers)
                            
                            # Check for rate limiting response
                            if response.status_code in [429, 503]:
                                rate_limit_analysis["rate_limiting_detected"] = True
                        
                        except Exception as e:
                            self.logger.debug(f"Rate limit test failed: {e}")
                    
                    rate_limit_analysis["endpoints_tested"].append({
                        "endpoint": endpoint_url,
                        "responses": responses
                    })
        
        except Exception as e:
            self.logger.error(f"Rate limiting test failed: {e}")
        
        return rate_limit_analysis
    
    async def _test_data_exposure(self, endpoints: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Test for sensitive data exposure"""
        data_exposure = {
            "sensitive_data_found": [],
            "pii_exposure": [],
            "debug_info_exposed": [],
            "error_information_leakage": []
        }
        
        try:
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                for endpoint in endpoints[:15]:  # Test more endpoints for data exposure
                    endpoint_url = endpoint["url"]
                    
                    try:
                        response = await client.get(endpoint_url)
                        response_text = response.text
                        
                        # Check for sensitive data patterns
                        for pattern_name, pattern in self.sensitive_patterns.items():
                            matches = re.findall(pattern, response_text, re.IGNORECASE)
                            if matches:
                                data_exposure["sensitive_data_found"].append({
                                    "endpoint": endpoint_url,
                                    "type": pattern_name,
                                    "matches_count": len(matches),
                                    "severity": "high" if pattern_name in ["passwords", "api_keys"] else "medium"
                                })
                        
                        # Check for debug information
                        debug_indicators = [
                            "stack trace", "exception", "error", "debug",
                            "traceback", "sql error", "database error"
                        ]
                        
                        for indicator in debug_indicators:
                            if indicator.lower() in response_text.lower():
                                data_exposure["debug_info_exposed"].append({
                                    "endpoint": endpoint_url,
                                    "indicator": indicator,
                                    "severity": "medium"
                                })
                        
                        # Test with malformed requests to trigger errors
                        error_response = await client.get(f"{endpoint_url}?id='; DROP TABLE users; --")
                        if error_response.status_code == 500:
                            error_text = error_response.text.lower()
                            if any(db in error_text for db in ["mysql", "postgresql", "sqlite", "oracle"]):
                                data_exposure["error_information_leakage"].append({
                                    "endpoint": endpoint_url,
                                    "type": "database_error",
                                    "severity": "medium"
                                })
                    
                    except Exception as e:
                        self.logger.debug(f"Data exposure test failed for {endpoint_url}: {e}")
        
        except Exception as e:
            self.logger.error(f"Data exposure testing failed: {e}")
        
        return data_exposure
    
    async def _test_endpoint_security(self, endpoint: Dict[str, Any], **kwargs) -> List[Dict[str, Any]]:
        """Test individual endpoint for security vulnerabilities"""
        vulnerabilities = []
        endpoint_url = endpoint["url"]
        
        try:
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                # Test HTTP methods
                method_vulns = await self._test_http_methods(client, endpoint_url)
                vulnerabilities.extend(method_vulns)
                
                # Test parameter manipulation
                param_vulns = await self._test_parameter_manipulation(client, endpoint_url)
                vulnerabilities.extend(param_vulns)
                
                # Test injection vulnerabilities
                injection_vulns = await self._test_api_injections(client, endpoint_url)
                vulnerabilities.extend(injection_vulns)
        
        except Exception as e:
            self.logger.debug(f"Endpoint security testing failed for {endpoint_url}: {e}")
        
        return vulnerabilities
    
    async def _test_http_methods(self, client: httpx.AsyncClient, endpoint_url: str) -> List[Dict[str, Any]]:
        """Test HTTP methods for security issues"""
        vulnerabilities = []
        
        for method in self.http_methods:
            try:
                response = await client.request(method, endpoint_url)
                
                # Check for method not allowed but informative responses
                if method in ["DELETE", "PUT"] and response.status_code == 200:
                    vulnerabilities.append({
                        "name": f"Dangerous HTTP Method Allowed: {method}",
                        "description": f"Endpoint allows potentially dangerous {method} method",
                        "severity": "medium" if method == "DELETE" else "low",
                        "category": "HTTP Methods",
                        "evidence": f"{method} request returned status {response.status_code}",
                        "endpoint": endpoint_url,
                        "method": method,
                        "recommendation": f"Restrict {method} method if not required"
                    })
                
                # Check for verbose error messages
                if response.status_code >= 400 and len(response.text) > 500:
                    vulnerabilities.append({
                        "name": "Verbose Error Messages",
                        "description": "API returns detailed error information",
                        "severity": "low",
                        "category": "Information Disclosure",
                        "evidence": f"Verbose error response for {method} method",
                        "endpoint": endpoint_url,
                        "method": method,
                        "recommendation": "Implement generic error messages"
                    })
            
            except Exception as e:
                self.logger.debug(f"HTTP method test failed for {method}: {e}")
        
        return vulnerabilities
    
    async def _test_parameter_manipulation(self, client: httpx.AsyncClient, endpoint_url: str) -> List[Dict[str, Any]]:
        """Test parameter manipulation vulnerabilities"""
        vulnerabilities = []
        
        # Test common parameters
        test_params = {
            "admin": "true",
            "role": "admin",
            "user_id": "1",
            "id": "1' OR '1'='1",
            "limit": "999999",
            "debug": "true"
        }
        
        for param, value in test_params.items():
            try:
                response = await client.get(f"{endpoint_url}?{param}={value}")
                
                # Check for privilege escalation indicators
                response_text = response.text.lower()
                if param in ["admin", "role"] and any(indicator in response_text 
                                                    for indicator in ["admin", "administrator", "privileged"]):
                    vulnerabilities.append({
                        "name": "Potential Privilege Escalation",
                        "description": f"Parameter {param} may allow privilege escalation",
                        "severity": "high",
                        "category": "Authorization",
                        "evidence": f"Response contains admin indicators when {param}={value}",
                        "endpoint": endpoint_url,
                        "method": "GET",
                        "recommendation": "Implement proper authorization checks"
                    })
            
            except Exception as e:
                self.logger.debug(f"Parameter manipulation test failed: {e}")
        
        return vulnerabilities
    
    async def _test_api_injections(self, client: httpx.AsyncClient, endpoint_url: str) -> List[Dict[str, Any]]:
        """Test for injection vulnerabilities in API"""
        vulnerabilities = []
        
        # SQL injection payloads
        sql_payloads = ["'", "1' OR '1'='1", "'; DROP TABLE users; --", "1' UNION SELECT NULL--"]
        
        # NoSQL injection payloads
        nosql_payloads = ['{"$ne": null}', '{"$gt": ""}', '{"$regex": ".*"}']
        
        # Command injection payloads
        cmd_payloads = [";ls", "|whoami", "$(whoami)", "`whoami`"]
        
        all_payloads = [
            ("SQL Injection", sql_payloads),
            ("NoSQL Injection", nosql_payloads),
            ("Command Injection", cmd_payloads)
        ]
        
        for injection_type, payloads in all_payloads:
            for payload in payloads[:2]:  # Limit payloads
                try:
                    # Test in URL parameter
                    response = await client.get(f"{endpoint_url}?id={payload}")
                    
                    # Check for error indicators
                    error_indicators = {
                        "SQL Injection": ["sql", "mysql", "postgresql", "sqlite", "syntax error"],
                        "NoSQL Injection": ["mongodb", "invalid bson", "json"],
                        "Command Injection": ["command not found", "permission denied", "root@"]
                    }
                    
                    response_text = response.text.lower()
                    for indicator in error_indicators.get(injection_type, []):
                        if indicator in response_text:
                            vulnerabilities.append({
                                "name": f"{injection_type} Vulnerability",
                                "description": f"Potential {injection_type.lower()} vulnerability detected",
                                "severity": "high",
                                "category": "Injection",
                                "evidence": f"Error indicator '{indicator}' found with payload: {payload}",
                                "endpoint": endpoint_url,
                                "method": "GET",
                                "recommendation": f"Implement input validation to prevent {injection_type.lower()}"
                            })
                
                except Exception as e:
                    self.logger.debug(f"Injection test failed: {e}")
        
        return vulnerabilities
    
    async def _test_api_specific_vulnerabilities(self, target: str, endpoints: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Test for API-specific vulnerabilities"""
        vulnerabilities = []
        
        try:
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                # Test for CORS misconfigurations
                cors_vulns = await self._test_cors_issues(client, target)
                vulnerabilities.extend(cors_vulns)
                
                # Test for API versioning issues
                version_vulns = await self._test_api_versioning(client, target)
                vulnerabilities.extend(version_vulns)
                
                # Test for GraphQL specific issues if GraphQL endpoint found
                graphql_endpoints = [ep for ep in endpoints if "graphql" in ep["url"].lower()]
                for graphql_ep in graphql_endpoints:
                    graphql_vulns = await self._test_graphql_issues(client, graphql_ep["url"])
                    vulnerabilities.extend(graphql_vulns)
        
        except Exception as e:
            self.logger.error(f"API-specific vulnerability testing failed: {e}")
        
        return vulnerabilities
    
    async def _test_cors_issues(self, client: httpx.AsyncClient, target: str) -> List[Dict[str, Any]]:
        """Test for CORS misconfigurations"""
        vulnerabilities = []
        
        try:
            # Test with malicious origin
            headers = {"Origin": "https://evil.com"}
            response = await client.options(target, headers=headers)
            
            cors_headers = {
                "access-control-allow-origin": response.headers.get("Access-Control-Allow-Origin"),
                "access-control-allow-credentials": response.headers.get("Access-Control-Allow-Credentials"),
                "access-control-allow-methods": response.headers.get("Access-Control-Allow-Methods")
            }
            
            # Check for wildcard with credentials
            if (cors_headers["access-control-allow-origin"] == "*" and 
                cors_headers["access-control-allow-credentials"] == "true"):
                vulnerabilities.append({
                    "name": "CORS Misconfiguration",
                    "description": "CORS allows any origin with credentials",
                    "severity": "high",
                    "category": "CORS",
                    "evidence": "Access-Control-Allow-Origin: * with credentials enabled",
                    "endpoint": target,
                    "method": "OPTIONS",
                    "recommendation": "Restrict CORS origins and disable credentials for wildcard origins"
                })
            
            # Check if evil origin is allowed
            if cors_headers["access-control-allow-origin"] == "https://evil.com":
                vulnerabilities.append({
                    "name": "CORS Origin Reflection",
                    "description": "CORS reflects arbitrary origins",
                    "severity": "medium",
                    "category": "CORS",
                    "evidence": "Malicious origin reflected in CORS headers",
                    "endpoint": target,
                    "method": "OPTIONS",
                    "recommendation": "Implement proper origin validation"
                })
        
        except Exception as e:
            self.logger.debug(f"CORS testing failed: {e}")
        
        return vulnerabilities
    
    async def _test_api_versioning(self, client: httpx.AsyncClient, target: str) -> List[Dict[str, Any]]:
        """Test API versioning security issues"""
        vulnerabilities = []
        
        try:
            base_url = target.rstrip('/')
            versions = ["v1", "v2", "v3", "v0", "beta", "alpha", "old"]
            
            for version in versions:
                version_url = f"{base_url}/api/{version}"
                
                try:
                    response = await client.get(version_url)
                    if response.status_code == 200:
                        # Check if older versions have different security
                        if version in ["v0", "v1", "old", "beta", "alpha"]:
                            vulnerabilities.append({
                                "name": "Legacy API Version Accessible",
                                "description": f"Legacy API version {version} is accessible",
                                "severity": "medium",
                                "category": "API Versioning",
                                "evidence": f"API version {version} returns 200 OK",
                                "endpoint": version_url,
                                "method": "GET",
                                "recommendation": "Disable or properly secure legacy API versions"
                            })
                
                except Exception as e:
                    self.logger.debug(f"Version test failed for {version}: {e}")
        
        except Exception as e:
            self.logger.debug(f"API versioning test failed: {e}")
        
        return vulnerabilities
    
    async def _test_graphql_issues(self, client: httpx.AsyncClient, graphql_url: str) -> List[Dict[str, Any]]:
        """Test GraphQL-specific vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Test introspection query
            introspection_query = {
                "query": "{ __schema { types { name } } }"
            }
            
            response = await client.post(graphql_url, json=introspection_query)
            
            if response.status_code == 200 and "types" in response.text:
                vulnerabilities.append({
                    "name": "GraphQL Introspection Enabled",
                    "description": "GraphQL introspection is enabled in production",
                    "severity": "medium",
                    "category": "GraphQL",
                    "evidence": "Introspection query returned schema information",
                    "endpoint": graphql_url,
                    "method": "POST",
                    "recommendation": "Disable GraphQL introspection in production"
                })
            
            # Test for query depth/complexity issues
            deep_query = {
                "query": "{ " + "user { friends { " * 10 + "name" + " } }" * 10 + " }"
            }
            
            response = await client.post(graphql_url, json=deep_query)
            if response.status_code == 200:
                vulnerabilities.append({
                    "name": "GraphQL Query Depth Not Limited",
                    "description": "GraphQL allows deeply nested queries",
                    "severity": "medium",
                    "category": "GraphQL",
                    "evidence": "Deep nested query was processed",
                    "endpoint": graphql_url,
                    "method": "POST",
                    "recommendation": "Implement query depth limiting"
                })
        
        except Exception as e:
            self.logger.debug(f"GraphQL testing failed: {e}")
        
        return vulnerabilities
    
    async def _analyze_api_results(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze and categorize API security results"""
        try:
            vulnerabilities = results["vulnerabilities"]
            
            # Categorize by severity
            critical_vulns = [v for v in vulnerabilities if v.get("severity") == "critical"]
            high_vulns = [v for v in vulnerabilities if v.get("severity") == "high"]
            medium_vulns = [v for v in vulnerabilities if v.get("severity") == "medium"]
            low_vulns = [v for v in vulnerabilities if v.get("severity") == "low"]
            
            # Categorize by type
            auth_issues = [v for v in vulnerabilities if v.get("category") == "Authorization"]
            injection_issues = [v for v in vulnerabilities if v.get("category") == "Injection"]
            cors_issues = [v for v in vulnerabilities if v.get("category") == "CORS"]
            info_disclosure = [v for v in vulnerabilities if v.get("category") == "Information Disclosure"]
            
            results["categorized_vulnerabilities"] = {
                "critical": critical_vulns,
                "high": high_vulns,
                "medium": medium_vulns,
                "low": low_vulns
            }
            
            results["vulnerability_categories"] = {
                "authorization": auth_issues,
                "injection": injection_issues,
                "cors": cors_issues,
                "information_disclosure": info_disclosure
            }
            
            # Calculate security metrics
            total_endpoints = len(results["discovered_endpoints"])
            secure_endpoints = total_endpoints - len(set(v.get("endpoint") for v in vulnerabilities))
            
            results["statistics"] = {
                "total_vulnerabilities": len(vulnerabilities),
                "critical_count": len(critical_vulns),
                "high_count": len(high_vulns),
                "medium_count": len(medium_vulns),
                "low_count": len(low_vulns),
                "total_endpoints": total_endpoints,
                "vulnerable_endpoints": len(set(v.get("endpoint") for v in vulnerabilities)),
                "secure_endpoints": secure_endpoints,
                "security_score": (secure_endpoints / max(total_endpoints, 1)) * 100,
                "documentation_accessible": results["api_documentation"].get("documentation_accessible", False),
                "authentication_required": results["authentication_analysis"].get("authentication_required", False),
                "rate_limiting_detected": results["rate_limiting"].get("rate_limiting_detected", False)
            }
            
            results["recommendations"] = self._generate_api_recommendations(results)
            
            return results
        
        except Exception as e:
            self.logger.error(f"API results analysis failed: {e}")
            return results
    
    def _generate_api_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Generate API-specific security recommendations"""
        recommendations = []
        
        if results["statistics"]["total_vulnerabilities"] > 0:
            recommendations.extend([
                "Implement proper input validation and sanitization",
                "Use parameterized queries to prevent injection attacks",
                "Implement proper authentication and authorization mechanisms",
                "Configure CORS policies securely",
                "Implement rate limiting to prevent abuse"
            ])
        
        if results["api_documentation"]["documentation_accessible"]:
            recommendations.append("Restrict access to API documentation in production")
        
        if not results["authentication_analysis"]["authentication_required"]:
            recommendations.append("Implement authentication for API endpoints")
        
        if not results["rate_limiting"]["rate_limiting_detected"]:
            recommendations.append("Implement rate limiting for API endpoints")
        
        recommendations.extend([
            "Use HTTPS for all API communications",
            "Implement proper error handling to prevent information leakage",
            "Use API versioning and deprecate old versions securely",
            "Implement logging and monitoring for API access",
            "Regular security testing and code reviews"
        ])
        
        return recommendations
    
    def get_vulnerability_types(self) -> List[str]:
        """Get types of API vulnerabilities this agent can detect"""
        return [
            "Authentication Bypass",
            "Authorization Issues",
            "Injection Vulnerabilities",
            "CORS Misconfigurations",
            "Information Disclosure",
            "Rate Limiting Issues",
            "GraphQL Vulnerabilities",
            "API Versioning Issues"
        ]
    
    def get_description(self) -> str:
        """Get agent description"""
        return "Comprehensive API security assessment agent for REST, GraphQL, and other API technologies"

