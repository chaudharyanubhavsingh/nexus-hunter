"""
Supply Chain Security Testing Agent
===================================

This agent performs comprehensive supply chain security testing including:
- Dependency confusion attacks detection
- Software supply chain tampering analysis  
- Package integrity verification
- Third-party library security assessment
- NPM/PyPI/Maven typosquatting detection
- Private package impersonation testing
- Software Bill of Materials (SBOM) analysis

Author: Nexus Hunter Security Team
Version: 1.0
"""

import asyncio
import aiohttp
import json
import time
import hashlib
import re
import base64
import subprocess
from typing import Dict, List, Any, Optional, Tuple
from urllib.parse import urljoin, urlparse
from pathlib import Path
from ..base import BaseAgent


class SupplyChainSecurityAgent(BaseAgent):
    """Advanced Supply Chain Security Testing Agent"""
    
    def __init__(self):
        super().__init__("Supply Chain Security Agent", "supply_chain_security")
        self.description = "Comprehensive software supply chain security testing"
        self.version = "1.0"
        
        # Supply chain attack categories
        self.test_categories = {
            'dependency_confusion': 'Dependency confusion and typosquatting attacks',
            'package_integrity': 'Package integrity and signature verification',
            'malicious_packages': 'Malicious package detection and analysis',
            'supply_chain_tampering': 'Third-party library tampering detection',
            'private_repo_exposure': 'Private repository and package exposure',
            'sbom_analysis': 'Software Bill of Materials security analysis',
            'license_compliance': 'Open source license and security compliance',
            'vulnerability_propagation': 'Dependency vulnerability propagation analysis'
        }
        
        # Package managers and ecosystems
        self.package_ecosystems = {
            'npm': {
                'files': ['package.json', 'package-lock.json', 'yarn.lock'],
                'registry': 'https://registry.npmjs.org/',
                'private_patterns': ['@company/', '@internal/', '@private/']
            },
            'pypi': {
                'files': ['requirements.txt', 'setup.py', 'pyproject.toml', 'Pipfile', 'poetry.lock'],
                'registry': 'https://pypi.org/pypi/',
                'private_patterns': ['company-', 'internal-', 'private-']
            },
            'maven': {
                'files': ['pom.xml', 'build.gradle', 'gradle.properties'],
                'registry': 'https://repo1.maven.org/maven2/',
                'private_patterns': ['com.company.', 'com.internal.', 'com.private.']
            },
            'nuget': {
                'files': ['packages.config', '*.csproj', 'Directory.Build.props'],
                'registry': 'https://api.nuget.org/v3-flatcontainer/',
                'private_patterns': ['Company.', 'Internal.', 'Private.']
            },
            'composer': {
                'files': ['composer.json', 'composer.lock'],
                'registry': 'https://packagist.org/packages/',
                'private_patterns': ['company/', 'internal/', 'private/']
            }
        }
        
        # Dependency confusion attack payloads
        self.confusion_indicators = [
            # Common typosquatting patterns
            'lodash', 'react', 'express', 'axios', 'request', 'moment',
            'django', 'flask', 'requests', 'numpy', 'pandas', 'tensorflow',
            'spring-boot', 'jackson', 'apache-commons', 'log4j',
            # Malicious package indicators
            'discord-webhook', 'crypto-miner', 'system-info-collector',
            'env-extractor', 'credential-harvester', 'backdoor-toolkit'
        ]
        
        # Malicious code patterns
        self.malicious_patterns = [
            # Data exfiltration
            r'process\.env\[.*\]', r'os\.environ\[.*\]', r'System\.getenv\(',
            # Network communication
            r'http[s]?://[^/\s]+/collect', r'webhook\.discord\.com',
            r'api\.telegram\.org', r'pastebin\.com/api',
            # File system access
            r'fs\.readFile.*\.ssh', r'os\.path\.expanduser\(.*\.ssh',
            r'System\.IO\.File\.ReadAllText.*ssh',
            # Cryptocurrency/mining
            r'bitcoin', r'ethereum', r'monero', r'mining', r'crypto',
            # Obfuscation indicators  
            r'eval\(', r'Function\(.*\)', r'exec\(', r'compile\(',
            # Persistence mechanisms
            r'crontab', r'systemd', r'registry.*Run', r'startup'
        ]

    async def execute(self, target: str, context: Dict = None) -> Dict[str, Any]:
        """Execute comprehensive supply chain security testing"""
        results = {
            'agent': self.name,
            'version': self.version,
            'target': target,
            'timestamp': time.time(),
            'vulnerabilities': [],
            'findings': {},
            'packages_analyzed': 0,
            'supply_chain_risks': [],
            'risk_score': 0,
            'test_summary': {}
        }
        
        try:
            async with aiohttp.ClientSession(
                timeout=aiohttp.ClientTimeout(total=60),
                connector=aiohttp.TCPConnector(limit=20)
            ) as session:
                
                # 1. Dependency File Discovery and Analysis
                await self._discover_and_analyze_dependencies(session, target, results)
                await asyncio.sleep(1)
                
                # 2. Dependency Confusion Attack Testing
                await self._test_dependency_confusion(session, target, results)
                await asyncio.sleep(1)
                
                # 3. Package Integrity Verification
                await self._verify_package_integrity(session, target, results)
                await asyncio.sleep(1)
                
                # 4. Malicious Package Detection
                await self._detect_malicious_packages(session, target, results)
                await asyncio.sleep(1)
                
                # 5. Private Repository Exposure Testing
                await self._test_private_repo_exposure(session, target, results)
                await asyncio.sleep(1)
                
                # 6. Supply Chain Tampering Detection
                await self._detect_supply_chain_tampering(session, target, results)
                await asyncio.sleep(1)
                
                # 7. SBOM Security Analysis
                await self._analyze_sbom_security(session, target, results)
                
        except Exception as e:
            results['error'] = f"Supply chain security testing failed: {str(e)}"
            results['success'] = False
            return results
        
        # Calculate final risk score
        results['risk_score'] = self._calculate_risk_score(results)
        results['success'] = True
        
        return results

    async def _discover_and_analyze_dependencies(self, session: aiohttp.ClientSession, target: str, results: Dict) -> None:
        """Discover and analyze dependency files"""
        findings = []
        dependency_files_found = []
        
        # Try to find dependency files through web crawling
        for ecosystem, config in self.package_ecosystems.items():
            for dep_file in config['files']:
                test_urls = [
                    f"{target}/{dep_file}",
                    f"{target}/.{dep_file}",
                    f"{target}/src/{dep_file}",
                    f"{target}/app/{dep_file}",
                    f"{target}/backend/{dep_file}",
                    f"{target}/frontend/{dep_file}"
                ]
                
                for test_url in test_urls:
                    try:
                        async with session.get(test_url) as response:
                            if response.status == 200:
                                content = await response.text()
                                
                                if len(content) > 50:  # Valid dependency file
                                    dependency_files_found.append({
                                        'ecosystem': ecosystem,
                                        'file': dep_file,
                                        'url': test_url,
                                        'size': len(content)
                                    })
                                    
                                    # Analyze file content for security issues
                                    security_issues = await self._analyze_dependency_file_security(content, ecosystem)
                                    
                                    if security_issues:
                                        findings.extend(security_issues)
                                    
                                    # Extract package information
                                    packages = await self._extract_packages_from_file(content, ecosystem)
                                    results['packages_analyzed'] += len(packages)
                                    
                                    findings.append({
                                        'type': 'Dependency File Exposure',
                                        'severity': 'MEDIUM',
                                        'file': dep_file,
                                        'url': test_url,
                                        'ecosystem': ecosystem,
                                        'packages_count': len(packages),
                                        'evidence': f"Exposed {dep_file} with {len(packages)} packages",
                                        'impact': 'Dependency information disclosure, potential attack surface mapping',
                                        'cwe': 'CWE-200'
                                    })
                        
                        await asyncio.sleep(0.3)
                        
                    except Exception:
                        continue
        
        results['findings']['dependency_discovery'] = findings
        results['test_summary']['dependency_discovery'] = len(findings)
        results['dependency_files_found'] = dependency_files_found

    async def _analyze_dependency_file_security(self, content: str, ecosystem: str) -> List[Dict]:
        """Analyze dependency file content for security issues"""
        security_issues = []
        
        # Check for common security anti-patterns
        if ecosystem == 'npm':
            # Check for postinstall scripts
            if 'postinstall' in content:
                security_issues.append({
                    'type': 'Suspicious PostInstall Script',
                    'severity': 'HIGH',
                    'evidence': 'Package.json contains postinstall scripts that could execute malicious code',
                    'impact': 'Code execution during package installation',
                    'cwe': 'CWE-94'
                })
            
            # Check for wildcard versions
            wildcard_pattern = r'"[^"]*":\s*"[\*\^~><=\s]*"'
            if re.search(wildcard_pattern, content):
                security_issues.append({
                    'type': 'Wildcard Version Dependencies',
                    'severity': 'MEDIUM',
                    'evidence': 'Wildcard or loose version constraints detected',
                    'impact': 'Automatic updates could introduce vulnerable versions',
                    'cwe': 'CWE-1395'
                })
        
        elif ecosystem == 'pypi':
            # Check for setup.py execution risks
            if 'setup.py' in content and any(dangerous in content.lower() for dangerous in ['exec', 'eval', 'subprocess', 'os.system']):
                security_issues.append({
                    'type': 'Dangerous Setup.py Code',
                    'severity': 'HIGH',
                    'evidence': 'Setup.py contains potentially dangerous code execution',
                    'impact': 'Code execution during package installation',
                    'cwe': 'CWE-94'
                })
        
        # Check for malicious patterns across all ecosystems
        for pattern in self.malicious_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                security_issues.append({
                    'type': 'Malicious Code Pattern Detected',
                    'severity': 'CRITICAL',
                    'pattern': pattern,
                    'evidence': f'Malicious code pattern found: {pattern}',
                    'impact': 'Potential malware or data exfiltration code',
                    'cwe': 'CWE-506'
                })
        
        return security_issues

    async def _extract_packages_from_file(self, content: str, ecosystem: str) -> List[Dict]:
        """Extract package information from dependency files"""
        packages = []
        
        try:
            if ecosystem == 'npm' and 'dependencies' in content:
                data = json.loads(content)
                deps = data.get('dependencies', {})
                dev_deps = data.get('devDependencies', {})
                
                for name, version in {**deps, **dev_deps}.items():
                    packages.append({
                        'name': name,
                        'version': version,
                        'ecosystem': ecosystem,
                        'type': 'dependency' if name in deps else 'dev-dependency'
                    })
            
            elif ecosystem == 'pypi':
                # Parse requirements.txt format
                lines = content.split('\n')
                for line in lines:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        # Parse package==version or package>=version format
                        match = re.match(r'([a-zA-Z0-9_-]+)([><=!]+)?(.*)', line)
                        if match:
                            packages.append({
                                'name': match.group(1),
                                'version': match.group(3) if match.group(3) else 'latest',
                                'ecosystem': ecosystem,
                                'constraint': match.group(2) if match.group(2) else None
                            })
            
        except Exception:
            # If parsing fails, still return empty list to continue
            pass
        
        return packages

    async def _test_dependency_confusion(self, session: aiohttp.ClientSession, target: str, results: Dict) -> None:
        """Test for dependency confusion attack vulnerabilities"""
        findings = []
        
        # Test for common typosquatting targets
        for package_name in self.confusion_indicators:
            # Test variations that could indicate typosquatting
            typosquat_variants = [
                package_name + '-utils',
                package_name + '-helper',
                package_name + '-core',
                package_name.replace('-', '_'),
                package_name.replace('_', '-'),
                package_name + 's',  # plural
                package_name[:-1] if len(package_name) > 3 else package_name,  # singular
            ]
            
            for variant in typosquat_variants:
                # Test if the application might be vulnerable to confusion
                test_urls = [
                    f"{target}/node_modules/{variant}/package.json",
                    f"{target}/.npm/{variant}",
                    f"{target}/vendor/{variant}",
                    f"{target}/packages/{variant}"
                ]
                
                for test_url in test_urls:
                    try:
                        async with session.get(test_url) as response:
                            if response.status == 200:
                                content = await response.text()
                                
                                # Check if this could be a typosquatting attack
                                if any(suspicious in content.lower() for suspicious in 
                                      ['collect', 'harvest', 'exfiltrate', 'webhook', 'backdoor']):
                                    
                                    findings.append({
                                        'type': 'Suspected Typosquatting Package',
                                        'severity': 'CRITICAL',
                                        'package': variant,
                                        'original': package_name,
                                        'url': test_url,
                                        'evidence': f'Suspicious package {variant} found (typosquat of {package_name})',
                                        'impact': 'Potential dependency confusion attack',
                                        'cwe': 'CWE-1395'
                                    })
                        
                        await asyncio.sleep(0.2)
                        
                    except Exception:
                        continue
        
        # Test for private package naming patterns that could be confused
        for ecosystem, config in self.package_ecosystems.items():
            for private_pattern in config['private_patterns']:
                # Test if public packages exist with similar names to private patterns
                test_package = private_pattern + 'common'
                
                try:
                    registry_url = config['registry'] + test_package
                    async with session.get(registry_url) as response:
                        if response.status == 200:
                            findings.append({
                                'type': 'Potential Private Package Confusion',
                                'severity': 'HIGH',
                                'ecosystem': ecosystem,
                                'pattern': private_pattern,
                                'evidence': f'Public package found matching private pattern: {test_package}',
                                'impact': 'Private package naming could be confused with public packages',
                                'cwe': 'CWE-1395'
                            })
                    
                    await asyncio.sleep(0.5)
                    
                except Exception:
                    continue
        
        results['findings']['dependency_confusion'] = findings
        results['test_summary']['dependency_confusion'] = len(findings)

    async def _verify_package_integrity(self, session: aiohttp.ClientSession, target: str, results: Dict) -> None:
        """Verify package integrity and signatures"""
        findings = []
        
        # Look for package lock files that contain integrity hashes
        integrity_files = [
            'package-lock.json', 'yarn.lock', 'poetry.lock', 'Pipfile.lock'
        ]
        
        for lock_file in integrity_files:
            test_url = f"{target}/{lock_file}"
            
            try:
                async with session.get(test_url) as response:
                    if response.status == 200:
                        content = await response.text()
                        
                        # Check for integrity verification
                        if 'integrity' not in content and 'sha' not in content:
                            findings.append({
                                'type': 'Missing Package Integrity Verification',
                                'severity': 'MEDIUM',
                                'file': lock_file,
                                'evidence': f'{lock_file} found but lacks integrity hashes',
                                'impact': 'Package tampering cannot be detected',
                                'cwe': 'CWE-353'
                            })
                        else:
                            # Verify integrity hash format
                            if lock_file == 'package-lock.json':
                                # Check for SHA-512 integrity (stronger than SHA-1)
                                if 'sha512-' not in content:
                                    findings.append({
                                        'type': 'Weak Package Integrity Algorithm',
                                        'severity': 'LOW',
                                        'file': lock_file,
                                        'evidence': 'Package lock uses weak integrity algorithm (not SHA-512)',
                                        'impact': 'Weak integrity verification susceptible to collision attacks',
                                        'cwe': 'CWE-327'
                                    })
                
                await asyncio.sleep(0.3)
                
            except Exception:
                continue
        
        results['findings']['package_integrity'] = findings
        results['test_summary']['package_integrity'] = len(findings)

    async def _detect_malicious_packages(self, session: aiohttp.ClientSession, target: str, results: Dict) -> None:
        """Detect potentially malicious packages"""
        findings = []
        
        # Check for packages with suspicious names
        suspicious_package_patterns = [
            r'.*discord.*webhook.*',
            r'.*crypto.*mine.*',
            r'.*system.*info.*',
            r'.*env.*extract.*',
            r'.*credential.*harvest.*',
            r'.*backdoor.*',
            r'.*malware.*',
            r'.*trojan.*'
        ]
        
        # Look for package.json files that might contain malicious packages
        package_file_urls = [
            f"{target}/package.json",
            f"{target}/node_modules/*/package.json"
        ]
        
        for url in package_file_urls:
            try:
                async with session.get(url) as response:
                    if response.status == 200:
                        content = await response.text()
                        
                        # Check for suspicious package names
                        for pattern in suspicious_package_patterns:
                            if re.search(pattern, content, re.IGNORECASE):
                                findings.append({
                                    'type': 'Suspicious Package Name Detected',
                                    'severity': 'HIGH',
                                    'pattern': pattern,
                                    'url': url,
                                    'evidence': f'Package with suspicious name pattern found: {pattern}',
                                    'impact': 'Potentially malicious package included in dependencies',
                                    'cwe': 'CWE-506'
                                })
                        
                        # Check for malicious code patterns in package.json scripts
                        if 'scripts' in content:
                            try:
                                data = json.loads(content)
                                scripts = data.get('scripts', {})
                                
                                for script_name, script_content in scripts.items():
                                    for mal_pattern in self.malicious_patterns:
                                        if re.search(mal_pattern, script_content, re.IGNORECASE):
                                            findings.append({
                                                'type': 'Malicious Script Pattern',
                                                'severity': 'CRITICAL',
                                                'script': script_name,
                                                'pattern': mal_pattern,
                                                'evidence': f'Malicious pattern in {script_name}: {script_content}',
                                                'impact': 'Code execution during package lifecycle',
                                                'cwe': 'CWE-94'
                                            })
                            except json.JSONDecodeError:
                                continue
                
                await asyncio.sleep(0.3)
                
            except Exception:
                continue
        
        results['findings']['malicious_packages'] = findings
        results['test_summary']['malicious_packages'] = len(findings)

    async def _test_private_repo_exposure(self, session: aiohttp.ClientSession, target: str, results: Dict) -> None:
        """Test for private repository and package exposure"""
        findings = []
        
        # Common private repository paths
        private_repo_paths = [
            '/.git/', '/.svn/', '/.hg/',
            '/vendor/', '/node_modules/',
            '/packages/', '/.npm/', '/.yarn/',
            '/composer/', '/vendor/',
            '/.m2/repository/', '/target/dependency/',
            '/dist/', '/build/', '/out/'
        ]
        
        for repo_path in private_repo_paths:
            test_url = f"{target}{repo_path}"
            
            try:
                async with session.get(test_url) as response:
                    if response.status == 200:
                        content = await response.text()
                        
                        # Check for directory listing or private content
                        if any(indicator in content.lower() for indicator in 
                              ['index of', 'directory listing', 'parent directory', 'package.json']):
                            
                            severity = 'HIGH' if repo_path in ['/.git/', '/.svn/'] else 'MEDIUM'
                            
                            findings.append({
                                'type': 'Private Repository Exposure',
                                'severity': severity,
                                'path': repo_path,
                                'url': test_url,
                                'evidence': f'Private repository or package directory exposed: {repo_path}',
                                'impact': 'Source code, dependencies, or credentials exposure',
                                'cwe': 'CWE-200'
                            })
                
                await asyncio.sleep(0.2)
                
            except Exception:
                continue
        
        # Test for exposed npm/yarn caches
        cache_files = [
            '/.npmrc', '/.yarnrc', '/.pip/pip.conf',
            '/.m2/settings.xml', '/composer.json'
        ]
        
        for cache_file in cache_files:
            test_url = f"{target}{cache_file}"
            
            try:
                async with session.get(test_url) as response:
                    if response.status == 200:
                        content = await response.text()
                        
                        # Check for authentication tokens or private registries
                        if any(token_indicator in content.lower() for token_indicator in 
                              ['token', 'password', 'auth', 'registry', 'private']):
                            
                            findings.append({
                                'type': 'Package Manager Configuration Exposure',
                                'severity': 'CRITICAL',
                                'file': cache_file,
                                'url': test_url,
                                'evidence': f'Package manager config exposed: {cache_file}',
                                'impact': 'Authentication tokens or private registry information disclosure',
                                'cwe': 'CWE-200'
                            })
                
                await asyncio.sleep(0.2)
                
            except Exception:
                continue
        
        results['findings']['private_repo_exposure'] = findings
        results['test_summary']['private_repo_exposure'] = len(findings)

    async def _detect_supply_chain_tampering(self, session: aiohttp.ClientSession, target: str, results: Dict) -> None:
        """Detect supply chain tampering indicators"""
        findings = []
        
        # Test for common tampering indicators
        tampering_indicators = [
            # Modified package files
            '/package.json.bak', '/requirements.txt.orig',
            # Suspicious build artifacts  
            '/.modified', '/.patched', '/.tampered',
            # Backdoor files
            '/backdoor.js', '/malware.py', '/trojan.php',
            # Hidden files
            '/.hidden.js', '/._malicious', '/.../',
            # Test utilities that might contain backdoors
            '/test-utils.js', '/dev-helper.py'
        ]
        
        for indicator in tampering_indicators:
            test_url = f"{target}{indicator}"
            
            try:
                async with session.get(test_url) as response:
                    if response.status == 200:
                        content = await response.text()
                        
                        # Check for malicious content
                        malicious_score = 0
                        for pattern in self.malicious_patterns:
                            if re.search(pattern, content, re.IGNORECASE):
                                malicious_score += 1
                        
                        if malicious_score > 0:
                            severity = 'CRITICAL' if malicious_score >= 3 else 'HIGH'
                            
                            findings.append({
                                'type': 'Supply Chain Tampering Detected',
                                'severity': severity,
                                'file': indicator,
                                'url': test_url,
                                'malicious_patterns': malicious_score,
                                'evidence': f'Tampering indicator found: {indicator} with {malicious_score} malicious patterns',
                                'impact': 'Potential supply chain compromise',
                                'cwe': 'CWE-506'
                            })
                
                await asyncio.sleep(0.2)
                
            except Exception:
                continue
        
        results['findings']['supply_chain_tampering'] = findings
        results['test_summary']['supply_chain_tampering'] = len(findings)

    async def _analyze_sbom_security(self, session: aiohttp.ClientSession, target: str, results: Dict) -> None:
        """Analyze Software Bill of Materials for security issues"""
        findings = []
        
        # Look for SBOM files
        sbom_files = [
            '/sbom.json', '/bom.xml', '/cyclonedx.json',
            '/software-bill-of-materials.json', '/.sbom/',
            '/SBOM.spdx', '/bill-of-materials.json'
        ]
        
        for sbom_file in sbom_files:
            test_url = f"{target}{sbom_file}"
            
            try:
                async with session.get(test_url) as response:
                    if response.status == 200:
                        content = await response.text()
                        
                        # Analyze SBOM for security issues
                        if len(content) > 100:  # Valid SBOM file
                            findings.append({
                                'type': 'SBOM File Exposure',
                                'severity': 'LOW',
                                'file': sbom_file,
                                'url': test_url,
                                'evidence': f'Software Bill of Materials exposed: {sbom_file}',
                                'impact': 'Detailed dependency information disclosure',
                                'cwe': 'CWE-200'
                            })
                            
                            # Check for vulnerable components in SBOM
                            if any(vuln_indicator in content.lower() for vuln_indicator in 
                                  ['vulnerable', 'cve-', 'security', 'exploit']):
                                findings.append({
                                    'type': 'Vulnerable Components in SBOM',
                                    'severity': 'HIGH',
                                    'file': sbom_file,
                                    'evidence': 'SBOM contains references to vulnerable components',
                                    'impact': 'Known vulnerable dependencies identified',
                                    'cwe': 'CWE-1395'
                                })
                
                await asyncio.sleep(0.3)
                
            except Exception:
                continue
        
        results['findings']['sbom_analysis'] = findings
        results['test_summary']['sbom_analysis'] = len(findings)

    def _calculate_risk_score(self, results: Dict) -> int:
        """Calculate overall supply chain risk score"""
        score = 0
        severity_weights = {'CRITICAL': 15, 'HIGH': 10, 'MEDIUM': 5, 'LOW': 2}
        
        for category, findings in results.get('findings', {}).items():
            for finding in findings:
                severity = finding.get('severity', 'LOW')
                score += severity_weights.get(severity, 2)
        
        # Add bonus for supply chain specific risks
        if results.get('packages_analyzed', 0) > 50:
            score += 10  # Large dependency footprint increases risk
        
        # Compile all vulnerabilities
        results['vulnerabilities'] = []
        for category, findings in results.get('findings', {}).items():
            results['vulnerabilities'].extend(findings)
        
        # Compile supply chain specific risks
        high_risk_findings = [v for v in results['vulnerabilities'] if v.get('severity') in ['CRITICAL', 'HIGH']]
        results['supply_chain_risks'] = high_risk_findings
        
        # Count critical vulnerabilities
        critical_count = sum(1 for vuln in results['vulnerabilities'] 
                           if vuln.get('severity') == 'CRITICAL')
        results['critical_vulnerabilities'] = critical_count
        
        return min(score, 100)  # Cap at 100

    def get_info(self) -> Dict[str, Any]:
        """Return agent information"""
        return {
            'name': self.name,
            'description': self.description,
            'version': self.version,
            'categories': list(self.test_categories.keys()),
            'ecosystems_supported': list(self.package_ecosystems.keys()),
            'test_types': [
                'Dependency Confusion Attack Detection',
                'Package Integrity Verification',
                'Malicious Package Detection',
                'Supply Chain Tampering Detection',
                'Private Repository Exposure Testing',
                'Software Bill of Materials Analysis',
                'Typosquatting Detection',
                'Third-Party Library Security Assessment'
            ],
            'attack_vectors': [
                'Dependency Confusion',
                'Typosquatting',
                'Package Integrity Compromise',
                'Malicious Package Injection',
                'Supply Chain Tampering',
                'Private Package Impersonation'
            ],
            'severity_levels': ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']
        }

