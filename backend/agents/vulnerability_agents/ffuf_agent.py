"""
Ffuf Agent for Nexus Hunter
Fast web fuzzer for directory/file discovery and parameter fuzzing
"""

import asyncio
import json
import tempfile
import os
from typing import Dict, List, Any, Optional
from pathlib import Path

import httpx
from loguru import logger

from agents.base import BaseAgent


class FfufAgent(BaseAgent):
    """Fast web fuzzer for comprehensive directory and parameter discovery"""
    
    def __init__(self):
        super().__init__("FfufAgent")
        self.wordlists = {
            "directory": [
                "/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt",
                "/usr/share/wordlists/dirb/common.txt",
                "/opt/SecLists/Discovery/Web-Content/directory-list-2.3-medium.txt",
                # Fallback wordlists
                "admin", "api", "backup", "config", "dev", "test", "staging", "uploads", "assets", 
                "js", "css", "img", "images", "files", "docs", "tmp", "temp", "cache", "log", "logs"
            ],
            "files": [
                "/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt", 
                "/opt/SecLists/Discovery/Web-Content/web-extensions.txt",
                # Common file extensions and names
                "index", "admin", "login", "config", "backup", "test", "robots.txt", "sitemap.xml",
                "web.config", ".htaccess", "phpinfo", "info", "debug", "status", "health"
            ],
            "parameters": [
                "/opt/SecLists/Discovery/Web-Content/burp-parameter-names.txt",
                # Common parameters
                "id", "user", "admin", "test", "debug", "q", "search", "query", "cmd", "exec",
                "file", "path", "dir", "page", "url", "redirect", "next", "return", "callback"
            ]
        }
    
    async def execute(self, target: str, config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Main execution method required by BaseAgent"""
        scan_type = config.get("scan_type", "directory") if config else "directory"
        return await self.scan(target, scan_type, **(config or {}))
    
    async def scan(self, target: str, scan_type: str = "directory", **kwargs) -> Dict[str, Any]:
        """
        Perform ffuf scan for directory/file/parameter discovery
        
        Args:
            target: Target URL to scan
            scan_type: Type of scan (directory, files, parameters)
            **kwargs: Additional scan options
        """
        try:
            results = {
                "target": target,
                "scan_type": scan_type,
                "discovered_paths": [],
                "discovered_files": [],
                "discovered_parameters": [],
                "statistics": {},
                "errors": []
            }
            
            # Check if ffuf is available
            if not await self._check_ffuf_installed():
                # Fallback to custom fuzzing logic
                return await self._custom_fuzzing(target, scan_type, **kwargs)
            
            # Perform ffuf scan
            if scan_type == "directory":
                results.update(await self._directory_discovery(target, **kwargs))
            elif scan_type == "files":
                results.update(await self._file_discovery(target, **kwargs))
            elif scan_type == "parameters":
                results.update(await self._parameter_discovery(target, **kwargs))
            elif scan_type == "comprehensive":
                # Run all scan types
                dir_results = await self._directory_discovery(target, **kwargs)
                file_results = await self._file_discovery(target, **kwargs)
                param_results = await self._parameter_discovery(target, **kwargs)
                
                results["discovered_paths"] = dir_results.get("discovered_paths", [])
                results["discovered_files"] = file_results.get("discovered_files", [])
                results["discovered_parameters"] = param_results.get("discovered_parameters", [])
            
            # Analyze and categorize findings
            results = await self._analyze_findings(results)
            
            return results
            
        except Exception as e:
            self.logger.error(f"Ffuf scan failed: {e}")
            return {"error": str(e), "target": target, "scan_type": scan_type}
    
    async def _check_ffuf_installed(self) -> bool:
        """Check if ffuf is installed"""
        try:
            process = await asyncio.create_subprocess_exec(
                "ffuf", "-h",
                stdout=asyncio.subprocess.DEVNULL,
                stderr=asyncio.subprocess.DEVNULL
            )
            await process.wait()
            return process.returncode == 0
        except FileNotFoundError:
            return False
    
    async def _directory_discovery(self, target: str, **kwargs) -> Dict[str, Any]:
        """Perform directory discovery using ffuf"""
        try:
            wordlist = await self._get_wordlist("directory")
            discovered_paths = []
            
            if isinstance(wordlist, list):
                # Use custom wordlist
                discovered_paths = await self._custom_directory_discovery(target, wordlist)
            else:
                # Use ffuf with wordlist file
                cmd = [
                    "ffuf",
                    "-u", f"{target}/FUZZ",
                    "-w", wordlist,
                    "-fc", "404,403",  # Filter common error codes
                    "-fs", "0",        # Filter by size
                    "-o", "/tmp/ffuf_output.json",
                    "-of", "json",
                    "-t", str(kwargs.get("threads", 50)),
                    "-rate", str(kwargs.get("rate", 100)),
                    "-timeout", str(kwargs.get("timeout", 10)),
                    "-s"  # Silent mode
                ]
                
                if kwargs.get("extensions"):
                    cmd.extend(["-e", kwargs["extensions"]])
                
                process = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                
                stdout, stderr = await process.communicate()
                
                if process.returncode == 0:
                    discovered_paths = await self._parse_ffuf_output("/tmp/ffuf_output.json")
            
            return {"discovered_paths": discovered_paths}
            
        except Exception as e:
            self.logger.error(f"Directory discovery failed: {e}")
            return {"discovered_paths": []}
    
    async def _file_discovery(self, target: str, **kwargs) -> Dict[str, Any]:
        """Perform file discovery using ffuf"""
        try:
            wordlist = await self._get_wordlist("files")
            discovered_files = []
            
            # Common file extensions to test
            extensions = kwargs.get("extensions", [
                ".php", ".asp", ".aspx", ".jsp", ".html", ".htm", ".js", ".css", 
                ".txt", ".xml", ".json", ".config", ".bak", ".old", ".tmp"
            ])
            
            if isinstance(wordlist, list):
                discovered_files = await self._custom_file_discovery(target, wordlist, extensions)
            else:
                # Use ffuf for file discovery
                for ext in extensions:
                    cmd = [
                        "ffuf",
                        "-u", f"{target}/FUZZ{ext}",
                        "-w", wordlist,
                        "-fc", "404,403",
                        "-o", f"/tmp/ffuf_files_{ext.replace('.', '')}.json",
                        "-of", "json",
                        "-t", str(kwargs.get("threads", 30)),
                        "-s"
                    ]
                    
                    process = await asyncio.create_subprocess_exec(
                        *cmd,
                        stdout=asyncio.subprocess.PIPE,
                        stderr=asyncio.subprocess.PIPE
                    )
                    
                    await process.communicate()
                    
                    if process.returncode == 0:
                        files = await self._parse_ffuf_output(f"/tmp/ffuf_files_{ext.replace('.', '')}.json")
                        discovered_files.extend(files)
            
            return {"discovered_files": discovered_files}
            
        except Exception as e:
            self.logger.error(f"File discovery failed: {e}")
            return {"discovered_files": []}
    
    async def _parameter_discovery(self, target: str, **kwargs) -> Dict[str, Any]:
        """Perform parameter discovery using ffuf"""
        try:
            wordlist = await self._get_wordlist("parameters")
            discovered_parameters = []
            
            if isinstance(wordlist, list):
                discovered_parameters = await self._custom_parameter_discovery(target, wordlist)
            else:
                # GET parameters
                cmd = [
                    "ffuf",
                    "-u", f"{target}?FUZZ=test",
                    "-w", wordlist,
                    "-fc", "404",
                    "-fs", "0",
                    "-o", "/tmp/ffuf_params_get.json",
                    "-of", "json",
                    "-t", str(kwargs.get("threads", 20)),
                    "-s"
                ]
                
                process = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                
                await process.communicate()
                
                if process.returncode == 0:
                    discovered_parameters = await self._parse_ffuf_output("/tmp/ffuf_params_get.json")
            
            return {"discovered_parameters": discovered_parameters}
            
        except Exception as e:
            self.logger.error(f"Parameter discovery failed: {e}")
            return {"discovered_parameters": []}
    
    async def _get_wordlist(self, wordlist_type: str) -> str:
        """Get appropriate wordlist for scan type"""
        wordlists = self.wordlists.get(wordlist_type, [])
        
        # Check if any wordlist files exist
        for wordlist_path in wordlists:
            if isinstance(wordlist_path, str) and wordlist_path.startswith("/") and os.path.exists(wordlist_path):
                return wordlist_path
        
        # Return built-in wordlist
        return wordlists
    
    async def _custom_fuzzing(self, target: str, scan_type: str, **kwargs) -> Dict[str, Any]:
        """Custom fuzzing implementation when ffuf is not available"""
        try:
            results = {
                "target": target,
                "scan_type": scan_type,
                "discovered_paths": [],
                "discovered_files": [],
                "discovered_parameters": [],
                "method": "custom_fuzzing"
            }
            
            wordlist = await self._get_wordlist(scan_type)
            if not isinstance(wordlist, list):
                wordlist = self.wordlists[scan_type]
            
            # Use httpx for custom fuzzing
            import httpx
            
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                semaphore = asyncio.Semaphore(10)  # Limit concurrent requests
                
                if scan_type in ["directory", "comprehensive"]:
                    tasks = []
                    for path in wordlist[:100]:  # Limit to avoid overwhelming
                        if isinstance(path, str):
                            task = self._test_path(client, semaphore, target, path)
                            tasks.append(task)
                    
                    path_results = await asyncio.gather(*tasks, return_exceptions=True)
                    results["discovered_paths"] = [r for r in path_results if r and not isinstance(r, Exception)]
                
                if scan_type in ["files", "comprehensive"]:
                    file_results = await self._custom_file_discovery(target, wordlist[:50], [".php", ".html", ".txt", ".js"])
                    results["discovered_files"] = file_results
            
            return results
            
        except Exception as e:
            self.logger.error(f"Custom fuzzing failed: {e}")
            return {"error": str(e)}
    
    async def _test_path(self, client: httpx.AsyncClient, semaphore: asyncio.Semaphore, target: str, path: str) -> Optional[Dict[str, Any]]:
        """Test a single path"""
        async with semaphore:
            try:
                if path.startswith("/"):
                    path = path[1:]
                
                url = f"{target.rstrip('/')}/{path}"
                response = await client.get(url, follow_redirects=True)
                
                if response.status_code not in [404, 403]:
                    return {
                        "url": url,
                        "path": path,
                        "status_code": response.status_code,
                        "content_length": len(response.content),
                        "content_type": response.headers.get("content-type", ""),
                        "method": "GET"
                    }
                
            except Exception as e:
                self.logger.debug(f"Path test failed for {path}: {e}")
            
            return None
    
    async def _custom_directory_discovery(self, target: str, wordlist: List[str]) -> List[Dict[str, Any]]:
        """Custom directory discovery implementation"""
        discovered = []
        
        try:
            import httpx
            
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                semaphore = asyncio.Semaphore(15)
                tasks = []
                
                for directory in wordlist[:100]:  # Limit for performance
                    if isinstance(directory, str):
                        task = self._test_path(client, semaphore, target, directory)
                        tasks.append(task)
                
                results = await asyncio.gather(*tasks, return_exceptions=True)
                discovered = [r for r in results if r and not isinstance(r, Exception)]
        
        except Exception as e:
            self.logger.error(f"Custom directory discovery failed: {e}")
        
        return discovered
    
    async def _custom_file_discovery(self, target: str, wordlist: List[str], extensions: List[str]) -> List[Dict[str, Any]]:
        """Custom file discovery implementation"""
        discovered = []
        
        try:
            import httpx
            
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                semaphore = asyncio.Semaphore(10)
                tasks = []
                
                for filename in wordlist[:50]:  # Limit for performance
                    for ext in extensions[:5]:  # Limit extensions
                        if isinstance(filename, str):
                            full_filename = f"{filename}{ext}"
                            task = self._test_path(client, semaphore, target, full_filename)
                            tasks.append(task)
                
                results = await asyncio.gather(*tasks, return_exceptions=True)
                discovered = [r for r in results if r and not isinstance(r, Exception)]
        
        except Exception as e:
            self.logger.error(f"Custom file discovery failed: {e}")
        
        return discovered
    
    async def _custom_parameter_discovery(self, target: str, wordlist: List[str]) -> List[Dict[str, Any]]:
        """Custom parameter discovery implementation"""
        discovered = []
        
        try:
            import httpx
            
            async with httpx.AsyncClient(timeout=10, verify=False) as client:
                base_response = await client.get(target)
                base_length = len(base_response.content)
                
                for param in wordlist[:30]:  # Limit for performance
                    if isinstance(param, str):
                        try:
                            test_url = f"{target}{'&' if '?' in target else '?'}{param}=test"
                            response = await client.get(test_url)
                            
                            # Check for different response (parameter might exist)
                            if len(response.content) != base_length or response.status_code != base_response.status_code:
                                discovered.append({
                                    "parameter": param,
                                    "url": test_url,
                                    "status_code": response.status_code,
                                    "content_length": len(response.content),
                                    "method": "GET"
                                })
                        
                        except Exception as e:
                            self.logger.debug(f"Parameter test failed for {param}: {e}")
        
        except Exception as e:
            self.logger.error(f"Custom parameter discovery failed: {e}")
        
        return discovered
    
    async def _parse_ffuf_output(self, output_file: str) -> List[Dict[str, Any]]:
        """Parse ffuf JSON output"""
        try:
            if not os.path.exists(output_file):
                return []
            
            with open(output_file, 'r') as f:
                data = json.load(f)
            
            results = []
            for result in data.get("results", []):
                results.append({
                    "url": result.get("url", ""),
                    "path": result.get("input", {}).get("FUZZ", ""),
                    "status_code": result.get("status", 0),
                    "content_length": result.get("length", 0),
                    "content_type": result.get("content-type", ""),
                    "method": result.get("method", "GET")
                })
            
            return results
            
        except Exception as e:
            self.logger.error(f"Failed to parse ffuf output: {e}")
            return []
    
    async def _analyze_findings(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze and categorize findings"""
        try:
            # Categorize discovered paths/files by potential interest level
            high_interest = []
            medium_interest = []
            low_interest = []
            
            interesting_paths = [
                "admin", "login", "config", "backup", "test", "debug", "api", "upload",
                "dashboard", "panel", "phpinfo", "info", "status", "health"
            ]
            
            sensitive_files = [
                ".htaccess", "web.config", "robots.txt", "sitemap.xml", ".git", ".env", 
                "config.php", "wp-config.php", "database.sql", "backup.sql"
            ]
            
            all_findings = (
                results.get("discovered_paths", []) + 
                results.get("discovered_files", []) + 
                results.get("discovered_parameters", [])
            )
            
            for finding in all_findings:
                path = finding.get("path", "").lower()
                url = finding.get("url", "").lower()
                
                is_high = any(keyword in path or keyword in url for keyword in interesting_paths)
                is_sensitive = any(keyword in path or keyword in url for keyword in sensitive_files)
                
                if is_high or is_sensitive:
                    high_interest.append(finding)
                elif finding.get("status_code") == 200:
                    medium_interest.append(finding)
                else:
                    low_interest.append(finding)
            
            results["categorized_findings"] = {
                "high_interest": high_interest,
                "medium_interest": medium_interest,
                "low_interest": low_interest
            }
            
            results["statistics"] = {
                "total_findings": len(all_findings),
                "high_priority": len(high_interest),
                "medium_priority": len(medium_interest),
                "low_priority": len(low_interest),
                "paths_found": len(results.get("discovered_paths", [])),
                "files_found": len(results.get("discovered_files", [])),
                "parameters_found": len(results.get("discovered_parameters", []))
            }
            
            return results
            
        except Exception as e:
            self.logger.error(f"Finding analysis failed: {e}")
            return results

    def get_scan_types(self) -> List[str]:
        """Get available scan types"""
        return ["directory", "files", "parameters", "comprehensive"]
    
    def get_description(self) -> str:
        """Get agent description"""
        return "Fast web fuzzer for directory, file, and parameter discovery using ffuf or custom implementation"

