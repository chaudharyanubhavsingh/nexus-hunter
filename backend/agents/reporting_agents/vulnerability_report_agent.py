"""
Vulnerability Report Agent
==========================

Advanced vulnerability report generation with comprehensive analysis,
CVSS scoring, remediation guidance, and professional formatting.
"""

import json
import time
from datetime import datetime
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, asdict
from enum import Enum

from loguru import logger
from agents.base import BaseAgent


class Severity(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "Critical"
    HIGH = "High"
    MEDIUM = "Medium"
    LOW = "Low"
    INFO = "Informational"


class VulnerabilityCategory(Enum):
    """Vulnerability categories"""
    INJECTION = "Injection"
    BROKEN_AUTH = "Broken Authentication"
    SENSITIVE_DATA = "Sensitive Data Exposure"
    XXE = "XML External Entities"
    BROKEN_ACCESS = "Broken Access Control"
    SECURITY_MISCONFIG = "Security Misconfiguration"
    XSS = "Cross-Site Scripting"
    INSECURE_DESERIALIZATION = "Insecure Deserialization"
    KNOWN_VULNS = "Using Components with Known Vulnerabilities"
    INSUFFICIENT_LOGGING = "Insufficient Logging & Monitoring"
    BUSINESS_LOGIC = "Business Logic Flaws"
    SSRF = "Server-Side Request Forgery"


@dataclass
class CVSSScore:
    """CVSS v3.1 scoring information"""
    base_score: float
    temporal_score: Optional[float] = None
    environmental_score: Optional[float] = None
    vector_string: str = ""
    severity: str = ""
    
    def __post_init__(self):
        if not self.severity:
            self.severity = self._calculate_severity()
    
    def _calculate_severity(self) -> str:
        """Calculate severity based on base score"""
        if self.base_score >= 9.0:
            return "Critical"
        elif self.base_score >= 7.0:
            return "High"
        elif self.base_score >= 4.0:
            return "Medium"
        elif self.base_score >= 0.1:
            return "Low"
        else:
            return "None"


@dataclass
class Vulnerability:
    """Comprehensive vulnerability information"""
    id: str
    title: str
    description: str
    category: VulnerabilityCategory
    severity: Severity
    cvss_score: CVSSScore
    affected_urls: List[str]
    evidence: List[str]
    impact: str
    likelihood: str
    risk_rating: str
    remediation: str
    references: List[str]
    cwe_id: Optional[str] = None
    owasp_category: Optional[str] = None
    discovered_by: str = ""
    discovery_date: str = ""
    retest_notes: List[str] = None
    
    def __post_init__(self):
        if not self.discovery_date:
            self.discovery_date = datetime.now().isoformat()
        if self.retest_notes is None:
            self.retest_notes = []


@dataclass
class ScanMetadata:
    """Scan execution metadata"""
    scan_id: str
    target: str
    start_time: str
    end_time: str
    duration_seconds: int
    tools_used: List[str]
    scan_type: str
    scope: List[str]
    exclusions: List[str]
    tester_name: str
    organization: str
    scan_version: str = "1.0"


@dataclass
class VulnerabilityReport:
    """Complete vulnerability assessment report"""
    metadata: ScanMetadata
    executive_summary: Dict[str, Any]
    vulnerabilities: List[Vulnerability]
    statistics: Dict[str, Any]
    recommendations: List[str]
    appendices: Dict[str, Any]
    report_generated: str = ""
    
    def __post_init__(self):
        if not self.report_generated:
            self.report_generated = datetime.now().isoformat()


class VulnerabilityReportAgent(BaseAgent):
    """Advanced vulnerability report generation agent"""
    
    def __init__(self):
        super().__init__("VulnerabilityReportAgent")
        self.report_templates = self._initialize_templates()
        self.cvss_calculator = CVSSCalculator()
        
    def _initialize_templates(self) -> Dict[str, str]:
        """Initialize report templates"""
        return {
            "executive_summary": """
# Executive Summary

## Assessment Overview
This security assessment was conducted on {target} from {start_date} to {end_date}. 
The assessment identified {total_vulns} vulnerabilities across {affected_systems} systems.

## Risk Summary
- **Critical**: {critical_count} vulnerabilities
- **High**: {high_count} vulnerabilities  
- **Medium**: {medium_count} vulnerabilities
- **Low**: {low_count} vulnerabilities
- **Informational**: {info_count} findings

## Key Findings
{key_findings}

## Business Impact
{business_impact}

## Recommendations
{top_recommendations}
            """,
            
            "vulnerability_detail": """
## {vuln_title}

**Severity**: {severity} ({cvss_score})  
**Category**: {category}  
**CWE**: {cwe_id}  
**OWASP**: {owasp_category}

### Description
{description}

### Impact
{impact}

### Affected Systems
{affected_urls}

### Evidence
{evidence}

### Remediation
{remediation}

### References
{references}
            """
        }
    
    async def execute(self, target: str, config: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Main execution method required by BaseAgent"""
        # For reporting agents, we expect scan results in config
        scan_results = config.get("scan_results", {}) if config else {}
        report = await self.generate_report(scan_results, config)
        return asdict(report)
    
    async def generate_report(
        self,
        scan_results: Dict[str, Any],
        config: Optional[Dict[str, Any]] = None
    ) -> VulnerabilityReport:
        """Generate comprehensive vulnerability report"""
        try:
            logger.info("ðŸ” Generating comprehensive vulnerability report")
            
            # Extract and process scan data
            metadata = self._extract_metadata(scan_results, config)
            vulnerabilities = await self._process_vulnerabilities(scan_results)
            statistics = self._calculate_statistics(vulnerabilities)
            executive_summary = self._generate_executive_summary(
                metadata, vulnerabilities, statistics
            )
            recommendations = self._generate_recommendations(vulnerabilities, statistics)
            appendices = self._generate_appendices(scan_results, vulnerabilities)
            
            report = VulnerabilityReport(
                metadata=metadata,
                executive_summary=executive_summary,
                vulnerabilities=vulnerabilities,
                statistics=statistics,
                recommendations=recommendations,
                appendices=appendices
            )
            
            logger.info(f"âœ… Generated report with {len(vulnerabilities)} vulnerabilities")
            return report
            
        except Exception as e:
            logger.error(f"âŒ Report generation failed: {e}")
            raise
    
    def _extract_metadata(
        self,
        scan_results: Dict[str, Any],
        config: Optional[Dict[str, Any]]
    ) -> ScanMetadata:
        """Extract scan metadata"""
        config = config or {}
        
        return ScanMetadata(
            scan_id=scan_results.get("scan_id", f"scan_{int(time.time())}"),
            target=scan_results.get("target", "Unknown"),
            start_time=scan_results.get("start_time", datetime.now().isoformat()),
            end_time=scan_results.get("end_time", datetime.now().isoformat()),
            duration_seconds=scan_results.get("duration", 0),
            tools_used=scan_results.get("tools_used", []),
            scan_type=config.get("scan_type", "Comprehensive Security Assessment"),
            scope=config.get("scope", []),
            exclusions=config.get("exclusions", []),
            tester_name=config.get("tester_name", "Nexus Hunter"),
            organization=config.get("organization", "Security Assessment Team")
        )
    
    async def _process_vulnerabilities(
        self,
        scan_results: Dict[str, Any]
    ) -> List[Vulnerability]:
        """Process and normalize vulnerabilities from scan results"""
        vulnerabilities = []
        vuln_id_counter = 1
        
        # Process vulnerabilities from different agents
        for agent_name, agent_results in scan_results.get("agent_results", {}).items():
            if not isinstance(agent_results, dict):
                continue
                
            agent_vulns = agent_results.get("vulnerabilities", [])
            if not isinstance(agent_vulns, list):
                continue
            
            for vuln_data in agent_vulns:
                try:
                    vuln = await self._normalize_vulnerability(
                        vuln_data, agent_name, vuln_id_counter
                    )
                    if vuln:
                        vulnerabilities.append(vuln)
                        vuln_id_counter += 1
                except Exception as e:
                    logger.warning(f"Failed to process vulnerability from {agent_name}: {e}")
                    continue
        
        # Sort by severity and CVSS score
        vulnerabilities.sort(
            key=lambda v: (
                self._severity_weight(v.severity),
                v.cvss_score.base_score
            ),
            reverse=True
        )
        
        return vulnerabilities
    
    async def _normalize_vulnerability(
        self,
        vuln_data: Dict[str, Any],
        agent_name: str,
        vuln_id: int
    ) -> Optional[Vulnerability]:
        """Normalize vulnerability data from different agents"""
        try:
            # Extract basic information
            title = vuln_data.get("name", vuln_data.get("title", "Unknown Vulnerability"))
            description = vuln_data.get("description", "No description available")
            severity_str = vuln_data.get("severity", "Medium").upper()
            
            # Map severity
            try:
                severity = Severity(severity_str.title())
            except ValueError:
                severity = Severity.MEDIUM
            
            # Calculate CVSS score
            cvss_score = await self._calculate_cvss_score(vuln_data, severity)
            
            # Determine category
            category = self._determine_category(vuln_data, agent_name)
            
            # Extract URLs
            affected_urls = self._extract_affected_urls(vuln_data)
            
            # Extract evidence
            evidence = self._extract_evidence(vuln_data)
            
            # Generate impact and remediation
            impact = self._generate_impact_description(vuln_data, severity)
            remediation = self._generate_remediation_guidance(vuln_data, category)
            
            # Extract references
            references = vuln_data.get("references", [])
            if isinstance(references, str):
                references = [references]
            
            return Vulnerability(
                id=f"VULN-{vuln_id:04d}",
                title=title,
                description=description,
                category=category,
                severity=severity,
                cvss_score=cvss_score,
                affected_urls=affected_urls,
                evidence=evidence,
                impact=impact,
                likelihood=self._assess_likelihood(vuln_data),
                risk_rating=self._calculate_risk_rating(severity, vuln_data),
                remediation=remediation,
                references=references,
                cwe_id=vuln_data.get("cwe", vuln_data.get("cwe_id")),
                owasp_category=self._map_owasp_category(category),
                discovered_by=agent_name
            )
            
        except Exception as e:
            logger.warning(f"Failed to normalize vulnerability: {e}")
            return None
    
    async def _calculate_cvss_score(
        self,
        vuln_data: Dict[str, Any],
        severity: Severity
    ) -> CVSSScore:
        """Calculate CVSS score for vulnerability"""
        # Check if CVSS data is already provided
        if "cvss" in vuln_data:
            cvss_data = vuln_data["cvss"]
            return CVSSScore(
                base_score=cvss_data.get("base_score", 0.0),
                vector_string=cvss_data.get("vector", ""),
                severity=cvss_data.get("severity", severity.value)
            )
        
        # Calculate based on severity and vulnerability characteristics
        base_score = self._estimate_cvss_base_score(vuln_data, severity)
        vector_string = self._generate_cvss_vector(vuln_data, severity)
        
        return CVSSScore(
            base_score=base_score,
            vector_string=vector_string,
            severity=severity.value
        )
    
    def _estimate_cvss_base_score(
        self,
        vuln_data: Dict[str, Any],
        severity: Severity
    ) -> float:
        """Estimate CVSS base score based on vulnerability characteristics"""
        # Base score mapping
        severity_scores = {
            Severity.CRITICAL: 9.5,
            Severity.HIGH: 7.5,
            Severity.MEDIUM: 5.0,
            Severity.LOW: 2.5,
            Severity.INFO: 0.0
        }
        
        base_score = severity_scores.get(severity, 5.0)
        
        # Adjust based on characteristics
        if "remote" in str(vuln_data).lower():
            base_score += 0.5
        if "authentication" in str(vuln_data).lower():
            base_score -= 0.5
        if "rce" in str(vuln_data).lower() or "command" in str(vuln_data).lower():
            base_score = max(base_score, 8.0)
        
        return min(10.0, max(0.0, base_score))
    
    def _generate_cvss_vector(
        self,
        vuln_data: Dict[str, Any],
        severity: Severity
    ) -> str:
        """Generate CVSS vector string"""
        # Simplified CVSS vector generation
        av = "N"  # Network
        ac = "L"  # Low complexity
        pr = "N"  # No privileges required
        ui = "N"  # No user interaction
        s = "U"   # Unchanged scope
        c = "H"   # High confidentiality impact
        i = "H"   # High integrity impact
        a = "H"   # High availability impact
        
        # Adjust based on vulnerability type
        vuln_str = str(vuln_data).lower()
        if "authentication" in vuln_str:
            pr = "L"
        if "user" in vuln_str or "click" in vuln_str:
            ui = "R"
        if severity in [Severity.LOW, Severity.INFO]:
            c = i = a = "L"
        elif severity == Severity.MEDIUM:
            c = i = a = "M"
        
        return f"CVSS:3.1/AV:{av}/AC:{ac}/PR:{pr}/UI:{ui}/S:{s}/C:{c}/I:{i}/A:{a}"
    
    def _determine_category(
        self,
        vuln_data: Dict[str, Any],
        agent_name: str
    ) -> VulnerabilityCategory:
        """Determine vulnerability category"""
        vuln_str = str(vuln_data).lower()
        
        # Map based on agent name
        agent_category_map = {
            "sql": VulnerabilityCategory.INJECTION,
            "xss": VulnerabilityCategory.XSS,
            "rce": VulnerabilityCategory.INJECTION,
            "lfi": VulnerabilityCategory.INJECTION,
            "ssrf": VulnerabilityCategory.SSRF,
            "xxe": VulnerabilityCategory.XXE,
            "auth": VulnerabilityCategory.BROKEN_AUTH,
            "jwt": VulnerabilityCategory.BROKEN_AUTH,
            "secret": VulnerabilityCategory.SENSITIVE_DATA,
            "ssl": VulnerabilityCategory.SECURITY_MISCONFIG,
            "api": VulnerabilityCategory.BROKEN_ACCESS
        }
        
        for key, category in agent_category_map.items():
            if key in agent_name.lower():
                return category
        
        # Map based on vulnerability content
        if any(term in vuln_str for term in ["injection", "sql", "nosql", "ldap"]):
            return VulnerabilityCategory.INJECTION
        elif any(term in vuln_str for term in ["xss", "script", "cross-site"]):
            return VulnerabilityCategory.XSS
        elif any(term in vuln_str for term in ["auth", "login", "session"]):
            return VulnerabilityCategory.BROKEN_AUTH
        elif any(term in vuln_str for term in ["secret", "key", "password", "token"]):
            return VulnerabilityCategory.SENSITIVE_DATA
        elif any(term in vuln_str for term in ["access", "authorization", "privilege"]):
            return VulnerabilityCategory.BROKEN_ACCESS
        elif any(term in vuln_str for term in ["config", "ssl", "tls", "header"]):
            return VulnerabilityCategory.SECURITY_MISCONFIG
        else:
            return VulnerabilityCategory.SECURITY_MISCONFIG
    
    def _extract_affected_urls(self, vuln_data: Dict[str, Any]) -> List[str]:
        """Extract affected URLs from vulnerability data"""
        urls = []
        
        # Common URL fields
        url_fields = ["url", "endpoint", "target", "affected_url", "location"]
        
        for field in url_fields:
            if field in vuln_data:
                url_value = vuln_data[field]
                if isinstance(url_value, str):
                    urls.append(url_value)
                elif isinstance(url_value, list):
                    urls.extend([str(u) for u in url_value])
        
        return list(set(urls))  # Remove duplicates
    
    def _extract_evidence(self, vuln_data: Dict[str, Any]) -> List[str]:
        """Extract evidence from vulnerability data"""
        evidence = []
        
        # Common evidence fields
        evidence_fields = ["evidence", "proof", "payload", "response", "request"]
        
        for field in evidence_fields:
            if field in vuln_data:
                evidence_value = vuln_data[field]
                if isinstance(evidence_value, str):
                    evidence.append(evidence_value)
                elif isinstance(evidence_value, list):
                    evidence.extend([str(e) for e in evidence_value])
        
        return evidence
    
    def _generate_impact_description(
        self,
        vuln_data: Dict[str, Any],
        severity: Severity
    ) -> str:
        """Generate impact description"""
        if "impact" in vuln_data:
            return vuln_data["impact"]
        
        # Generate based on severity and type
        impact_templates = {
            Severity.CRITICAL: "This vulnerability poses a critical risk to the organization and could lead to complete system compromise, data breach, or service disruption.",
            Severity.HIGH: "This vulnerability poses a high risk and could lead to significant data exposure, unauthorized access, or system compromise.",
            Severity.MEDIUM: "This vulnerability poses a moderate risk and could lead to limited data exposure or unauthorized access under certain conditions.",
            Severity.LOW: "This vulnerability poses a low risk but should be addressed to maintain security posture.",
            Severity.INFO: "This finding is informational and represents a security best practice or potential future risk."
        }
        
        return impact_templates.get(severity, "Impact assessment required.")
    
    def _generate_remediation_guidance(
        self,
        vuln_data: Dict[str, Any],
        category: VulnerabilityCategory
    ) -> str:
        """Generate remediation guidance"""
        if "remediation" in vuln_data:
            return vuln_data["remediation"]
        
        # Category-specific remediation templates
        remediation_templates = {
            VulnerabilityCategory.INJECTION: "Implement input validation, use parameterized queries, and apply the principle of least privilege.",
            VulnerabilityCategory.XSS: "Implement proper output encoding, Content Security Policy (CSP), and input validation.",
            VulnerabilityCategory.BROKEN_AUTH: "Implement multi-factor authentication, secure session management, and proper password policies.",
            VulnerabilityCategory.SENSITIVE_DATA: "Implement encryption at rest and in transit, secure key management, and data classification.",
            VulnerabilityCategory.BROKEN_ACCESS: "Implement proper authorization checks, role-based access control, and regular access reviews.",
            VulnerabilityCategory.SECURITY_MISCONFIG: "Review and harden security configurations, implement security baselines, and regular security assessments.",
            VulnerabilityCategory.SSRF: "Implement input validation, network segmentation, and whitelist allowed destinations.",
            VulnerabilityCategory.XXE: "Disable XML external entity processing, use secure XML parsers, and implement input validation."
        }
        
        return remediation_templates.get(
            category,
            "Consult with security team for appropriate remediation steps."
        )
    
    def _assess_likelihood(self, vuln_data: Dict[str, Any]) -> str:
        """Assess likelihood of exploitation"""
        # Simple likelihood assessment
        if "remote" in str(vuln_data).lower() and "authentication" not in str(vuln_data).lower():
            return "High"
        elif "authentication" in str(vuln_data).lower():
            return "Medium"
        else:
            return "Low"
    
    def _calculate_risk_rating(
        self,
        severity: Severity,
        vuln_data: Dict[str, Any]
    ) -> str:
        """Calculate overall risk rating"""
        likelihood = self._assess_likelihood(vuln_data)
        
        # Risk matrix
        risk_matrix = {
            (Severity.CRITICAL, "High"): "Critical",
            (Severity.CRITICAL, "Medium"): "High",
            (Severity.CRITICAL, "Low"): "High",
            (Severity.HIGH, "High"): "High",
            (Severity.HIGH, "Medium"): "High",
            (Severity.HIGH, "Low"): "Medium",
            (Severity.MEDIUM, "High"): "Medium",
            (Severity.MEDIUM, "Medium"): "Medium",
            (Severity.MEDIUM, "Low"): "Low",
            (Severity.LOW, "High"): "Low",
            (Severity.LOW, "Medium"): "Low",
            (Severity.LOW, "Low"): "Low",
            (Severity.INFO, "High"): "Low",
            (Severity.INFO, "Medium"): "Low",
            (Severity.INFO, "Low"): "Info"
        }
        
        return risk_matrix.get((severity, likelihood), "Medium")
    
    def _map_owasp_category(self, category: VulnerabilityCategory) -> str:
        """Map to OWASP Top 10 category"""
        owasp_mapping = {
            VulnerabilityCategory.INJECTION: "A03:2021 â€“ Injection",
            VulnerabilityCategory.BROKEN_AUTH: "A07:2021 â€“ Identification and Authentication Failures",
            VulnerabilityCategory.SENSITIVE_DATA: "A02:2021 â€“ Cryptographic Failures",
            VulnerabilityCategory.XXE: "A05:2021 â€“ Security Misconfiguration",
            VulnerabilityCategory.BROKEN_ACCESS: "A01:2021 â€“ Broken Access Control",
            VulnerabilityCategory.SECURITY_MISCONFIG: "A05:2021 â€“ Security Misconfiguration",
            VulnerabilityCategory.XSS: "A03:2021 â€“ Injection",
            VulnerabilityCategory.INSECURE_DESERIALIZATION: "A08:2021 â€“ Software and Data Integrity Failures",
            VulnerabilityCategory.KNOWN_VULNS: "A06:2021 â€“ Vulnerable and Outdated Components",
            VulnerabilityCategory.INSUFFICIENT_LOGGING: "A09:2021 â€“ Security Logging and Monitoring Failures",
            VulnerabilityCategory.SSRF: "A10:2021 â€“ Server-Side Request Forgery"
        }
        
        return owasp_mapping.get(category, "Not Classified")
    
    def _severity_weight(self, severity: Severity) -> int:
        """Get numeric weight for severity sorting"""
        weights = {
            Severity.CRITICAL: 5,
            Severity.HIGH: 4,
            Severity.MEDIUM: 3,
            Severity.LOW: 2,
            Severity.INFO: 1
        }
        return weights.get(severity, 0)
    
    def _calculate_statistics(self, vulnerabilities: List[Vulnerability]) -> Dict[str, Any]:
        """Calculate vulnerability statistics"""
        total_vulns = len(vulnerabilities)
        
        # Count by severity
        severity_counts = {}
        for severity in Severity:
            severity_counts[severity.value.lower()] = sum(
                1 for v in vulnerabilities if v.severity == severity
            )
        
        # Count by category
        category_counts = {}
        for category in VulnerabilityCategory:
            category_counts[category.value] = sum(
                1 for v in vulnerabilities if v.category == category
            )
        
        # CVSS statistics
        cvss_scores = [v.cvss_score.base_score for v in vulnerabilities if v.cvss_score.base_score > 0]
        avg_cvss = sum(cvss_scores) / len(cvss_scores) if cvss_scores else 0.0
        
        # Risk statistics
        risk_counts = {}
        for vuln in vulnerabilities:
            risk = vuln.risk_rating
            risk_counts[risk] = risk_counts.get(risk, 0) + 1
        
        return {
            "total_vulnerabilities": total_vulns,
            "severity_distribution": severity_counts,
            "category_distribution": category_counts,
            "average_cvss_score": round(avg_cvss, 1),
            "risk_distribution": risk_counts,
            "unique_affected_systems": len(set(
                url for vuln in vulnerabilities for url in vuln.affected_urls
            )),
            "remediation_priority": self._calculate_remediation_priority(vulnerabilities)
        }
    
    def _calculate_remediation_priority(self, vulnerabilities: List[Vulnerability]) -> List[str]:
        """Calculate remediation priority order"""
        priority_vulns = sorted(
            vulnerabilities,
            key=lambda v: (
                self._severity_weight(v.severity),
                v.cvss_score.base_score,
                len(v.affected_urls)
            ),
            reverse=True
        )
        
        return [v.id for v in priority_vulns[:10]]  # Top 10 priority
    
    def _generate_executive_summary(
        self,
        metadata: ScanMetadata,
        vulnerabilities: List[Vulnerability],
        statistics: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Generate executive summary"""
        severity_counts = statistics["severity_distribution"]
        
        # Key findings
        key_findings = []
        if severity_counts.get("critical", 0) > 0:
            key_findings.append(f"{severity_counts['critical']} critical vulnerabilities require immediate attention")
        if severity_counts.get("high", 0) > 0:
            key_findings.append(f"{severity_counts['high']} high-severity vulnerabilities pose significant risk")
        
        # Business impact assessment
        business_impact = self._assess_business_impact(vulnerabilities, statistics)
        
        # Top recommendations
        top_recommendations = self._generate_top_recommendations(vulnerabilities, statistics)
        
        return {
            "assessment_overview": {
                "target": metadata.target,
                "duration": f"{metadata.duration_seconds // 3600}h {(metadata.duration_seconds % 3600) // 60}m",
                "tools_used": len(metadata.tools_used),
                "total_vulnerabilities": statistics["total_vulnerabilities"],
                "affected_systems": statistics["unique_affected_systems"]
            },
            "risk_summary": severity_counts,
            "key_findings": key_findings,
            "business_impact": business_impact,
            "top_recommendations": top_recommendations,
            "overall_risk_rating": self._calculate_overall_risk_rating(statistics)
        }
    
    def _assess_business_impact(
        self,
        vulnerabilities: List[Vulnerability],
        statistics: Dict[str, Any]
    ) -> str:
        """Assess overall business impact"""
        critical_count = statistics["severity_distribution"].get("critical", 0)
        high_count = statistics["severity_distribution"].get("high", 0)
        
        if critical_count > 0:
            return "Critical business impact - immediate action required to prevent potential data breaches, system compromise, or service disruption."
        elif high_count > 3:
            return "High business impact - significant security risks that could lead to data exposure or unauthorized access."
        elif high_count > 0:
            return "Moderate business impact - security vulnerabilities present manageable risks that should be addressed promptly."
        else:
            return "Low business impact - security posture is generally good with minor improvements needed."
    
    def _generate_top_recommendations(
        self,
        vulnerabilities: List[Vulnerability],
        statistics: Dict[str, Any]
    ) -> List[str]:
        """Generate top-level recommendations"""
        recommendations = []
        
        # Priority based on vulnerability types
        category_counts = statistics["category_distribution"]
        
        if category_counts.get("Injection", 0) > 0:
            recommendations.append("Implement comprehensive input validation and parameterized queries")
        
        if category_counts.get("Cross-Site Scripting", 0) > 0:
            recommendations.append("Deploy Content Security Policy (CSP) and output encoding")
        
        if category_counts.get("Broken Authentication", 0) > 0:
            recommendations.append("Strengthen authentication mechanisms and session management")
        
        if category_counts.get("Security Misconfiguration", 0) > 0:
            recommendations.append("Review and harden security configurations across all systems")
        
        if category_counts.get("Sensitive Data Exposure", 0) > 0:
            recommendations.append("Implement encryption and secure data handling practices")
        
        # Add general recommendations
        recommendations.extend([
            "Establish regular security testing and code review processes",
            "Implement security awareness training for development teams",
            "Deploy automated security scanning in CI/CD pipelines"
        ])
        
        return recommendations[:5]  # Top 5 recommendations
    
    def _calculate_overall_risk_rating(self, statistics: Dict[str, Any]) -> str:
        """Calculate overall risk rating"""
        severity_counts = statistics["severity_distribution"]
        
        if severity_counts.get("critical", 0) > 0:
            return "Critical"
        elif severity_counts.get("high", 0) > 2:
            return "High"
        elif severity_counts.get("high", 0) > 0 or severity_counts.get("medium", 0) > 5:
            return "Medium"
        else:
            return "Low"
    
    def _generate_recommendations(
        self,
        vulnerabilities: List[Vulnerability],
        statistics: Dict[str, Any]
    ) -> List[str]:
        """Generate detailed recommendations"""
        recommendations = []
        
        # Immediate actions
        critical_vulns = [v for v in vulnerabilities if v.severity == Severity.CRITICAL]
        if critical_vulns:
            recommendations.append(
                f"IMMEDIATE: Address {len(critical_vulns)} critical vulnerabilities within 24-48 hours"
            )
        
        # Short-term actions (1-4 weeks)
        high_vulns = [v for v in vulnerabilities if v.severity == Severity.HIGH]
        if high_vulns:
            recommendations.append(
                f"SHORT-TERM: Remediate {len(high_vulns)} high-severity vulnerabilities within 1-4 weeks"
            )
        
        # Medium-term actions (1-3 months)
        medium_vulns = [v for v in vulnerabilities if v.severity == Severity.MEDIUM]
        if medium_vulns:
            recommendations.append(
                f"MEDIUM-TERM: Address {len(medium_vulns)} medium-severity vulnerabilities within 1-3 months"
            )
        
        # Process improvements
        recommendations.extend([
            "Implement secure development lifecycle (SDLC) practices",
            "Establish regular penetration testing schedule",
            "Deploy web application firewall (WAF) for immediate protection",
            "Implement security monitoring and incident response procedures",
            "Conduct security awareness training for all personnel",
            "Establish vulnerability management program",
            "Implement automated security testing in CI/CD pipeline"
        ])
        
        return recommendations
    
    def _generate_appendices(
        self,
        scan_results: Dict[str, Any],
        vulnerabilities: List[Vulnerability]
    ) -> Dict[str, Any]:
        """Generate report appendices"""
        return {
            "methodology": {
                "description": "This assessment was conducted using automated security scanning tools and manual verification techniques.",
                "tools_used": scan_results.get("tools_used", []),
                "testing_approach": "Black-box testing with authenticated and unauthenticated scans",
                "limitations": [
                    "Automated scanning may not identify all business logic flaws",
                    "Some vulnerabilities may require manual verification",
                    "Testing was limited to the defined scope"
                ]
            },
            "vulnerability_details": [asdict(v) for v in vulnerabilities],
            "cvss_scoring": {
                "version": "CVSS v3.1",
                "description": "Common Vulnerability Scoring System provides standardized vulnerability severity ratings",
                "score_ranges": {
                    "Critical": "9.0-10.0",
                    "High": "7.0-8.9", 
                    "Medium": "4.0-6.9",
                    "Low": "0.1-3.9",
                    "None": "0.0"
                }
            },
            "references": [
                "OWASP Top 10 - https://owasp.org/www-project-top-ten/",
                "NIST Cybersecurity Framework - https://www.nist.gov/cyberframework",
                "CWE/SANS Top 25 - https://cwe.mitre.org/top25/",
                "CVSS v3.1 Specification - https://www.first.org/cvss/v3.1/specification-document"
            ]
        }
    
    async def export_report(
        self,
        report: VulnerabilityReport,
        format_type: str = "json",
        output_path: Optional[str] = None
    ) -> str:
        """Export report in specified format"""
        try:
            if format_type.lower() == "json":
                content = json.dumps(asdict(report), indent=2, default=str)
                extension = "json"
            else:
                raise ValueError(f"Unsupported format: {format_type}")
            
            if not output_path:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                output_path = f"vulnerability_report_{timestamp}.{extension}"
            
            with open(output_path, 'w') as f:
                f.write(content)
            
            logger.info(f"âœ… Report exported to {output_path}")
            return output_path
            
        except Exception as e:
            logger.error(f"âŒ Report export failed: {e}")
            raise


class CVSSCalculator:
    """CVSS v3.1 score calculator"""
    
    def calculate_base_score(
        self,
        attack_vector: str,
        attack_complexity: str,
        privileges_required: str,
        user_interaction: str,
        scope: str,
        confidentiality: str,
        integrity: str,
        availability: str
    ) -> float:
        """Calculate CVSS v3.1 base score"""
        # Simplified CVSS calculation
        # In a real implementation, this would follow the official CVSS formula
        
        # Impact subscore
        impact_scores = {"H": 0.56, "M": 0.22, "L": 0.0}
        iss = 1 - ((1 - impact_scores.get(confidentiality, 0)) * 
                   (1 - impact_scores.get(integrity, 0)) * 
                   (1 - impact_scores.get(availability, 0)))
        
        # Exploitability subscore  
        av_scores = {"N": 0.85, "A": 0.62, "L": 0.55, "P": 0.2}
        ac_scores = {"L": 0.77, "H": 0.44}
        pr_scores = {"N": 0.85, "L": 0.62, "H": 0.27}
        ui_scores = {"N": 0.85, "R": 0.62}
        
        exploitability = (av_scores.get(attack_vector, 0.85) * 
                         ac_scores.get(attack_complexity, 0.77) * 
                         pr_scores.get(privileges_required, 0.85) * 
                         ui_scores.get(user_interaction, 0.85))
        
        # Base score calculation
        if iss <= 0:
            return 0.0
        
        if scope == "U":
            base_score = min(10.0, (iss + exploitability))
        else:
            base_score = min(10.0, 1.08 * (iss + exploitability))
        
        return round(base_score, 1)
